<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Untitled_Dungeon_Crawler</title>
<style>
:root{
  --bg:#0f1720;
  --panel:#121c27;
  --chip:#172332;
  --chipBorder:#243241;
  --text:#d9e7f5;
  --hp1:#ff9a8b;
  --hp2:#ff6a88;
  --mp1:#9cd3ff;
  --mp2:#79baff;
  /* NEW: Stamina Colors */
  --stm1:#15803d; 
  --stm2:#166534;
.hp.poison .fill{ background:linear-gradient(90deg,#22c55e,#16a34a) }
/* NEW: Stamina Bar Class */
.stamina .fill{ background:linear-gradient(90deg,var(--stm1),var(--stm2)) }

}
/* base floating button stack ‚Äî hidden by default (desktop) */
.fabs{
  position:absolute;
  right:8px;
  top:8px;                    /* desktop anchor doesn't matter since hidden */
  display:none;               /* HIDE ON DESKTOP */
  flex-direction:column;
  gap:10px;
  pointer-events:none;        /* clicks only on children */
  z-index:6;                  /* above canvas/joystick */
}
.fab{ pointer-events:auto; }

/* phones/tablets only */
@media (hover:none) and (pointer:coarse){
  .joystick{ display:block; }   /* show joystick on touch devices */

  /* Action buttons at the TOP of the canvas and a bit smaller */
  .fabs{
    display:flex;
    flex-direction:row;         /* horizontal row */
    gap:12px;
    top:8px;                    /* move to top */
    right:8px;
    bottom:auto;                /* ensure not anchored to bottom anymore */
  }
  .fab.small{ width:44px; height:44px; font-size:18px; }

  #runTimer{
  top:8px;
  left:8px;
  z-index:20;    /* above boss bar/buttons */
  display:block;
}

  /* ‚Üì ADD THIS: drop the boss bar under the top buttons on phones */
  #bossHud{
    top:64px !important;                     /* 8px (margin) + 44px (button) + ~12px gap */
    width:min(640px, calc(100% - 16px));     /* keeps it fitting on small screens */
  }
}
/* Mobile joystick visuals (make sure these exist) */
.joystick{
  position:absolute; left:8px; bottom:8px;
  width:120px; height:120px; display:none; z-index:6;
}
.joy-base{
  position:absolute; inset:0; border-radius:999px;
  background:rgba(18,28,39,0.55); border:1px solid var(--chipBorder);
}
.joy-stick{
  position:absolute; left:50%; top:50%;
  width:56px; height:56px; margin:-28px 0 0 -28px;
  border-radius:999px; background:rgba(34,51,68,0.85);
  border:1px solid var(--chipBorder); box-shadow:0 0 0 2px rgba(0,0,0,.15) inset;
}


/* Wheel container and arrow */
#wheelContainer {
  position: relative;
  width: 180px;
  height: 180px;
  margin: 0 auto;
}

#jesterWheel {
  width: 100%;
  height: 100%;
  transition: transform 4s ease-out;
}

@keyframes glow {
  0%,100% { filter: brightness(1); }
  50%     { filter: brightness(1.5); }
}
#jesterWheel.glow {
  animation: glow 1s infinite;
}

/* Arrow centered at the TOP of the wheel, pointing DOWN */
#jesterArrow {
  position: absolute;
  top: 1px;                   /* move tip down onto the wheel */
  left: 50%;
  transform: translateX(-50%);
  width: 0;
  height: 0;
  border-left: 12px solid transparent;
  border-right: 12px solid transparent;
  border-top: 20px solid #f9d65c;  /* triangle pointing DOWN */
  pointer-events: none;
  z-index: 2;                 /* ensure it‚Äôs above the canvas */
}




/* Base floating button stack ‚Äì keep hidden on desktop but anchor to TOP-RIGHT */
.fabs{
  position:absolute; right:8px; top:8px;
  display:none;                /* hidden on desktop */
  flex-direction:column; gap:10px;
  pointer-events:none; z-index:6;
}
.fab{ pointer-events:auto; }

/* Phones/tablets */
@media (hover:none) and (pointer:coarse){
  .joystick{ display:block; }   /* show joystick on touch devices */

  /* Action buttons at the TOP of the canvas and a bit smaller */
  .fabs{
    display:flex;
    flex-direction:row;         /* horizontal row */
    gap:12px;
    top:8px;                    /* move to top */
    right:8px;
    bottom:auto;                /* ensure not anchored to bottom anymore */
  }
  .fab.small{ width:44px; height:44px; font-size:18px; }
}

/* Show mobile controls whenever touch is detected (Android-proof) */
.touch .joystick{ display:block; }
.touch .fabs{
  display:flex;
  flex-direction:row;
  gap:12px;
  top:8px; right:8px; bottom:auto;
}
.touch .fab.small{ width:44px; height:44px; font-size:18px; }

  /* Mobile/touch layout for timer + boss bar */
  .touch #runTimer{
    top:8px;
    left:8px;
    z-index:20;
    display:block;
  }

  .touch #bossHud{
    top:64px !important;                     /* move boss bar down on touch devices */
    width:min(640px, calc(100% - 16px));     /* keep margin from edges */
  }



*{box-sizing:border-box}
html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu;overscroll-behavior:none;}
.app{max-width:800px;margin:0 auto;padding:10px 10px 40px;}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.chip{background:var(--chip);border:1px solid var(--chipBorder);padding:10px 14px;border-radius:14px;font-weight:600;font-size:14px;line-height:1;color:var(--text);}
.chip.button{cursor:pointer;user-select:none}
.level{margin-left:auto}
.card{background:var(--panel);border:1px solid var(--chipBorder);border-radius:16px;padding:12px;margin-top:10px}
.canvasWrap{position:relative;height:54vh;min-height:360px;border-radius:16px;overflow:hidden;border:1px solid var(--chipBorder);background:#0b141d;}
canvas{display:block;width:100%;height:100%;image-rendering:pixelated;touch-action:none;}

.fab{pointer-events:auto;width:56px;height:56px;border-radius:14px;background:rgba(18,28,39,0.85);border:1px solid var(--chipBorder);display:flex;align-items:center;justify-content:center;font-weight:900;font-size:22px;color:var(--text);}
.fab.small{width:52px;height:52px;font-size:20px}
.bars{display:grid;grid-template-columns:auto 1fr 72px;align-items:center;gap:10px;margin-top:10px}
.bar{height:12px;border-radius:999px;background:#0e1a25;position:relative;overflow:hidden;border:1px solid var(--chipBorder)}
.bar>.fill{position:absolute;left:0;top:0;bottom:0;border-radius:999px}
.hp .fill{background:linear-gradient(90deg,var(--hp1),var(--hp2))}
.mp .fill{background:linear-gradient(90deg,var(--mp1),var(--mp2))}
.list{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
#equipRow{margin-top:2px; transform:translateY(-2px)}
.skill{
  background:var(--chip);
  border:1px solid var(--chipBorder);
  padding:10px 14px;
  border-radius:12px;
  font-weight:600;
  font-size:14px;
  color:var(--text);            /* ‚Üê add this line */
}
button.skill{
  -webkit-appearance:none;
  appearance:none;
  background:var(--chip);
  color:var(--text);
  border:1px solid var(--chipBorder);
  font:inherit;
}
button.skill:focus-visible{ outline:2px solid #3b82f6; outline-offset:2px; }
button.skill:disabled{ opacity:.6; cursor:not-allowed; }

.log{background:var(--panel);border:1px solid var(--chipBorder);border-radius:16px;margin-top:10px;padding:12px;max-height:22vh;overflow:auto}
/* Keep the modal header always reachable */
.modal .sheet .row:first-child{
  position:sticky;
  top:0;
  z-index:2;
  padding-bottom:8px;
  margin-bottom:8px;
  background:var(--panel);
  border-bottom:1px solid var(--chipBorder);
}

/* Scroll area for Inventory & Spells content */
#invBody,
#spellBody{
  flex:1;                               /* fill remaining height */
  overflow:auto;                        /* enable scrolling */
  -webkit-overflow-scrolling:touch;     /* momentum scroll on iOS */
}

/* Modal backdrop + bounded, flex sheet */
.modal{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.5);   /* if you ever see 5, change to .5 */
  display:none;
  align-items:center;
  justify-content:center;
  padding:14px;
  z-index:5;
}
/* Make the High Score table responsive */
#hiscoreTable{
  grid-template-columns: 96px 1fr 1fr 1fr 1fr !important;
  gap:8px 12px !important;
}
@media (hover:none) and (pointer:coarse){
  #hiscoreTable{
    grid-template-columns: 64px 64px 1fr 56px 56px !important;
    gap:6px 10px !important;
    font-size:14px;
  }
  /* Optional: tidy alignment */
  #hiscoreTable > div { text-align:center; }
  #hiscoreTable > div:nth-child(5n+1) { text-align:left; }   /* ‚ÄúInitials‚Äù column */
}


.modal>.sheet{
  width:min(520px,92vw);
  max-height:92vh;             /* NEW: cap height to viewport */
  display:flex;                /* NEW: header + body column layout */
  flex-direction:column;       /* NEW */
  background:var(--panel);
  border:1px solid var(--chipBorder);
  border-radius:16px;
  padding:14px;
}

.modal .title{font-weight:800;margin-bottom:6px}
.modal .row{justify-content:space-between}
.btn{background:#1b2a3a;border:1px solid var(--chipBorder);color:var(--text);padding:10px 14px;border-radius:10px;font-weight:700}
.btn.choice{min-width:120px}
body.noscroll{position:fixed;width:100%}
/* --- Start screen title, mobile-friendly --- */

/* ====== Full-screen overlays ====== */
.fullOverlay{
  position:fixed; inset:0; z-index:9999;
  display:flex; align-items:center; justify-content:center;
  background:#0b141d;
  color:#dfe7f2;
  text-align:center;
}

/* Title screen */
.ts-inner{ display:flex; flex-direction:column; gap:min(4vh, 28px); align-items:center; padding: min(6vh, 40px) 4vw; }
.ts-image{
  width:min(900px, 88vw);
  max-height:60vh; object-fit:contain; object-position:center;
  filter: drop-shadow(0 12px 30px rgba(0,0,0,.45));
}
.ts-press{
  font-weight:900;
  font-size: clamp(18px, 4.5vw, 44px);
  letter-spacing:.02em;
  opacity:.85;
  animation: pulse 1.4s ease-in-out infinite;
}
@keyframes pulse { 0%{opacity:.35} 50%{opacity:1} 100%{opacity:.35} }

/* Main Menu */
.menu-inner{
  position:relative; width:100%; height:100%;
  display:flex; align-items:center; justify-content:center;
  padding: min(6vh, 40px) 4vw;
}
.menu-image{
  position:absolute; inset:0; width:100%; height:100%;
  object-fit:cover; object-position:center;
  filter: brightness(.45) saturate(1.1);
  z-index:-1;
}
.menuCard{
  background:rgba(16,26,36,.72);
  border:1px solid rgba(255,255,255,.12);
  border-radius:18px;
  padding:min(3vh, 22px) min(4vw, 28px);
  backdrop-filter: blur(6px);
  box-shadow: 0 15px 40px rgba(0,0,0,.35);
  display:flex; flex-direction:column; gap:16px; min-width:min(520px, 92vw);
}
.menuTitle{
  font-weight:900;
  font-size: clamp(24px, 5.5vw, 52px);
  letter-spacing:.01em;
  text-shadow: 0 4px 10px rgba(0,0,0,.55);
  margin-bottom:4px;
}
.menuCol{ display:flex; flex-direction:column; gap:12px; }
.menuBtn{
  -webkit-appearance:none; appearance:none;
  background:#1b2a3a; color:#d9e7f5; border:1px solid var(--chipBorder);
  padding:14px 18px; border-radius:12px; font-weight:800; font-size:18px;
  cursor:pointer; transition:transform .06s ease, background .15s;
}
.menuBtn:hover{ transform:translateY(-1px); background:#213247; }
.menuBtn:active{ transform:translateY(0); }
.menuBtn[disabled], .menuBtn[aria-disabled="true"]{
  opacity:.5; cursor:not-allowed; filter:grayscale(.2);
}
.menuBtn.outline{ background:transparent; }
.menuBtn.ghost{ background:transparent; border-color:rgba(255,255,255,.16); }


#startGate{ padding: min(6vh, 40px) 4vw; }
.start-title{
  font-weight: 700;
  font-size: clamp(22px, 6vw, 64px);
  line-height: 1.1;
  margin-bottom: min(2vh, 16px);
  text-align: center;
}
.game-title{
  font-weight: 800;
  font-size: clamp(28px, 14vw, 150px);
  line-height: 0.95;
  color: #8B0000;                 /* change this fill color as you like */
  text-align: center;
  text-wrap: balance;
  -webkit-text-stroke: max(5px, 0.6vw) #000000;  /* scalable outline */
  paint-order: stroke fill;
  max-width: 92vw;
  margin: 0 auto;
}

/* ====== Step 3 ‚Äî Title/Menu/Credits CSS (paste near end of <style>) ====== */

/* Fallback for border color if not already defined */
:root{
  --chipBorder: rgba(255,255,255,.18);
}

/* Prevent background scroll when modals/overlays are open */
body.noscroll{
  overflow: hidden;
}

/* Full-screen overlays shared by Title, Menu, Credits */
.fullOverlay{
  position: fixed;
  inset: 0;
  z-index: 9999;              /* ensure above HUD/canvas */
  display: flex;
  align-items: center;
  justify-content: center;
  background: #0b141d;        /* dark fallback under images */
  color: #dfe7f2;
  text-align: center;
}

/* ===== Title screen bits ===== */
.ts-inner{
  display: flex;
  flex-direction: column;
  gap: min(4vh, 28px);
  align-items: center;
  padding: min(6vh, 40px) 4vw;
}

.ts-image{
  width: min(900px, 88vw);
  max-height: 60vh;
  object-fit: contain;
  object-position: center;
  filter: drop-shadow(0 12px 30px rgba(0,0,0,.45));
}

.ts-press{
  font-weight: 900;
  font-size: clamp(18px, 4.5vw, 44px);
  letter-spacing: .02em;
  opacity: .85;
  animation: pulse 1.4s ease-in-out infinite;
}

.ts-actions{
  display: flex;
  gap: 10px;
  align-items: center;
  justify-content: center;
}

/* subtle pulse */
@keyframes pulse {
  0% { opacity: .35; }
  50% { opacity: 1; }
  100% { opacity: .35; }
}

/* ===== Main Menu card ===== */
.menu-inner{
  position: relative;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: min(6vh, 40px) 4vw;
}

.menu-image{
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  object-position: center;
  filter: brightness(.45) saturate(1.1);
  z-index: -1; /* sit behind the content */
}

.menuCard{
  background: rgba(16,26,36,.72);
  border: 1px solid rgba(255,255,255,.12);
  border-radius: 18px;
  padding: min(3vh, 22px) min(4vw, 28px);
  backdrop-filter: blur(6px);
  box-shadow: 0 15px 40px rgba(0,0,0,.35);
  display: flex;
  flex-direction: column;
  gap: 16px;
  min-width: min(520px, 92vw);
}

.menuTitle{
  font-weight: 900;
  font-size: clamp(24px, 5.5vw, 52px);
  letter-spacing: .01em;
  text-shadow: 0 4px 10px rgba(0,0,0,.55);
  margin-bottom: 4px;
}

.menuCol{ display: flex; flex-direction: column; gap: 12px; }

.menuBtn{
  -webkit-appearance: none; appearance: none;
  background: #1b2a3a;
  color: #d9e7f5;
  border: 1px solid var(--chipBorder);
  padding: 14px 18px;
  border-radius: 12px;
  font-weight: 800;
  font-size: 18px;
  cursor: pointer;
  transition: transform .06s ease, background .15s;
}
.menuBtn:hover{ transform: translateY(-1px); background: #213247; }
.menuBtn:active{ transform: translateY(0); }
.menuBtn[disabled], .menuBtn[aria-disabled="true"]{
  opacity: .5; cursor: not-allowed; filter: grayscale(.2);
}
.menuBtn.outline{ background: transparent; }
.menuBtn.ghost{ background: transparent; border-color: rgba(255,255,255,.16); }

/* ===== Full-screen Credits overlay ===== */
.creditsWrap{
  position: relative;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: min(6vh, 40px) 4vw;
}

.creditsBg{
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  object-position: center;
  filter: brightness(.45) saturate(1.1);
  z-index: -1;
}

/* scrollable content area for long credits */
.creditsCard{
  background: rgba(16,26,36,.78);
  border: 1px solid rgba(255,255,255,.12);
  border-radius: 18px;
  padding: min(3vh, 22px) min(4vw, 28px);
  backdrop-filter: blur(6px);
  box-shadow: 0 15px 40px rgba(0,0,0,.35);
  width: min(900px, 94vw);
  max-height: 88vh;      /* allows scrolling if long */
  overflow: auto;
}
.creditsTitle{
  font-weight: 900;
  font-size: clamp(24px, 5.5vw, 52px);
  margin-bottom: 10px;
  text-shadow: 0 4px 10px rgba(0,0,0,.55);
}
.creditsBody{ font-size: 18px; line-height: 1.5; opacity: .95 }

/* top-right close button for full overlays */
.closeBtn{
  position: absolute;
  right: 18px;
  top: 18px;
  z-index: 2;
  background: #1b2a3a;
  color: #dfe7f2;
  border: 1px solid var(--chipBorder);
  padding: 10px 14px;
  border-radius: 10px;
  font-weight: 800;
}

/* Lower the "Press to Start" text on the title screen */
#titleScreen .ts-inner{
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100dvh;   /* full screen height */
}

#titleScreen .ts-press{
  margin-top: auto;     /* pushes it to the bottom of the column */
  margin-bottom: 12vh;  /* distance from bottom ‚Äì tweak to taste */
}

/* Left-edge floating text menu */
.menuList{
  position:absolute;
  left:clamp(16px, 4vw, 48px);     /* ‚Äúedge of the left side‚Äù */
  top:50%;
  transform:translateY(-50%);
  display:flex;
  flex-direction:column;
  gap:18px;
  z-index:2;
}

.menuLink{
  display:inline-block;
  color:#e8f1fb;
  text-decoration:none;
  font-weight:900;
  font-size:clamp(16px, 3vw, 20px);
  letter-spacing:.01em;
  text-shadow:0 3px 10px rgba(0,0,0,.45);
  opacity:.95;
  cursor:pointer;
  transition:transform .08s ease, opacity .12s ease;
}

.menuLink:hover,
.menuLink:focus-visible{
  transform:translateX(4px);
  opacity:1;
  outline:none;
}

.menuLink.disabled{
  opacity:.45;
  pointer-events:none;
}

/* Optional: tone down/hide the old card if still present anywhere */
.menuCard{ display:none !important; }

/* --- NEW SETTINGS UI --- */
#settingsOverlay .creditsCard {
  width: min(800px, 96vw); height: min(600px, 90vh);
  padding: 0; display: flex; flex-direction: column; overflow: hidden;
}
.settings-header {
  padding: 20px; border-bottom: 1px solid rgba(255,255,255,0.1);
  display: flex; justify-content: space-between; align-items: center; background: rgba(0,0,0,0.2);
}
.settings-header .title { font-weight: 900; font-size: 28px; letter-spacing: 1px; color: #f9d65c; margin:0; }
.settings-body { display: flex; flex: 1; overflow: hidden; }
.settings-nav {
  width: 200px; background: rgba(0,0,0,0.3); border-right: 1px solid rgba(255,255,255,0.1);
  display: flex; flex-direction: column; padding: 10px; gap: 8px;
}
.tab-btn {
  background: transparent; border: 1px solid transparent; color: #9ca3af;
  padding: 12px 16px; text-align: left; font-weight: 700; font-size: 16px;
  border-radius: 8px; cursor: pointer; transition: all 0.2s;
}
.tab-btn:hover { background: rgba(255,255,255,0.05); color: #fff; }
.tab-btn.active {
  background: #1b2a3a; border-color: var(--chipBorder); color: #f9d65c;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}
.settings-content {
  flex: 1; padding: 24px; overflow-y: auto; background: rgba(20, 26, 35, 0.4); text-align:left;
}
.settings-panel { display: none; animation: fadeIn 0.2s ease-out; }
.settings-panel.active { display: block; }
.vol-group { margin-bottom: 20px; }
.vol-header { display: flex; justify-content: space-between; margin-bottom: 6px; font-weight: 600; font-size: 14px; color: #d9e7f5; }
input[type=range].custom-slider { -webkit-appearance: none; width: 100%; background: transparent; }
input[type=range].custom-slider:focus { outline: none; }
input[type=range].custom-slider::-webkit-slider-runnable-track {
  width: 100%; height: 8px; cursor: pointer; background: #0b141d; border-radius: 4px; border: 1px solid #374151;
}
input[type=range].custom-slider::-webkit-slider-thumb {
  height: 20px; width: 12px; border-radius: 2px; background: #f9d65c; border: 1px solid #b45309;
  cursor: pointer; -webkit-appearance: none; margin-top: -7px; box-shadow: 0 0 5px rgba(249, 214, 92, 0.5);
}
@media (max-width: 600px) {
  .settings-body { flex-direction: column; }
  .settings-nav { width: 100%; flex-direction: row; overflow-x: auto; padding: 8px; flex: none; }
  .tab-btn { flex: 1; text-align: center; padding: 10px; font-size: 14px; white-space: nowrap; }
}


</style>


<script>
(function(){
  const onTouch = ()=> document.documentElement.classList.add('touch');
  window.addEventListener('touchstart', onTouch, { once:true, passive:true });
  window.addEventListener('pointerdown', e=>{
    if (e.pointerType && e.pointerType !== 'mouse') onTouch();
  }, { once:true });
})();
</script>


</head>
<body>
 <!-- ====== TITLE SCREEN (full-screen) ====== -->
<div id="titleScreen"
     class="fullOverlay"
     tabindex="0"
     aria-label="Title Screen"
     style="background: url('https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawler@main/testing_title_screen.png') center / cover no-repeat #0b141d;">
  <div class="ts-inner">
    <div class="ts-press">Press to Start</div>
  </div>
</div>


<!-- ====== MAIN MENU (full-screen) ====== -->
<div id="mainMenu" class="fullOverlay" style="display:none;" tabindex="0" aria-label="Main Menu">
  <div class="menu-inner">
    <!-- Your menu background image -->
    <img class="menu-image" src="https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawler@main/testing_title_screen.png" alt="Main Menu Image" />
    <!-- Left-edge floating options -->
    <nav class="menuList" aria-label="Main Menu" id="menuRoot">
      <div id="mm-main" style="display:flex; flex-direction:column; gap:18px;">
        <a id="btnMenuPlay" class="menuLink" href="#">Play</a>
        <a id="btnMenuStats" class="menuLink" href="#">Stats</a>
        <a id="btnShop" class="menuLink" href="#" style="color:#f9d65c">Soul Shop (0)</a>
        <a id="btnSettings" class="menuLink" href="#">Settings</a>
        <a id="btnCredits" class="menuLink" href="#">Credits</a>
      </div>

      <div id="mm-play" style="display:none; flex-direction:column; gap:18px;">
        <a id="btnMenuBackPlay" class="menuLink" href="#" style="opacity:0.6; font-size:14px;">&lt; Back</a>
        <a id="btnTutorial" class="menuLink" href="#">Tutorial Mode</a>
        <a id="btnClassic"  class="menuLink" href="#">Classic Mode</a>
        <span id="btnEndless" class="menuLink disabled" aria-disabled="true" title="Unlock after beating Classic">???</span>
      </div>

      <div id="mm-stats" style="display:none; flex-direction:column; gap:18px;">
        <a id="btnMenuBackStats" class="menuLink" href="#" style="opacity:0.6; font-size:14px;">&lt; Back</a>
        <a id="btnCodex" class="menuLink" href="#">Codex</a>
        <a id="btnShowLeaderboard" class="menuLink" href="#">Leaderboard</a>
      </div>
    </nav>
  </div>
</div>

<!-- ====== Codex ====== -->
<div id="codexOverlay" class="fullOverlay" style="display:none;" aria-label="Codex">
  <div class="creditsWrap">
    <button class="btn closeBtn" data-close="#codexOverlay" title="Close">Close</button>
    <img class="creditsBg" src="https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawler@main/testing_title_screen.png" alt="" />
    
    <div class="creditsCard" style="text-align:left;">
      <div class="creditsTitle" style="text-align:center;">Dungeon Codex</div>
      <div id="codexContent" style="display:grid; grid-template-columns:1fr; gap:16px;">
        </div>
    </div>
  </div>
</div>

<!-- ====== Shop ====== -->
<div class="modal" id="shopModal" style="display:none; z-index: 10001;"> <div class="sheet">
    <div class="row">
      <div class="title">Soul Shop</div>
      <button class="btn" data-close="#shopModal">Close</button>
    </div>
    
    <div class="row" style="gap:10px; justify-content:center; margin-bottom:8px;">
      <button class="btn" id="btnShopClassic" style="flex:1;">Classic</button>
      <button class="btn" id="btnShopEndless" style="flex:1;">Endless</button>
    </div>

    <div style="text-align:center; margin-bottom:10px; opacity:0.8">
      <span id="shopModeLabel">Classic Upgrades</span><br>
      <span style="color:#f9d65c; font-weight:bold;" id="shopBalance">0 Shards</span>
    </div>
    <div id="shopList" style="display:flex; flex-direction:column; gap:8px; max-height:60vh; overflow-y:auto;">
      </div>
  </div>
</div>

<!-- ====== CREDITS (full-screen overlay) ====== -->
<div id="creditsOverlay" class="fullOverlay" style="display:none;" aria-label="Credits">
  <div class="creditsWrap">
    <button class="btn closeBtn" data-close="#creditsOverlay" title="Close">Close</button>
    <!-- Optional background image; remove if you want solid color -->
    <img class="creditsBg" src="https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawler@main/testing_title_screen.png" alt="" />

    <!-- Your scrollable credits content goes here -->
    <div class="creditsCard">
      <div class="creditsTitle">Credits</div>
      <div class="creditsBody">
        <p><strong>Game Design &amp; Code:</strong> Captain Noodles</p>
        
        <hr style="border:0; border-top:1px solid rgba(255,255,255,0.1); margin: 15px 0;">

        <div style="font-size:20px; font-weight:800; margin-bottom:8px; color:#f9d65c;">Voice Cast</div>
        <p><strong>Merchant:</strong> [Name Here]</p>
        <p><strong>Blacksmith:</strong> [Name Here]</p>
        <p><strong>Jester:</strong> Jolly</p>
        <p><strong>Cartographer:</strong> DJ Jam</p>
        <p><strong>Cleric:</strong> [Name Here]</p>
        <p><strong>The Mad King:</strong> [Name Here]</p>
        <p><strong>Shadow:</strong> [Name Here]</p>

        <hr style="border:0; border-top:1px solid rgba(255,255,255,0.1); margin: 15px 0;">

        <div style="font-size:20px; font-weight:800; margin-bottom:8px; color:#f9d65c;">Concept Contributors</div>
        <p><strong>[Friend Name]:</strong> Idea for the [Class Name]</p>
        <p><strong>[Friend Name]:</strong> Idea for the [Weapon/Item]</p>
        <p><strong>[Friend Name]:</strong> Suggestions for [Feature]</p>

        <hr style="border:0; border-top:1px solid rgba(255,255,255,0.1); margin: 15px 0;">

        <p><strong>Special Thanks:</strong> To all my friends who've play tested so far.</p>
        
      </div>
    </div>

<!-- ====== SETTINGS (full-screen overlay) ====== -->
<div id="settingsOverlay" class="fullOverlay" style="display:none;" aria-label="Settings">
  <div class="creditsWrap">
    <div class="creditsCard">
      <div class="settings-header">
        <div class="title">Settings</div>
        <button class="btn" data-close="#settingsOverlay">Close</button>
      </div>
      <div class="settings-body">
        <div class="settings-nav">
          <button class="tab-btn active" onclick="switchTab('sound')">Audio</button>
          <button class="tab-btn" onclick="switchTab('graphics')">Graphics</button>
          <button class="tab-btn" onclick="switchTab('gameplay')">Gameplay</button>
        </div>
        <div class="settings-content">
          <div id="tab-sound" class="settings-panel active">
            <div class="vol-group"><div class="vol-header"><span>Master Volume</span><span id="valMaster">50%</span></div>
              <input id="volMaster" class="custom-slider" type="range" min="0" max="100" value="50"></div>
            <hr style="border:0; border-top:1px solid rgba(255,255,255,0.1); margin: 20px 0;">
            <div class="vol-group"><div class="vol-header"><span>Music</span><span id="valMusic">80%</span></div>
              <input id="volMusic" class="custom-slider" type="range" min="0" max="100" value="80"></div>
            <div class="vol-group"><div class="vol-header"><span>Combat (Hits, Magic)</span><span id="valCombat">90%</span></div>
              <input id="volCombat" class="custom-slider" type="range" min="0" max="100" value="90"></div>
            <div class="vol-group"><div class="vol-header"><span>System / UI (Pickups, Level Up)</span><span id="valUi">90%</span></div>
              <input id="volUi" class="custom-slider" type="range" min="0" max="100" value="90"></div>
            <div class="vol-group"><div class="vol-header"><span>Environment (Doors, NPCs)</span><span id="valInteract">90%</span></div>
              <input id="volInteract" class="custom-slider" type="range" min="0" max="100" value="90"></div>
            <div class="vol-group"><div class="vol-header"><span>Footsteps</span><span id="valFoot">100%</span></div>
              <input id="volFoot" class="custom-slider" type="range" min="0" max="100" value="100"></div>
          </div>
          <div id="tab-graphics" class="settings-panel">
            <label style="display:flex; align-items:center; justify-content:space-between; padding:12px; background:rgba(0,0,0,0.2); border-radius:8px; cursor:pointer;">
              <div><div style="font-weight:700; color:#ff9a8b;">Arachnophobia Mode</div><div style="font-size:12px; opacity:0.7;">Replaces spiders with text labels.</div></div>
              <input id="chkArachno" type="checkbox" style="width:24px; height:24px; accent-color:#ff9a8b;">
            </label>
          </div>
          <div id="tab-gameplay" class="settings-panel">
            <label style="display:flex; align-items:center; justify-content:space-between; padding:12px; background:rgba(0,0,0,0.2); border-radius:8px; cursor:pointer; margin-bottom:15px;">
              <div><div style="font-weight:700; color:#facc15;">Developer Sounds [Work In Progress]</div><div style="font-size:12px; opacity:0.7;">Logs audio events to console (Debug).</div></div>
              <input id="chkDevSounds" type="checkbox" style="width:24px; height:24px; accent-color:#facc15;">
            </label>
            <div style="padding:15px; border:1px solid #7f1d1d; background:rgba(127, 29, 29, 0.1); border-radius:8px;">
              <div style="font-weight:bold; color:#fee2e2; margin-bottom:8px;">Danger Zone</div>
              <button id="btnResetData" class="btn" style="width:100%; background:#7f1d1d; border-color:#991b1b; color:#fee2e2;">Reset All Save Data</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>






<div class="app" id="app">
  <div class="row top">
    <div class="chip button" id="btnInv">Inventory</div>
    <div class="chip button" id="btnSpells">Spells</div>
    <div class="chip level" id="levelChip">Lvl 1 ‚Äî 0/24</div>
    <div class="chip" id="floorChip">Depth 1</div>
  </div>

  <div class="card">
    <div class="list" id="equipRow">
      <div class="chip" id="equipName">Fists</div>
      <div class="chip" id="equipAtk">ATK: 1‚Äì2</div>
      <div class="chip" id="equipSpell">No Spells</div>
      <div class="chip" id="equipBow">Bow (0/0)</div>
      <div class="chip" id="equipShield">No Shield</div>
    </div>

    <div class="canvasWrap" id="cw">
  <canvas id="view" width="1024" height="768"></canvas>

  <!-- NEW: play-area-only floor tint -->
  <div id="floorTint" style="
    position:absolute; inset:0; z-index:1;
    background:rgba(0,0,0,0);
    pointer-events:none;">
  </div>

  <div id="hurtFlash" style="
    position:absolute; inset:0; z-index:5;
    background:rgba(255,0,0,0.0);
    pointer-events:none; transition:background 480ms ease-out;">
  </div>

<div id="banner" style="
  position:absolute;
  left:50%;
  bottom:calc(14px + env(safe-area-inset-bottom));
  transform:translate(-50%, 0);
  width:100%;
  max-width:calc(100% - 24px);
  text-align:center;              /* ‚Üê center the text */
  padding:0 12px;                 /* keep it off the edges */
  background:transparent;
  color:#d9e7f5;
  font:800 18px/1.2 ui-sans-serif,system-ui;
  display:none;
  z-index:12;
  text-shadow:0 2px 4px rgba(0,0,0,.45);
  pointer-events:none;
  transition:opacity .25s, transform .25s;">
</div>



<!-- Boss HUD -->
<div id="bossHud" style="
  position:absolute; top:8px; left:50%; transform:translateX(-50%);
  width:min(640px, calc(100% - 24px)); padding:6px 10px;
  background:rgba(0,0,0,.45); border:1px solid rgba(255,255,255,.15);
  border-radius:10px; box-shadow:0 4px 12px rgba(0,0,0,.35);
  color:#fff; font:600 14px/1.2 ui-sans-serif,system-ui;
  display:none; z-index:15; text-align:center;">
  <div id="bossName" style="font-weight:800; margin-bottom:6px;">Boss</div>
  <div class="bar" style="height:12px; background:rgba(255,255,255,.12); border-radius:8px; overflow:hidden;">
    <div class="fill" id="bossHpFill" style="height:100%; width:100%; background:#d44747;"></div>
  </div>
  <div id="bossHpText" style="margin-top:4px; opacity:.9;">0/0</div>
</div>



<!-- Mobile-only joystick (inside .canvasWrap, above the canvas) -->
<div class="joystick" id="joystick">
  <div class="joy-base"></div>
  <div class="joy-stick" id="joyStick"></div>
</div>
<div class="fabs">
    <div class="fab small" id="btnQuickPot" style="display:none; color:#ff9a8b;">üß™</div>
        <div class="fab small" id="btnE">E</div>
        <div class="fab small" id="btnAtk">‚öîÔ∏è</div>
        <div class="fab small" id="btnCast">‚ú®</div>
        <div class="fab small" id="btnBow">üèπ</div> 
      </div>
</div>
      
    </div>

    <div class="bars">
      <div>HP</div>
      <div class="bar hp"><div class="fill" id="hpFill" style="width:60%"></div></div>
      <div id="hpText">20/20</div>

      <div>MP</div>
      <div class="bar mp"><div class="fill" id="mpFill" style="width:60%"></div></div>
      <div id="mpText">10/10</div>

      <div>STM</div>
      <div class="bar stamina"><div class="fill" id="stmFill" style="width:100%"></div></div>
      <div id="stmText">10/10</div>
    </div>
  </div>

  <div class="card">
    <div style="font-weight:800;margin-bottom:6px">Skills</div>
    <div class="list" id="skillsList"></div>
  </div>

  <div class="card">
    <div style="font-weight:800;margin-bottom:6px">Event Log</div>
    <div class="log" id="log"></div>
  </div>
</div>

<!-- Inventory Modal -->
<div class="modal" id="invModal">
  <div class="sheet">
    <div class="row"><div class="title">Inventory</div><button class="btn" data-close="#invModal">Close</button></div>
    <div id="invBody"></div>
  </div>
</div>

<!-- Spells Modal -->
<div class="modal" id="spellModal">
  <div class="sheet">
    <div class="row"><div class="title">Spells</div><button class="btn" data-close="#spellModal">Close</button></div>
    <div id="spellBody"></div>
  </div>
</div>

<!-- Spell Upgrade Modal -->
<div class="modal" id="spellUpModal" style="display:none;">
  <div class="sheet">
    <div class="title" id="spellUpTitle" style="text-align:center; font-weight:800; margin-bottom:6px;">
      Spell Upgrade
    </div>
    <div id="spellUpMsg" style="text-align:center; opacity:.9; margin-bottom:10px;">
      You have 5 duplicate shards. Choose an upgrade:
    </div>
    <div class="row" style="gap:10px; justify-content:center;">
      <button class="btn choice" id="btnSpellUpDmg">+1 Damage</button>
      <button class="btn choice" id="btnSpellUpRange">+1 Range</button>
    </div>
  </div>
</div>


    <!-- Level Up Modal -->
    <div class="modal" id="lvlupModal" style="display:none;">
      <div class="sheet">
        <div class="title" style="text-align:center;font-size:18px;font-weight:800;margin-bottom:4px;">
          Level Up!
        </div>
        <div style="text-align:center;font-size:14px;opacity:0.9;">
          Choose your bonus:
        </div>
        <div class="row" style="margin-top:8px;justify-content:space-between;gap:8px;">
          <button class="btn" id="btnHP"   style="flex:1; padding:10px 4px; font-size:13px;">+Max HP</button>
          <button class="btn" id="btnMP"   style="flex:1; padding:10px 4px; font-size:13px;">+Max MP</button>
          <button class="btn" id="btnStam" style="flex:1; padding:10px 4px; font-size:13px;">+Max STM</button>
        </div>
      </div>
    </div>

    <!-- Pick 1 of 2 Modal -->
    <div class="modal" id="pick2Modal" style="display:none;">
      <div class="sheet">
        <div class="title" id="pick2Title"
             style="text-align:center;font-size:18px;font-weight:800;margin-bottom:4px;">
          Pick 1 of 2
        </div>
        <div id="pick2Desc"
             style="text-align:center;font-size:14px;opacity:0.9;margin-bottom:8px;">
          Each choice has a blessing and a curse.
        </div>
        <div class="row" style="flex-direction:column;gap:8px;margin-top:4px;">
          <button class="btn" id="btnPick2A" style="width:100%;">Option A</button>
          <button class="btn" id="btnPick2B" style="width:100%;">Option B</button>
        </div>
      </div>
    </div>

    <!-- Pause overlay -->
    <div id="pauseOverlay" class="overlay" style="display:none;">
      <div class="sheet">
        <h2>Paused</h2>
        <p>Game is paused. Resume or quit to the menu.</p>
        <div class="pause-buttons">
          <button id="btnResume" class="btn">Resume</button>
          <button id="btnHelp"   class="btn">Help</button>
          <button id="btnQuit"   class="btn">Quit to Menu</button>
        </div>
      </div>
    </div>


<!-- Pause Menu Modal -->
<div class="modal" id="pauseModal" style="display:none;">
  <div class="sheet">
    <div class="title" style="text-align:center; font-weight:800; font-size:20px; margin-bottom:10px;">
      Paused
    </div>
    <div class="row" style="flex-direction:column; gap:10px; align-items:stretch; margin-top:4px;">
      <button class="btn" id="btnPauseResume">Resume</button>
      <button class="btn" id="btnPauseHelp">Help</button>
      <button class="btn" id="btnPauseSettings">Settings</button>
      <button class="btn" id="btnPauseQuit">Quit</button>
    </div>
  </div>
</div>


<!-- Classic Mode Clear Modal -->
<div class="modal" id="classicClearModal" style="display:none;">
  <div class="sheet">
    <div class="title" style="text-align:center; font-weight:800; margin-bottom:6px;">
      Classic Mode Cleared!
    </div>
    <div style="text-align:center; opacity:.9; margin-bottom:10px;">
      Congratulations! You've beaten Classic Mode. Head on over to Endless Mode from the menu to delve deeper into the dungeon and find what mysteries lie within!
    </div>
    <div class="row" style="gap:10px; justify-content:center;">
      <button class="btn" id="btnReturnToMenu">Return to Menu</button>
    </div>
  </div>
</div>

<!-- Tutorial Mode Clear Modal -->
<div class="modal" id="tutorialCompleteModal" style="display:none;">
  <div class="sheet">
    <div class="row">
      <div class="title">Tutorial Complete</div>
      </div>
    
    <div style="text-align:center; margin:10px 0 20px 0; opacity:0.9; font-size:15px; line-height:1.5;">
      You have mastered the basics of survival.
      <br><br>
      The real dungeon awaits you in Classic Mode.
      <br>
      <span style="font-size:13px; opacity:0.7;">(Press <b>H</b> anytime for controls)</span>
    </div>

    <div class="row" style="gap:10px; justify-content:center;">
      <button class="btn" id="btnTutReturn" style="min-width:140px;">Return to Menu</button>
    </div>
  </div>
</div>

<!-- Merchant Modal -->
<div class="modal" id="merchantModal" style="display:none;">
  <div class="sheet">
    <div class="row">
  <div class="title">Merchant</div>
<button class="btn" id="mBack">Close</button>
</div>

    <div id="merchantMsg" style="opacity:.9; margin:6px 0 10px">
      Three offers ‚Äî buy or sell. Choose wisely.
    </div>
    <div class="row" style="gap:10px; justify-content:center;">
      <button class="btn choice" id="mOfferA">...</button>
      <button class="btn choice" id="mOfferB">...</button>
      <button class="btn choice" id="mOfferC">...</button>
    </div>
    <div style="margin-top:10px; text-align:center; opacity:.85">
      Gold: <span id="goldNow">0</span>
    </div>
  </div>
</div>


<!-- Blacksmith Modal -->
<div class="modal" id="blacksmithModal" style="display:none;">
  <div class="sheet">
    <div class="row">
      <div class="title">Blacksmith</div>
      <button class="btn" data-close="#blacksmithModal">Close</button>
    </div>
    <div id="bsMsg" style="opacity:.9; margin:6px 0 10px"></div>

<!-- ‚ñº NEW: choose what you‚Äôre repairing -->
<div class="row" style="gap:8px; justify-content:center; margin-bottom:6px;">
  <button class="btn" id="bsTargetWeapon">Weapon</button>
  <button class="btn" id="bsTargetShield">Shield</button>
</div>

<div class="row" style="gap:10px; justify-content:center;">
  <button class="btn" id="bsRepair1">Repair +1</button>
  <button class="btn" id="bsRepair5">Repair +5</button>
  <button class="btn" id="bsRepairFull">Repair to Full</button>
</div>

    <div style="margin-top:10px; text-align:center; opacity:.85">
      Gold: <span id="bsGold">0</span>
    </div>
  </div>
</div>

<!-- Jester Modal -->
<div class="modal" id="jesterModal" style="display:none;">
  <div class="sheet">
    <div class="row">
      <div class="title">Jester</div>
      <button class="btn" id="jBack">Close</button>
    </div>
    <div id="jesterMsg" style="opacity:.9; margin:6px 0 10px; text-align:center;">
      Spin the wheel of fate! Land on green to win big, red means a big loss...
    </div>
        <div id="wheelContainer" style="position: relative;">
      <div id="jesterArrow"></div>
      <canvas id="jesterWheel" width="180" height="180"></canvas>
    </div>



    <div class="row" style="gap:10px; justify-content:center; margin-top:10px;">
      <button class="btn" id="jSpin">Spin</button>
      <button class="btn" id="jDone">Leave</button>
    </div>
  </div>
</div>

<!-- Cartographer Modal -->
<div class="modal" id="cartographerModal" style="display:none;">
  <div class="sheet">
    <div class="row">
      <div class="title">Cartographer</div>
      <button class="btn" id="cBack">Close</button>
    </div>
    <div id="cartographerMsg" style="opacity:.9; margin:6px 0 10px">
      I can chart this floor for a price.
    </div>
    <div class="row" style="gap:10px; justify-content:center;">
      <button class="btn choice" id="cBuyMap">Buy Map</button>
      <button class="btn" id="cDone">Leave</button>
    </div>
    <div style="margin-top:10px; text-align:center; opacity:.85">
      Gold: <span id="cGoldNow">0</span>
    </div>
  </div>
</div>

<!-- Cleric Modal -->
<div class="modal" id="clericModal" style="display:none;">
  <div class="sheet">
    <div class="row">
      <div class="title">Cleric</div>
      <button class="btn" id="clBack">Close</button>
    </div>
    <div id="clericMsg" style="opacity:.9; margin:6px 0 10px">
      The shadows are deep here. I can bless you for a price.
    </div>
    <div class="row" style="gap:10px; justify-content:center;">
      <button class="btn choice" id="clBuyBless">Blessing (50g)</button>
      <button class="btn" id="clDone">Leave</button>
    </div>
    <div style="margin-top:10px; text-align:center; opacity:.85">
      Gold: <span id="clGoldNow">0</span>
    </div>
  </div>
</div>


<!-- Debug Teleport Modal (hidden) -->
<div class="modal" id="debugModal" style="display:none;">
  <div class="sheet">
    <div class="row">
      <div class="title">Debug Tools</div>
      <button class="btn" data-close="#debugModal">Close</button>
    </div>
    <div style="margin:8px 0 12px; opacity:.9">
      Jump to a specific floor for testing.
    </div>
    <div class="row" style="gap:10px; align-items:center;">
      <label for="dbgFloor">Floor:</label>
      <input id="dbgFloor" type="number" min="1" value="1" 
             style="width:100px; padding:8px; background:#1b2a3a; color:#d9e7f5; border:1px solid var(--chipBorder); border-radius:8px;">
      <button class="btn" id="dbgGo">Go</button>
<div class="row" style="margin-top:12px; justify-content:flex-start">
  <button class="btn" id="dbgSpawnShield">Spawn Shield Below</button>
  <button class="btn" id="dbgSpawnHeal">Spawn Heal Scroll Below</button>
  <button class="btn" id="dbgSpawnPebble">Spawn Pebble Scroll Below</button>
  <button class="btn" id="dbgSpawnStairs">Spawn Stairs Below</button>
  <button class="btn" id="dbgSpawnShrine">Spawn Shrine</button>
 <button class="btn" id="dbgGiveClaymore">Give Claymore</button>
  <button class="btn" id="dbgUnlockEndless">Unlock Endless</button>
<button class="btn" id="dbgGiveBomb">Give 5 Bombs</button>
  <button class="btn" id="dbgGiveWarp">Give 1 Warp Stone</button>
  <button class="btn" id="dbgGiveGold">Give 500 Gold</button>
 <button class="btn" id="dbgGiveKeyBlade">Give Key of Destiny</button>
  <button class="btn" id="dbgUnlockClasses">Unlock All Classes</button>
  <button class="btn" id="dbgSpawnKey">Spawn Key Below</button>
<button class="btn" id="dbgSpawnCursed">Spawn Cursed Sword</button>
  <button class="btn" id="dbgSpawnGoldWell">Spawn Gold Well</button>
  <button class="btn" id="dbgSpawnCleric">Spawn Cleric</button> <button class="btn" id="dbgSpawnWarp">Spawn Warp Stone</button> </div>


    </div>
  </div>
</div>

<script>
// ====== Utility ======
const rand = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
function shuffle(arr){for(let i=arr.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[arr[i],arr[j]]=[arr[j],arr[i]]}return arr}
const key=(x,y)=>x+','+y;
// === Boss color variations (tints) ===
const BOSS_TINTS = [
  'hue-rotate(40deg)  saturate(1.35) brightness(1.05)',
  'hue-rotate(120deg) saturate(1.40) brightness(1.05)',
  'hue-rotate(200deg) saturate(1.35) brightness(1.05)',
  'hue-rotate(300deg) saturate(1.35) brightness(1.05)'
];
function randomBossTint(){
  return BOSS_TINTS[rand(0, BOSS_TINTS.length - 1)];
}

function showBanner(text, ms = 2500){
  const el = document.getElementById('banner');
  if (!el) return;

  // NEW: queue banners so they don‚Äôt overwrite each other
  if (!el._queue) el._queue = [];
  if (el._busy){
    el._queue.push({ text, ms });
    return;
  }
  el._busy = true;

  el.textContent = text;
  el.style.display = 'block';
  // start slightly lower, fade in, slide up a touch
  el.style.opacity = '0';
  el.style.transform = 'translate(-50%, 8px)';

  requestAnimationFrame(()=>{
    el.style.opacity = '1';
    el.style.transform = 'translate(-50%, 0)';
  });

  clearTimeout(el._hideT1); clearTimeout(el._hideT2);
  el._hideT1 = setTimeout(()=>{
    el.style.opacity = '0';
    el.style.transform = 'translate(-50%, 6px)';
  }, ms);
  el._hideT2 = setTimeout(()=>{
    el.style.display = 'none';
    el.style.transform = 'translate(-50%, 0)';

    // NEW: advance the queue
    el._busy = false;
    const next = el._queue.shift();
    if (next) showBanner(next.text, next.ms);
  }, ms + 260);
}


function hideBanner(){
  const el = document.getElementById('banner'); if (!el) return;
  clearTimeout(el._hideT1); clearTimeout(el._hideT2);
  el.style.display = 'none';
  el.style.opacity  = '0';
  el.style.transform = 'translate(-50%, 0)';

  // NEW: allow queued banners (and say()) to continue after a manual hide
  el._busy = false;
  if (el._queue && el._queue.length){
    const next = el._queue.shift();
    if (next) showBanner(next.text, next.ms);
  }
}

function waitForAdvance(){
  return new Promise(resolve=>{
    const cleanup = ()=>{
      window.removeEventListener('pointerdown', onClick);
      window.removeEventListener('keydown', onKey);
    };
    const onClick = ()=>{ cleanup(); resolve(); };
    const onKey = (e)=>{ if (e.key === 'Enter' || e.key === ' ') { cleanup(); resolve(); } };
    // slight delay so a click that *opened* the scene doesn‚Äôt auto-skip the first line
    setTimeout(()=>{
      window.addEventListener('pointerdown', onClick, { once:true });
      window.addEventListener('keydown', onKey, { once:true });
    }, 80);
  });
}

async function say(text){
  showBanner(text, 999999);   // stay up until the player advances
  await waitForAdvance();
  hideBanner();
}



const PLAYER_XP_START   = 22;   
const PLAYER_XP_GROWTH  = 1.20; // Reduced from 1.30 (Smoother late-game leveling)
const SKILL_XP_START    = 22;   
const SKILL_XP_GROWTH   = 1.30; // Reduced from 1.40 (Skills level up more often)



function isMerchantTile(x,y){
  const m = state.merchant;
  if (!m) return false;
  return (x===m.x && y===m.y) ||
         (m.left && x===m.left.x && y===m.left.y) ||
         (m.right && x===m.right.x && y===m.right.y);
}
function isNearMerchant(px,py){
  const m = state.merchant;
  if (!m) return false;
  const d = Math.abs(px - m.x) + Math.abs(py - m.y);
  return d === 1;
}

function isBlacksmithTile(x,y){
  const b = state.blacksmith;
  if (!b) return false;
  return (x===b.x && y===b.y) ||
         (b.left && x===b.left.x && y===b.left.y) ||
         (b.right && x===b.right.x && y===b.right.y);
}
function isNearBlacksmith(px,py){
  const b = state.blacksmith;
  if (!b) return false;
  const d = Math.abs(px - b.x) + Math.abs(py - b.y);
  return d === 1;
}

// ===== Jester NPC helpers =====
function isJesterTile(x,y){
  const j = state.jester;
  if (!j) return false;
  return (x===j.x && y===j.y) ||
         (j.left && x===j.left.x && y===j.left.y) ||
         (j.right && x===j.right.x && y===j.right.y);
}
function isNearJester(px,py){
  const j = state.jester;
  if (!j) return false;
  const d = Math.abs(px - j.x) + Math.abs(py - j.y);
  return d === 1;
}


// ===== Cartographer NPC helpers =====
function isCartographerTile(x,y){
  const c = state.cartographer;
  if (!c) return false;
  return (x===c.x && y===c.y) ||
         (c.left && x===c.left.x && y===c.left.y) ||
         (c.right && x===c.right.x && y===c.right.y);
}
function isNearCartographer(px,py){
  const c = state.cartographer;
   if (!c) return false;
  const d = Math.abs(px - c.x) + Math.abs(py - c.y);
  return d === 1;
}

// --- NEW: Cleric Helper ---
function isClericTile(x,y){
  return state.cleric && x === state.cleric.x && y === state.cleric.y;
}
// --------------------------


// NEW: find stairs + reveal full floor + draw arrow around player
function cartographerFindStairs(){
  if (state.cartographerArrowTarget) return state.cartographerArrowTarget;
  for (let y=0; y<state.size.h; y++){
    for (let x=0; x<state.size.w; x++){
      if (state.tiles?.[y]?.[x] === 4){
        state.cartographerArrowTarget = { x, y };
        return state.cartographerArrowTarget;
      }
    }
  }
  return null;
}
function cartographerRevealFloor(){
  if (!state.seen) state.seen = new Set();
  for (let y=0; y<state.size.h; y++){
    for (let x=0; x<state.size.w; x++){
      state.seen.add(key(x,y));
    }
  }
  cartographerFindStairs(); // cache target for arrow
}
function drawCartographerStairsArrow(ctx, ox, oy, tile){
  if (!state.cartographerMapActive) return;
  const s = cartographerFindStairs();
  if (!s) return;

  const dx = (s.x - state.player.x);
  const dy = (s.y - state.player.y);
  if (dx === 0 && dy === 0) return;

  const ang = Math.atan2(dy, dx);
  const cx = (state.player.x - ox) * tile + tile/2;
  const cy = (state.player.y - oy) * tile + tile/2;

  const r = tile * 0.55;
  const tipX = cx + Math.cos(ang) * r;
  const tipY = cy + Math.sin(ang) * r;

  ctx.save();
  ctx.globalAlpha = 0.95;
  ctx.lineWidth = Math.max(2, tile * 0.10);
  ctx.strokeStyle = 'rgba(242,201,76,0.95)';
  ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();

  const back = tile * 0.18;
  const side = tile * 0.14;
  ctx.fillStyle = 'rgba(242,201,76,0.95)';
  ctx.beginPath();
  ctx.moveTo(tipX, tipY);
  ctx.lineTo(
    tipX - Math.cos(ang)*back + Math.cos(ang+Math.PI/2)*side,
    tipY - Math.sin(ang)*back + Math.sin(ang+Math.PI/2)*side
  );
  ctx.lineTo(
    tipX - Math.cos(ang)*back + Math.cos(ang-Math.PI/2)*side,
    tipY - Math.sin(ang)*back + Math.sin(ang-Math.PI/2)*side
  );
  ctx.closePath(); ctx.fill();
  ctx.restore();
}



const CARTOGRAPHER_SPAWN_CHANCE = 0.20; // 20%
const CARTOGRAPHER_LOOP_URL = 'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/cartographer.mp3';
let cartographerAudio = null, cartographerGain = null, cartographerNode = null;

function ensureCartographerAudio(){
  initAudio();
  if (!cartographerGain){
    cartographerGain = audioCtx.createGain();
    cartographerGain.gain.value = 0;
    cartographerGain.connect(interactGain || masterGain); // Interactables slider
  }
  if (!cartographerAudio){
    cartographerAudio = new Audio();
    cartographerAudio.crossOrigin = 'anonymous';
    cartographerAudio.loop = true;
    cartographerAudio.preload = 'auto';
    cartographerAudio.setAttribute('playsinline','');
    cartographerAudio.src = CARTOGRAPHER_LOOP_URL;
    cartographerAudio.muted = true; // autoplay-safe priming
    cartographerAudio.play().catch(()=>{});
  }
  if (!cartographerNode && cartographerAudio){
    try{
      cartographerNode = audioCtx.createMediaElementSource(cartographerAudio);
      cartographerNode.connect(cartographerGain);
    }catch{}
  }
}

function stopCartographerAudio(){
  try{ if (cartographerAudio){ cartographerAudio.pause(); cartographerAudio.currentTime = 0; } }catch{}
  try{ if (cartographerNode){ cartographerNode.disconnect(); cartographerNode = null; } }catch{}
  cartographerAudio = null;
  if (cartographerGain) cartographerGain.gain.value = 0;
}

function updateCartographerAudio(){
  if (!cartographerGain) return;

  // if cartographer is gone (new floor / boss floor), force silence
  if (!state.cartographer){ cartographerGain.gain.value = 0; return; }

  // play until you're next to the NPC
  if (isNearCartographer(state.player.x, state.player.y)){
    cartographerGain.gain.value = 0;
    return;
  }

  const d = Math.abs(state.player.x - state.cartographer.x) + Math.abs(state.player.y - state.cartographer.y);
  const maxD = 20; // was 12
  const v = clamp(1 - (d/maxD), 0, 1);
  const shaped = Math.pow(v, 0.65);

  // NOTE: Interactables slider is already applied by interactGain
  cartographerGain.gain.value = shaped * 0.6;
}

// --- NEW: Cleric Audio ---
const CLERIC_LOOP_URL = 'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/priest.mp3';
let clericAudio = null, clericGain = null, clericNode = null;

function ensureClericAudio(){
  initAudio();
  if (!clericGain){
    clericGain = audioCtx.createGain();
    clericGain.gain.value = 0;
    clericGain.connect(interactGain || masterGain);
  }
  if (!clericAudio){
    clericAudio = new Audio();
    clericAudio.crossOrigin = 'anonymous';
    clericAudio.loop = true;
    clericAudio.preload = 'auto';
    clericAudio.setAttribute('playsinline','');
    clericAudio.src = CLERIC_LOOP_URL;
    clericAudio.muted = true;
    clericAudio.play().catch(()=>{});
  }
  if (!clericNode && clericAudio){
    try{
      clericNode = audioCtx.createMediaElementSource(clericAudio);
      clericNode.connect(clericGain);
    }catch{}
  }
}

function stopClericAudio(){
  try{ if (clericAudio){ clericAudio.pause(); clericAudio.currentTime = 0; } }catch{}
  try{ if (clericNode){ clericNode.disconnect(); clericNode = null; } }catch{}
  clericAudio = null;
  if (clericGain) clericGain.gain.value = 0;
}

function updateClericAudio(){
  if (!clericGain) return;
  if (!state.cleric){ clericGain.gain.value = 0; return; }

  const d = Math.abs(state.player.x - state.cleric.x) + Math.abs(state.player.y - state.cleric.y);

  // RESTORED: Mute if you are on top of her or directly adjacent (distance <= 1)
  if (d <= 1){
    clericGain.gain.value = 0;
    return;
  }

  const maxD = 20;
  const v = clamp(1 - (d/maxD), 0, 1);
  const shaped = Math.pow(v, 0.65);
  
  // Volume is 60% max
  clericGain.gain.value = shaped * 0.6;
}






// Spawn chance (20% per non-boss floor)
const JESTER_SPAWN_CHANCE = 0.20; 
const JESTER_LOOP_URL = 'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_jester_laugh.mp3';
let jesterAudio = null, jesterGain = null, jesterNode = null;

function ensureJesterAudio(){
  initAudio();
  if (!jesterGain){
    jesterGain = audioCtx.createGain();
    jesterGain.gain.value = 0;
    jesterGain.connect(interactGain || masterGain); // Interactables slider
  }
  if (!jesterAudio){
    jesterAudio = new Audio();
    jesterAudio.crossOrigin = 'anonymous';
    jesterAudio.loop = true;
    jesterAudio.preload = 'auto';
    jesterAudio.setAttribute('playsinline','');
    jesterAudio.src = JESTER_LOOP_URL;
    jesterAudio.muted = true; // autoplay-safe priming
    jesterAudio.play().catch(()=>{});
  }
  if (!jesterNode && jesterAudio){
    try{
      jesterNode = audioCtx.createMediaElementSource(jesterAudio);
      jesterNode.connect(jesterGain);
    }catch{}
  }
}

function stopJesterAudio(){
  try{ if (jesterAudio){ jesterAudio.pause(); jesterAudio.currentTime = 0; } }catch{}
  try{ if (jesterNode){ jesterNode.disconnect(); jesterNode = null; } }catch{}
  jesterAudio = null;
  if (jesterGain) jesterGain.gain.value = 0;
}

function updateJesterAudio(){
  if (!jesterGain) return;

  // if jester is gone (new floor / boss floor), force silence
  if (!state.jester){ jesterGain.gain.value = 0; return; }

  // play until you're next to the NPC
  if (isNearJester(state.player.x, state.player.y)){
    jesterGain.gain.value = 0;
    return;
  }

  const d = Math.abs(state.player.x - state.jester.x) + Math.abs(state.player.y - state.jester.y);
  const maxD = 20; // was 12
  const v = clamp(1 - (d/maxD), 0, 1);
  const shaped = Math.pow(v, 0.65);

  // NOTE: Interactables slider is already applied by interactGain
  jesterGain.gain.value = shaped * 0.6;
}






// ---- Default BGM (replace with your hosted URL) ----


const DEFAULT_BGM_URL = 'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/bg.mp3';

// ---- NPC dialogue (one-shot voice lines) ----
// Replace these placeholder URLs with your recorded lines.
const NPC_DIALOGUE_URLS = {
  // Use arrays ['url1', 'url2'] for random variations.
  merchant: {
    interact: ['https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_merchant_interact.mp3'],
    buy:      ['https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_merchant_buy.mp3'],
    sell:     ['https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_merchant_sell.mp3'],
    leave:    ['https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_merchant_leave.mp3'],
  },
  blacksmith: {
    interact: ['https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_blacksmith_interact.mp3'],
    partialrepair:   ['https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_blacksmith_partial_repair.mp3'],
    fullrepair:   ['https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_blacksmith_full_repair.mp3'],
    leave:    ['https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_blacksmith_leave.mp3'],
  },
  jester: {
    interact: ['https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_jester_interact1.mp3','https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_jester_interact2.mp3','https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_jester_interact3.mp3'],
    spin:     ['https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_jester_spin1.mp3','https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_jester_spin2.mp3','https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_jester_spin3.mp3','https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_jester_spin4.mp3','https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_jester_spin5.mp3','https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_jester_spin6.mp3'],
    leave:    ['https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_jester_leave1.mp3','https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_jester_leave2.mp3','https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_jester_leave3.mp3','https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_jester_leave4.mp3','https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_jester_leave5.mp3'],
    win:      ['https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_jester_win1.mp3','https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_jester_win2.mp3','https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_jester_win3.mp3'],
    lose:     ['https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_jester_lose1.mp3','https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_jester_lose2.mp3'],
  },
  cartographer: {
    interact: ['https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_cartographer_interact.mp3'],
    buy:      ['https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_cartographer_buy.mp3'],
    leave:    ['https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_cartographer_leave.mp3'],
  },
cleric: {
    interact: ['https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_cleric_interact.mp3'],
    buy:      ['https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_cleric_buy.mp3'],
    purify:   ['https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_cleric_purify.mp3'], 
    leave:    ['https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_cleric_leave.mp3'],
  },
  // --- NEW: Boss Voices ---
  shadow: {
    intro:  ['https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_shadow_intro.mp3'],
    defeat: ['https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_shadow_defeat.mp3']
  },
  madking: {
    intro:  ['https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_madking_intro.mp3'],
    defeat: ['https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/npc_madking_defeat.mp3']
  }
};

const _npcDialogueEls = Object.create(null);
const _npcDialogueNodes = Object.create(null);

// Plays a one-shot voice line routed through Interactables volume (interactGain).
let _currentNpcAudio = null; // Global tracker

function playNpcDialogue(input){
  if (!input) return;

  // --- NEW: Randomize if Array ---
  // If input is an array ['a.mp3', 'b.mp3'], pick one. If string, use as is.
  const url = Array.isArray(input) 
    ? input[Math.floor(Math.random() * input.length)] 
    : input;
  // -------------------------------

  // STOP previous line if playing
  if (_currentNpcAudio) {
    try { _currentNpcAudio.pause(); _currentNpcAudio.currentTime = 0; } catch{}
    _currentNpcAudio = null;
  }

  try { initAudio(); } catch {}
  try { if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{}); } catch {}
  try { if (typeof muted !== 'undefined' && muted) return; } catch {}

  let el = _npcDialogueEls[url];
  if (!el){
    el = new Audio();
    el.preload = 'auto';
    el.crossOrigin = 'anonymous';
    el.setAttribute('playsinline','');
    el.src = url;
    _npcDialogueEls[url] = el;

    // Route through WebAudio so your "Interactables" slider affects the dialogue.
    try{
      const node = audioCtx.createMediaElementSource(el);
      node.connect(interactGain || masterGain);
      _npcDialogueNodes[url] = node;
      el.volume = 1;
    }catch(e){
      // If routing fails, still try to play via element audio.
    }
  }

  try{
    el.currentTime = 0;
    el.play().catch(()=>{});
    _currentNpcAudio = el; // <--- FIX: Track the currently playing audio
  }catch{}
}

// ---- Merchant config ----


const MERCHANT_SPAWN_CHANCE = .20; // 20% per non-boss floor
const MERCHANT_LOOP_URL = 'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/money.mp3'; // ‚Üê your loop SFX
let merchantAudio = null, merchantNode = null, merchantGain = null;

function ensureMerchantAudio(){
  initAudio();
  if (!merchantGain){
    merchantGain = audioCtx.createGain();
    merchantGain.gain.value = 0;        // start silent
  merchantGain.connect(interactGain || masterGain);   // route via Interactables group
  }
  if (!merchantAudio){
    merchantAudio = new Audio();
    merchantAudio.crossOrigin = 'anonymous';
    merchantAudio.loop = true;
    merchantAudio.preload = 'auto';
    merchantAudio.setAttribute('playsinline','');
    merchantAudio.src = MERCHANT_LOOP_URL;
    merchantAudio.muted = true; // autoplay-safe priming
    merchantAudio.play().catch(()=>{});
  }
  if (!merchantNode && merchantAudio){
    try{
      merchantNode = audioCtx.createMediaElementSource(merchantAudio);
      merchantNode.connect(merchantGain);
    }catch{}
  }
}

function stopMerchantAudio(){
  try{ if (merchantAudio){ merchantAudio.pause(); merchantAudio.currentTime = 0; } }catch{}
  try{ if (merchantNode){ merchantNode.disconnect(); merchantNode = null; } }catch{}
  merchantAudio = null;
  if (merchantGain) merchantGain.gain.value = 0;
}

// volume rises as you approach the merchant
function updateMerchantAudio(){
  if (!merchantGain) return;

  // if merchant is gone (new floor / boss floor), force silence
  if (!state.merchant){ merchantGain.gain.value = 0; return; }

  // play until you're next to the NPC
  if (isNearMerchant(state.player.x, state.player.y)){
    merchantGain.gain.value = 0;
    return;
  }

  const d = Math.abs(state.player.x - state.merchant.x) + Math.abs(state.player.y - state.merchant.y);
  const maxD = 20; // was 12
  const v = clamp(1 - (d/maxD), 0, 1);
  const shaped = Math.pow(v, 0.65); // gentler falloff so it doesn't feel ‚Äúshort‚Äù

  // NOTE: Interactables slider is already applied by interactGain
  merchantGain.gain.value = shaped * 0.6;
}


// ---- Blacksmith config ----
const BLACKSMITH_SPAWN_CHANCE = 0.20; // 20% per non-boss floor
const BLACKSMITH_LOOP_URL = 'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/anvil-loop.mp3'; // add this file to your repo
let blacksmithAudio = null, blacksmithNode = null, blacksmithGain = null;

function ensureBlacksmithAudio(){
  initAudio();
  if (!blacksmithGain){
    blacksmithGain = audioCtx.createGain();
    blacksmithGain.gain.value = 0;
  blacksmithGain.connect(interactGain || masterGain);
  }
  if (!blacksmithAudio){
    blacksmithAudio = new Audio();
    blacksmithAudio.crossOrigin = 'anonymous';
    blacksmithAudio.loop = true;
    blacksmithAudio.preload = 'auto';
    blacksmithAudio.setAttribute('playsinline','');
    blacksmithAudio.src = BLACKSMITH_LOOP_URL;
    blacksmithAudio.muted = true;
    blacksmithAudio.play().catch(()=>{});
  }
  if (!blacksmithNode && blacksmithAudio){
    try{
      blacksmithNode = audioCtx.createMediaElementSource(blacksmithAudio);
      blacksmithNode.connect(blacksmithGain);
    }catch{}
  }
}

function stopBlacksmithAudio(){
  try{ if (blacksmithAudio){ blacksmithAudio.pause(); blacksmithAudio.currentTime = 0; } }catch{}
  try{ if (blacksmithNode){ blacksmithNode.disconnect(); blacksmithNode = null; } }catch{}
  blacksmithAudio = null;
  if (blacksmithGain) blacksmithGain.gain.value = 0;
}


function updateBlacksmithAudio(){
  if (!blacksmithGain) return;

  // if blacksmith is gone (new floor / boss floor), force silence
  if (!state.blacksmith){ blacksmithGain.gain.value = 0; return; }

  // play until you're next to the NPC
  if (isNearBlacksmith(state.player.x, state.player.y)){
    blacksmithGain.gain.value = 0;
    return;
  }

  const d = Math.abs(state.player.x - state.blacksmith.x) + Math.abs(state.player.y - state.blacksmith.y);
  const maxD = 20; // was 12
  const v = clamp(1 - (d/maxD), 0, 1);
  const shaped = Math.pow(v, 0.65);

  // NOTE: Interactables slider is already applied by interactGain
  blacksmithGain.gain.value = shaped * 0.7;
}



// ---- Shield config ----
const SHIELD_NAME = 'Round Shield';
const SHIELD_DR   = 0.20;   // 20% damage reduction
const SHIELD_DUR  = 20;     // max durability


// ====== Audio (WebAudio, synthesized SFX) ======

// Per-group volume (0..1). These are the *sliders*.
let _volMaster   = 0.5; // New Master slider
let _volMusic    = 0.8; 
let _volCombat   = 0.9; 
let _volInteract = 0.9; 
let _volUi       = 0.9; // New UI Group
let _volFoot     = 1.0; 

// Try to restore saved volumes from localStorage
(function restoreVolumePrefs(){
  try{
    const get = (k, def) => { const v = localStorage.getItem(k); return v!==null ? parseFloat(v) : def; };
    _volMaster   = clamp(get('volMaster', 0.5), 0, 1);
    _volMusic    = clamp(get('volMusic', 0.8), 0, 1);
    _volCombat   = clamp(get('volCombat', 0.9), 0, 1);
    _volInteract = clamp(get('volInteract', 0.9), 0, 1);
    _volUi       = clamp(get('volUi', 0.9), 0, 1);
    _volFoot     = clamp(get('volFoot', 1.0), 0, 1);
  } catch(e){}
})();

// Main audio nodes
let audioCtx, masterGain,
    musicGain, combatGain, interactGain, uiGain, footstepGain, 
    muted = false;

const SFX = {};

function initAudio(){
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  // Master Gain
  masterGain = audioCtx.createGain();
  masterGain.connect(audioCtx.destination);

  // Group Gains
  musicGain    = audioCtx.createGain(); musicGain.connect(masterGain);
  combatGain   = audioCtx.createGain(); combatGain.connect(masterGain);
  interactGain = audioCtx.createGain(); interactGain.connect(masterGain);
  uiGain       = audioCtx.createGain(); uiGain.connect(masterGain); // New
  footstepGain = audioCtx.createGain(); footstepGain.connect(masterGain);

  applyGroupVolumes();
}

function applyGroupVolumes(){
  if (!audioCtx) return;
  if (masterGain)   masterGain.gain.value   = muted ? 0 : _volMaster;
  if (musicGain)    musicGain.gain.value    = _volMusic;
  if (combatGain)   combatGain.gain.value   = _volCombat;
  if (interactGain) interactGain.gain.value = _volInteract;
  if (uiGain)       uiGain.gain.value       = _volUi;
  if (footstepGain) footstepGain.gain.value = _volFoot;
}


// iOS/Android: unlock audio on first touch/click
window.addEventListener('pointerdown', initAudio, { once:true });

function tone(freq, dur=0.12, type='square', vol=0.7){
  if (!audioCtx || muted) return;
  const t = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq;
  g.gain.setValueAtTime(0, t);
  g.gain.linearRampToValueAtTime(vol, t+0.005);
  g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
  o.connect(g); g.connect(masterGain);
  o.start(t); o.stop(t+dur+0.02);
}

function chord(freqs, dur=0.15, type='triangle', vol=0.5){
  const each = vol / Math.max(1, freqs.length);
  freqs.forEach(f=>tone(f, dur, type, each));
}

function noise(dur=0.08, vol=0.5, bandHz=1200){
  if (!audioCtx || muted) return;
  const n = audioCtx.sampleRate * dur;
  const buf = audioCtx.createBuffer(1, n, audioCtx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i=0;i<n;i++) data[i] = (Math.random()*2-1)*0.6;

  const src = audioCtx.createBufferSource(); src.buffer = buf;
  const bp = audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=bandHz; bp.Q.value=0.7;
  const g = audioCtx.createGain(); g.gain.value = vol;
  src.connect(bp); bp.connect(g); g.connect(masterGain);
  src.start(); src.stop(audioCtx.currentTime + dur);
}

// Group-aware versions of the synth helpers
function toneTo(destGain, freq, dur=0.12, type='square', vol=0.7){
  if (!audioCtx || muted) return;
  const t = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type;
  o.frequency.value = freq;
  g.gain.setValueAtTime(0, t);
  g.gain.linearRampToValueAtTime(vol, t+0.005);
  g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
  o.connect(g); g.connect(destGain || masterGain);
  o.start(t);
  o.stop(t+dur+0.02);
}

function chordTo(destGain, freqs, dur=0.15, type='triangle', vol=0.5){
  const each = vol / Math.max(1, (freqs && freqs.length) || 1);
  (freqs || []).forEach(f => toneTo(destGain, f, dur, type, each));
}

function noiseTo(destGain, dur=0.08, vol=0.5, bandHz=1200){
  if (!audioCtx || muted) return;
  const n = audioCtx.sampleRate*dur;
  const buf = audioCtx.createBuffer(1, n, audioCtx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i=0; i<n; i++){
    data[i] = (Math.random()*2-1)*0.6;
  }
  const src = audioCtx.createBufferSource();
  src.buffer = buf;

  const bp = audioCtx.createBiquadFilter();
  bp.type = 'bandpass';
  bp.frequency.value = bandHz;
  bp.Q.value = 0.7;

  const g = audioCtx.createGain();
  g.gain.value = vol;

  src.connect(bp); bp.connect(g); g.connect(destGain || masterGain);
  src.start();
  src.stop(audioCtx.currentTime + dur);
}


// ---- Walking SFX (custom file) ----
// Replace with your hosted file (wav/ogg/mp3). Make sure it has CORS enabled.
const WALK_SFX_URL = 'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/footstep.mp3';

let walkBuf = null;
let _lastWalkAt = 0;

async function loadWalkSfx(url = WALK_SFX_URL){
  try{
    initAudio();
    const res = await fetch(url, { mode:'cors' });
    const arr = await res.arrayBuffer();
    walkBuf = await new Promise((ok, err)=>audioCtx.decodeAudioData(arr, ok, err));
  }catch(e){
    console.warn('walk sfx failed to load', e);
  }
}

function playWalkSfx(){
  if (!audioCtx || muted) return;
  const now = audioCtx.currentTime || 0;

  // throttle: joystick can step every ~120ms; keep SFX tidy
  if (now - _lastWalkAt < 0.08) return;
  _lastWalkAt = now;

  if (walkBuf){
    const src = audioCtx.createBufferSource();
    src.buffer = walkBuf;
    src.playbackRate.value = 0.95 + Math.random()*0.1; // tiny variation
    const g = audioCtx.createGain();
    g.gain.value = 0.35; // footstep volume
  src.connect(g);
  g.connect(footstepGain || masterGain); // Footsteps group
    src.start(now);
  }else{
    // fallback: your old beep if the file isn't decoded yet
    tone(220, 0.05, 'square', 0.18);
  }
}

// ---- Drink + Cast SFX (custom files) ----
// Replace these with your hosted files (CORS-enabled)
const POTION_SFX_URL = 'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/potion.mp3';
const CAST_SFX_URL   = 'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/magic.mp3';

let drinkBuf = null;
let castBuf  = null;

async function loadPotionSfx(url = POTION_SFX_URL){
  try{
    initAudio();
    const res = await fetch(url, { mode:'cors' });
    const arr = await res.arrayBuffer();
    drinkBuf = await new Promise((ok, err)=>audioCtx.decodeAudioData(arr, ok, err));
  }catch(e){ console.warn('drink sfx failed to load', e); }
}

async function loadCastSfx(url = CAST_SFX_URL){
  try{
    initAudio();
    const res = await fetch(url, { mode:'cors' });
    const arr = await res.arrayBuffer();
    castBuf = await new Promise((ok, err)=>audioCtx.decodeAudioData(arr, ok, err));
  }catch(e){ console.warn('cast sfx failed to load', e); }
}

function playDrinkSfx(){
  if (!audioCtx || muted) return;
  const now = audioCtx.currentTime || 0;

  if (drinkBuf){
    const src = audioCtx.createBufferSource();
    src.buffer = drinkBuf;
    src.playbackRate.value = 0.98 + Math.random()*0.04; // tiny variation
    const g = audioCtx.createGain();
  g.gain.value = 0.32;
  src.connect(g); g.connect(interactGain || masterGain); // Interactables group
  src.start();
} else{
  console.warn('drink sfx failed / not loaded', e);
  // fallback still respects Interactables slider
  toneTo(interactGain, 500, 0.08, 'triangle', 0.18);
}
}

function playCastSfx(){
  if (!audioCtx || muted) return;
  const now = audioCtx.currentTime || 0;

  if (castBuf){
    const src = audioCtx.createBufferSource();
    src.buffer = castBuf;
    src.playbackRate.value = 0.98 + Math.random()*0.04;
    const g = audioCtx.createGain();
  g.gain.value = 0.30;
  src.connect(g); g.connect(combatGain || masterGain); // Combat group
  src.start();
} else {
  console.warn('cast sfx failed / not loaded', e);
  // fallback in Combat group
  chordTo(combatGain, [660,880], 0.12, 'sine', 0.24);
}
}

const WEAPON_SFX = {
  one:    'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/one_handed.mp3',
  two:    'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/two_handed.mp3',
  spear:  'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/spear.mp3',
  axe:    'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/axe.mp3',
  hand:   'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/punch.mp3',
  bowShot:'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/arrow.mp3',
  break:   'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/weapon_break.mp3',
  descend: 'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/steps.mp3',

};

const _weaponBufs = {};

// generic file loader
async function _loadBuf(key, url){
  try{
    initAudio();
    const res = await fetch(url, { mode:'cors' });
    const arr = await res.arrayBuffer();
    _weaponBufs[key] = await new Promise((ok, err)=>audioCtx.decodeAudioData(arr, ok, err));
  }catch(e){ console.warn('weapon sfx failed', key, e); }
}

// load all the above in parallel
async function loadWeaponSfx(map = WEAPON_SFX){
  await Promise.all(Object.entries(map).map(([k,u])=> _loadBuf(k,u)));
}

// play a decoded buffer (with tiny pitch variation)
function playBuf(key, gain=0.4, rateJitter=0.05){
  if (!audioCtx || muted) return false;
  const now = audioCtx.currentTime || 0;
  const b = _weaponBufs[key];
  if (!b) return false;
  const src = audioCtx.createBufferSource();
  src.buffer = b;
  src.playbackRate.value = 1 - rateJitter + Math.random()*rateJitter*2;
   const g = audioCtx.createGain();
  g.gain.value = gain;

  // Route weapon / descend buffers to the correct group
  let dest = masterGain;
  switch (key){
    case 'one':
    case 'two':
    case 'spear':
    case 'axe':
    case 'hand':
    case 'bowShot':
    case 'bowDraw':
    case 'break':
      dest = combatGain || masterGain;
      break;
    case 'descend':
      dest = interactGain || masterGain;
      break;
    default:
      dest = masterGain;
  }

  src.connect(g); g.connect(dest);
  src.start(now);
  return true;
}

// tasteful synthesized fallbacks so you‚Äôre never silent
function synthSwing(type){
  const dest = combatGain || masterGain;
  switch(type){
    case 'one':   noiseTo(dest, 0.06, 0.32, 2200); break;                           // quick swish
    case 'two':   toneTo(dest, 120,0.06,'sine',0.35); noiseTo(dest,0.08,0.28,1400); break; // heavy whoosh + thump
    case 'spear': noiseTo(dest,0.05,0.28,2600); break;                              // airy thrust
    case 'axe':   toneTo(dest,180,0.05,'square',0.40); noiseTo(dest,0.04,0.22,900); break; // chunky chop
    case 'hand':  toneTo(dest,90, 0.05,'sine',0.35); break;                         // punch thud
    default:      chordTo(dest,[440,660], 0.08, 'square', 0.25);
  }
}

function playWeaponSwing(type){
  if (playBuf(type, ({two:0.48, axe:0.45}[type] || 0.38))) return;
  synthSwing(type);
}

function playBowShot(){
  if (playBuf('bowShot', 0.42, 0.03)) return;
  // fallback: bow "twang" in Combat group
  const dest = combatGain || masterGain;
  toneTo(dest, 300,0.05,'triangle',0.28);
  noiseTo(dest,0.04,0.24,1800);
}

function playBowDraw(){
  if (playBuf('bowDraw', 0.34, 0.02)) return;
  // subtle draw fallback in Combat group
  toneTo(combatGain || masterGain, 220,0.04,'sine',0.22);
}


// expose through your SFX object
function extendSfxForWeapons(){
  SFX.swingFor = (t)=>playWeaponSwing(t); // t = 'one'|'two'|'spear'|'axe'|'hand'
  SFX.bowShot  = ()=>playBowShot();
  SFX.bowDraw  = ()=>playBowDraw();       // call this when loading an arrow
}

// new: simple players (uses the same playBuf loader/fallback system)
SFX.weaponBreak = () => {
  // a touch louder, tiny pitch variance
  if (!playBuf('break', 1, 0.03)) {
    // synth fallback if file hasn't loaded
    noise(0.20, 0.30, 1600);
    tone(160, 0.06, 'square', 0.30);
  }
};

SFX.descend = () => {
  if (!playBuf('descend', 0.42, 0.02)) {
    // soft low ‚Äúwhoomp‚Äù fallback
    tone(180, 0.18, 'sine', 0.40);
  }
};


// kick off loads at boot (after AudioContext exists)
document.addEventListener('DOMContentLoaded', ()=>{
  extendSfxForWeapons();
  loadWeaponSfx(); // safe if files 404 ‚Äî fallbacks cover you
});

// --- Custom URLs (replace with your own, CORS-enabled) ---
const MISS_SFX_URL        = 'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/miss.mp3';
const LOCK_SUCCESS_SFX_URL= 'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/lockpick_success.mp3';
const CHEST_OPEN_SFX_URL  = 'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/chest.mp3';
// --- Boss BGMs (replace with your own CORS-enabled URLs) ---
const BOSS1_BGM_URL = 'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/boss1.mp3';
const BOSS2_BGM_URL = 'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/boss2.mp3';

// Buffers
let missBuf = null, lockOkBuf = null, chestOpenBuf = null;

// Loaders
async function loadMissSfx(url = MISS_SFX_URL){
  try { initAudio();
    const arr = await (await fetch(url, {mode:'cors'})).arrayBuffer();
    missBuf = await new Promise((ok, err)=>audioCtx.decodeAudioData(arr, ok, err));
  } catch (e){ console.warn('miss sfx failed to load', e); }
}
async function loadLockOkSfx(url = LOCK_SUCCESS_SFX_URL){
  try { initAudio();
    const arr = await (await fetch(url, {mode:'cors'})).arrayBuffer();
    lockOkBuf = await new Promise((ok, err)=>audioCtx.decodeAudioData(arr, ok, err));
  } catch (e){ console.warn('lock success sfx failed to load', e); }
}
async function loadChestOpenSfx(url = CHEST_OPEN_SFX_URL){
  try { initAudio();
    const arr = await (await fetch(url, {mode:'cors'})).arrayBuffer();
    chestOpenBuf = await new Promise((ok, err)=>audioCtx.decodeAudioData(arr, ok, err));
  } catch (e){ console.warn('chest open sfx failed to load', e); }
}

// Players (fall back to your current synth tones if file not ready)
function playMissSfx(){
  if (!audioCtx || muted) return;
  if (missBuf){
    const src = audioCtx.createBufferSource();
    src.buffer = missBuf;
    const g = audioCtx.createGain();
    g.gain.value = 0.32;
    src.connect(g); g.connect(combatGain || masterGain);
    src.start();
  } else {
    // fallback if file not loaded (Combat group)
    toneTo(combatGain, 220, 0.08, 'square', 0.24);
  }
}

function playLockOkSfx(){
  if (!audioCtx || muted) return;
  const now = audioCtx.currentTime || 0;
  if (lockOkBuf){
    const src = audioCtx.createBufferSource(); src.buffer = lockOkBuf;
    src.playbackRate.value = 0.98 + Math.random()*0.04;
    const g = audioCtx.createGain(); g.gain.value = 0.36;
src.connect(g); g.connect(interactGain || masterGain);
    src.start(now);
  } else {
toneTo(interactGain, 660, 0.10, 'triangle', 0.22);
  }
}
function playChestOpenSfx(){
  if (!audioCtx || muted) return;
  const now = audioCtx.currentTime || 0;
  if (chestOpenBuf){
    const src = audioCtx.createBufferSource(); src.buffer = chestOpenBuf;
    src.playbackRate.value = 0.98 + Math.random()*0.04;
    const g = audioCtx.createGain(); g.gain.value = 0.40;
src.connect(g); g.connect(interactGain || masterGain);
    src.start(now);
  } else {
chordTo(interactGain, [440,550], 0.15, 'square', 0.26);
  }
}

// Wire the new players into your SFX map
function extendSfxForUtility(){
  SFX.miss        = ()=>playMissSfx();
  SFX.lockSuccess = ()=>playLockOkSfx();
  SFX.openChest   = ()=>playChestOpenSfx();
}

// ---- Level Up SFX (custom file) ----
// swap this URL for your own hosted/CORS-enabled file
const LEVEL_UP_SFX_URL = 'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/level_up.mp3';
// Replace with your actual hosted file
const ARACHNO_SFX_URL  = 'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/arachnophobia_mode.mp3'; 

let levelUpBuf = null;

function playArachnoSound(){
    // Simple one-shot player
    const a = new Audio(ARACHNO_SFX_URL);
    a.volume = 0.5;
    a.play().catch(()=>{});
}

async function loadLevelUpSfx(url = LEVEL_UP_SFX_URL){
  try{
    initAudio();
    const res = await fetch(url, { mode:'cors' });
    const arr = await res.arrayBuffer();
    levelUpBuf = await new Promise((ok, err)=>audioCtx.decodeAudioData(arr, ok, err));
  }catch(e){ console.warn('level up sfx failed to load', e); }
}

function playLevelUpSfx(){
  if (!audioCtx || muted) return;
  const now = audioCtx.currentTime || 0;

  if (levelUpBuf){
    const src = audioCtx.createBufferSource();
    src.buffer = levelUpBuf;
    src.playbackRate.value = 1.0;
    const g = audioCtx.createGain(); g.gain.value = 0.42;
    // Changed: Routes to UI Gain instead of Combat Gain
    src.connect(g); g.connect(uiGain || masterGain);
    src.start(now);
  }else{
    // Fallback: Routes to UI Gain
    chordTo(uiGain, [392,523,659], 0.28, 'triangle', 0.32);
    toneTo(uiGain, 1046.5, 0.10, 'sine', 0.22); 
  }
}


// Preload on boot (alongside your other loads)
document.addEventListener('DOMContentLoaded', ()=>{
  extendSfxForUtility();
  loadMissSfx();
  loadLockOkSfx();
  loadChestOpenSfx(); 
  loadLevelUpSfx();          // <-- add this line
});

function defineSfx(){
  // --- NEW: Developer Placeholder Helper (for logging) ---
  const devSfx = (name, fn) => () => {
    // Check for the global flag (defined in settings section)
    if (window._devSounds) console.log(`[DEV SFX] ${name}`);
    if (fn) fn();
  };
  // ----------------------------------------------------
  
  SFX.step = devSfx('Step', ()=>playWalkSfx());
  SFX.drink = devSfx('Drink Potion/Tonic/Antidote', ()=>playDrinkSfx());

  // Combat (Attacks, Hits, Deaths)
  SFX.attack      = devSfx('Melee Hit: Generic Attack', ()=>chordTo(combatGain, [440,660], 0.08, 'square', 0.25));
  SFX.miss        = devSfx('Melee/Ranged Miss', ()=>playMissSfx());
  SFX.enemyHit    = devSfx('Player Hurt', ()=>toneTo(combatGain, 140, 0.10, 'sawtooth', 0.28));
  SFX.kill        = devSfx('Enemy Kill', ()=>chordTo(combatGain, [392, 523, 659], 0.20, 'triangle', 0.32));
  
  // Environment (Interactables: Chests, Doors, Stairs)
  SFX.openChest   = devSfx('Chest Open', ()=>playChestOpenSfx()); // Uses interactGain internally
  SFX.lockSuccess = devSfx('Lockpick Success', ()=>playLockOkSfx()); // Uses interactGain internally
  SFX.lockFail    = devSfx('Lockpick Fail', ()=>toneTo(interactGain, 110, 0.12, 'sawtooth', 0.22));
  SFX.bossDown    = devSfx('Boss Down/Stairs Spawn', ()=>chordTo(interactGain, [196, 262, 392, 523], 0.35, 'triangle', 0.35)); // Moved to Interact

  // UI / System (Pickups, Level Up)
  SFX.pickup      = devSfx('Item/Gold Pickup/Upgrade Ready', ()=>chordTo(uiGain, [880,1320], 0.08, 'triangle', 0.22)); // Moved to UI
  SFX.levelUp     = devSfx('Player Level Up/Upgrade', ()=>playLevelUpSfx()); // Route changed in player function below

  // Magic / Status (Combat)
  SFX.spell       = devSfx('Spell Cast', ()=>playCastSfx());
  SFX.rangedZap   = devSfx('Enemy Ranged Hit', ()=>toneTo(combatGain, 900, 0.11, 'sine', 0.26));
  SFX.poisonTick  = devSfx('Poison Tick', ()=>noiseTo(combatGain, 0.06, 0.25, 1000));
  SFX.antidote    = devSfx('Antidote Cure', ()=>chordTo(combatGain, [523,659], 0.12, 'triangle', 0.24));
}

document.addEventListener('DOMContentLoaded', defineSfx);

// Mute button
document.addEventListener('DOMContentLoaded', ()=>{
  const b = document.getElementById('btnMute');
  if (!b) return;
  b.onclick = ()=>{
    initAudio();
    muted = !muted;
    if (masterGain) masterGain.gain.value = muted ? 0 : 0.5;
    b.textContent = muted ? 'üîá' : 'üîä';
  };
});

// --- NEW: Tab Switching Logic ---
window.switchTab = function(tabName) {
  document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
  if(event) event.target.classList.add('active');
  document.querySelectorAll('.settings-panel').forEach(p => p.classList.remove('active'));
  document.getElementById('tab-' + tabName).classList.add('active');
};

// Settings sliders ‚Üí per-group volume
document.addEventListener('DOMContentLoaded', ()=>{
  const bind = (id, get, set, key) => {
    const el = document.getElementById(id);
    const label = document.getElementById(id.replace('vol','val')); // e.g. valMaster
    if (!el) return;
    
    el.value = Math.round(get() * 100);
    if(label) label.textContent = el.value + '%';

    el.addEventListener('input', ()=>{
      const v = clamp(el.value / 100, 0, 1);
      set(v);
      if(label) label.textContent = el.value + '%';
      if (!audioCtx) initAudio();
      try{ localStorage.setItem(key, String(v)); }catch(e){}
    });
  };

  bind('volMaster',   ()=>_volMaster,   (v)=>{ _volMaster=v;   applyGroupVolumes(); }, 'volMaster');
  bind('volMusic',    ()=>_volMusic,    (v)=>{ _volMusic=v;    applyGroupVolumes(); }, 'volMusic');
  bind('volCombat',   ()=>_volCombat,   (v)=>{ _volCombat=v;   applyGroupVolumes(); }, 'volCombat');
  bind('volInteract', ()=>_volInteract, (v)=>{ _volInteract=v; applyGroupVolumes(); }, 'volInteract');
  bind('volUi',       ()=>_volUi,       (v)=>{ _volUi=v;       applyGroupVolumes(); }, 'volUi');
  bind('volFoot',     ()=>_volFoot,     (v)=>{ _volFoot=v;     applyGroupVolumes(); }, 'volFoot');

  // --- Arachnophobia Mode Wiring ---
  const chkArachno = document.getElementById('chkArachno');
  window._arachnophobiaMode = (localStorage.getItem('arachnoMode') === '1');
  if (chkArachno) {
    chkArachno.checked = window._arachnophobiaMode;
    chkArachno.addEventListener('change', ()=>{
       window._arachnophobiaMode = chkArachno.checked;
       localStorage.setItem('arachnoMode', chkArachno.checked ? '1' : '0');
       if (chkArachno.checked && typeof playArachnoSound === 'function') playArachnoSound();
       if(typeof draw === 'function') draw();
    });
  }

  // --- Reset Data Wiring ---
  document.getElementById('btnResetData')?.addEventListener('click', () => {
    if(confirm("Are you sure? This will wipe ALL progress, purchases, and high scores forever.")){
      localStorage.clear();
      window.location.reload();
    }
  });

  // --- Developer Sounds Wiring ---
  const chkDev = document.getElementById('chkDevSounds');
  window._devSounds = (localStorage.getItem('devSounds') === '1');
  let devTries = 0;
  // Temporary denial sounds (placeholders)
  const devDenials = [
    'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/miss.mp3', // Placeholder 1
    'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/miss.mp3', // Placeholder 2
    'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/miss.mp3', // Placeholder 3
    'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/miss.mp3', // Placeholder 4
    'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/miss.mp3'  // Placeholder 5
  ];

  if (chkDev) {
    chkDev.checked = window._devSounds;
    chkDev.addEventListener('click', (e) => {
        // If enabling, and not fully unlocked (tries < 5), intercept
        if (chkDev.checked && devTries < 5) {
            e.preventDefault(); // Stop it from checking
            
            // Play Audio Bite (Blocking)
            const audio = new Audio(devDenials[devTries]);
            // Lock input/UI
            document.body.style.pointerEvents = 'none'; 
            audio.play().catch(()=>{});
            
            audio.onended = () => {
                document.body.style.pointerEvents = 'auto'; // Unlock
                devTries++;
            };
            // Fallback unlock if audio fails
            audio.onerror = () => { document.body.style.pointerEvents = 'auto'; devTries++; };
            return;
        }

        // 6th click or disabling: Allow toggle
        window._devSounds = chkDev.checked;
        localStorage.setItem('devSounds', chkDev.checked ? '1' : '0');
        if (window._devSounds) alert("Developer Sounds Activated! (Placeholder: Implement audio swap logic here)");
    });
  }
});


// ====== Background Music (custom file) ======
let bgmAudio = null;   // <audio> element
let bgmNode  = null;   // MediaElementAudioSourceNode
let bgmGain  = null;   // gain for BGM (routes into masterGain)
let bgmUrl   = null;   // object URL for the chosen file

function attachBgmNodeIfNeeded(){
  // Only wire the media source after the context is unlocked/running (Android/iOS/Chrome autoplay fix)
  if (!audioCtx || audioCtx.state !== 'running') return;
  if (!bgmAudio || bgmNode) return;
  try {
    bgmNode = audioCtx.createMediaElementSource(bgmAudio);
    bgmNode.connect(bgmGain);
  } catch (e) {
    // ignore
  }
}



function ensureBgmNodes(){
  initAudio();
  if (!bgmGain){
  bgmGain = audioCtx.createGain();
  bgmGain.gain.value = 0.35;       // BGM base volume
  bgmGain.connect(musicGain || masterGain); // route through Music group
}

}

function stopBgm(){
  if (bgmAudio){
    bgmAudio.pause();
    bgmAudio.currentTime = 0;
  }
}

function unloadBgm(){
  stopBgm();
  if (bgmNode){ try{ bgmNode.disconnect(); }catch{} bgmNode = null; }
  if (bgmAudio){ bgmAudio.src=''; bgmAudio = null; }
  if (bgmUrl){ URL.revokeObjectURL(bgmUrl); bgmUrl = null; }
}

function setBgmFromFile(file){
  ensureBgmNodes();
  unloadBgm();

  bgmAudio = new Audio();
  bgmAudio.muted = true;                 // prime for autoplay
  bgmAudio.crossOrigin = 'anonymous';
  bgmAudio.loop = true;
  bgmAudio.preload = 'auto';
  bgmAudio.setAttribute('playsinline','');
  bgmAudio.volume = 1;

  bgmUrl = URL.createObjectURL(file);
  bgmAudio.src = bgmUrl;

  // Do NOT connect to AudioContext until first user gesture
  // (attach happens inside kick)
  bgmAudio.play().catch(()=>{});         // will succeed after first tap
}

function setBgmUrl(url){
  ensureBgmNodes();
  unloadBgm();

  bgmAudio = new Audio();
  bgmAudio.muted = true;                 // prime for autoplay
  bgmAudio.crossOrigin = 'anonymous';
  bgmAudio.loop = true;
  bgmAudio.preload = 'auto';
  bgmAudio.setAttribute('playsinline','');
  bgmAudio.volume = 1;

  bgmAudio.src = url;

  // Do NOT connect to AudioContext until first user gesture
  // (attach happens inside kick)
  bgmAudio.play().catch(()=>{});         // will succeed after first tap
}




function setBgmVolume(v){ // optional helper: 0..1
  ensureBgmNodes();
  bgmGain.gain.value = Math.max(0, Math.min(1, v));
}

// Wire the BGM button + file input
document.addEventListener('DOMContentLoaded', ()=>{
  const btn = document.getElementById('btnBgm');
  const inp = document.getElementById('bgmFile');
  if (!btn || !inp) return;

  // Click BGM ‚Üí choose a local audio file
  btn.onclick = ()=>{
    initAudio();
    inp.click();
  };

  // Load & loop the chosen track
  inp.onchange = ()=>{
  const f = inp.files && inp.files[0];
  if (!f) return;

  setBgmFromFile(f);

  // IMPORTANT: user just interacted, so we can safely wire + unmute now
  attachBgmNodeIfNeeded();
  if (bgmAudio){
    bgmAudio.muted = false;
    bgmAudio.play()?.catch(()=>{});
  }

  btn.textContent = 'BGM ‚ñ∂';
};

  // Optional: middle-click BGM to pause/resume
btn.addEventListener('auxclick', ()=>{
  if (!bgmAudio) return;
  if (bgmAudio.paused){ bgmAudio.play(); btn.textContent='BGM ‚ñ∂'; }
  else { bgmAudio.pause(); btn.textContent='BGM ‚ùö‚ùö'; }
});
}); // <-- end of the BGM button wiring block

// Gameplay / Menu BGM
const CLASSIC_BGM_URL = 'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/bg.mp3';
const ENDLESS_BGM_URL = 'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/bg.mp3';

// Title + Menu BGM (set these to your actual files)
const TITLE_BGM_URL = 'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/temp_title.mp3';

// IMPORTANT: change this to your menu track you uploaded
const MENU_BGM_URL  = 'https://cdn.jsdelivr.net/gh/MrCaptainNoodles/DungeonCrawlerAudio@main/temp_title.mp3';

function playTitleBgm(){
  ensureBgmNodes();
  setBgmUrl(TITLE_BGM_URL);     // load title track
  attachBgmNodeIfNeeded();      // connect to WebAudio
  if (bgmAudio){ bgmAudio.muted = false; bgmAudio.play()?.catch(()=>{}); }
}

function playMenuBgm(){
  ensureBgmNodes();
  setBgmUrl(MENU_BGM_URL);      // load menu track
  attachBgmNodeIfNeeded();
  if (bgmAudio){ bgmAudio.muted = false; bgmAudio.play()?.catch(()=>{}); }
}

function playGameBgm(url){
  ensureBgmNodes();
  setBgmUrl(url);              // load gameplay track
  attachBgmNodeIfNeeded();     // connect to WebAudio
  if (bgmAudio){ bgmAudio.muted = false; bgmAudio.play()?.catch(()=>{}); }
}




// --- Global modal helpers (accessible from gameplay code) ---
window.openModal = function openModal(sel){
  const m = document.querySelector(sel);
  if (!m) return;
  m.style.display = 'flex';
  document.body.classList.add('noscroll');
};
window.closeModal = function closeModal(sel){
  const m = document.querySelector(sel);
  if (!m) return;
  m.style.display = 'none';
  document.body.classList.remove('noscroll');
};



// ====== Boot: Title ‚Üí Menu ‚Üí Game ======
document.addEventListener('DOMContentLoaded', ()=>{
  // Preload default BGM element (muted); we‚Äôll unmute on first user gesture
  

  // Small helper to open/close our simple modals (reuses your .modal styles)
 
  document.addEventListener('click', (e)=>{
    const btn = e.target.closest('[data-close]');
    if (!btn) return;
    const sel = btn.getAttribute('data-close');
    const m = document.querySelector(sel);
    if (m){ m.style.display = 'none'; document.body.classList.remove('noscroll'); }
  });

  // Unlock audio + connect loops + preload some sfx (safe to call multiple times)
function unlockAudioAndLoops(){
  try { initAudio?.(); } catch {}
  try {
    if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
  } catch {}

  // NPC loops (ok if not present yet)
  try { ensureMerchantAudio?.(); if (merchantAudio){ merchantAudio.muted=false; merchantAudio.play()?.catch(()=>{}); } } catch {}
  try { ensureBlacksmithAudio?.(); if (blacksmithAudio){ blacksmithAudio.muted=false; blacksmithAudio.play()?.catch(()=>{}); } } catch {}
try { ensureJesterAudio?.(); if (jesterAudio){ jesterAudio.muted=false; jesterAudio.play()?.catch(()=>{}); } } catch {}
  try { ensureCartographerAudio?.(); if (cartographerAudio){ cartographerAudio.muted=false; cartographerAudio.play()?.catch(()=>{}); } } catch {}
  try { ensureClericAudio?.(); if (clericAudio){ clericAudio.muted=false; clericAudio.play()?.catch(()=>{}); } } catch {}

  // Preload a few common SFX so first use isn‚Äôt delayed
  try { loadWalkSfx?.(); loadPotionSfx?.(); loadCastSfx?.(); } catch {}
}


  // Transition: Title ‚Üí Menu
const title = document.getElementById('titleScreen');
const menu  = document.getElementById('mainMenu');

// ‚úÖ Start title BGM while we're waiting on "Press to Start"
try {
  if (typeof playTitleBgm === 'function') playTitleBgm();
} catch {}

function syncEndlessUnlockUI(){
  const unlocked = localStorage.getItem('endlessUnlocked') === '1';
  const el = document.getElementById('btnEndless');
  if (!el) return;

  if (unlocked){
    el.textContent = 'Endless Mode';
    el.classList.remove('disabled');
    el.removeAttribute('aria-disabled');
    el.setAttribute('title','');
    el.style.pointerEvents = 'auto';
    el.tabIndex = 0;
  } else {
    el.textContent = '???';
    el.classList.add('disabled');
    el.setAttribute('aria-disabled','true');
    el.setAttribute('title','Unlock after beating Classic');
    el.style.pointerEvents = 'none';
    el.tabIndex = -1;
  }
}


function goMenu(e){
  if (e?.preventDefault) e.preventDefault();

  // FIX: Force clear any lingering banners (like Tutorial steps)
  const b = document.getElementById('banner');
  if (b) b._queue = []; // Empty the queue so nothing else pops up
  hideBanner();         // Hide the current text immediately

  unlockAudioAndLoops();

  // NEW: when we go back to the main menu, play the menu BGM
  if (typeof playMenuBgm === 'function') {
    playMenuBgm();
  }

  if (title) title.style.display = 'none';
  if (menu)  menu.style.display  = 'flex';

  // --- FIX: Reset Menu Layers ---
  if(document.getElementById('mm-main')) document.getElementById('mm-main').style.display = 'flex';
  if(document.getElementById('mm-play')) document.getElementById('mm-play').style.display = 'none';
  if(document.getElementById('mm-stats')) document.getElementById('mm-stats').style.display = 'none';
  // ------------------------------

  syncEndlessUnlockUI();
  updateMainMenuShopLabel(); // <--- Refresh shard count
  document.getElementById('btnMenuPlay')?.focus();
}


  // ‚ñ∂ Make goMenu available to the pause menu and other scripts
  window.goMenu = goMenu;

async function startTutorial(e){
  if (e?.preventDefault) e.preventDefault();
  if (menu) menu.style.display = 'none';
  playGameBgm(CLASSIC_BGM_URL);
  
  state.gameMode = 'tutorial';
  doRestart('Adventurer'); 

  // --- 1. Init Tutorial State ---
  state.tutorialStep = 1; // Start at Step 1
  state._tutProgress = {}; // Generic container for sub-flags (wasd, items used)
  state._tutMoveWASD = { w:false, a:false, s:false, d:false }; // Movement tracking
  state._inputLocked = false;

  // --- 2. Build Linear Map (10 wide, 60 high) ---
  state.tiles = Array(60).fill().map(()=>Array(20).fill(0));
  state.rooms = [{x:5,y:5,w:10,h:50}];
  for(let y=5; y<55; y++){
    for(let x=5; x<15; x++){
      state.tiles[y][x] = 1;
    }
  }

  // --- 3. Player Start ---
  state.player.x = 10; state.player.y = 6;
  state.player.rx=10; state.player.ry=6;
  state.player.stamina = 10;
  state.seen = new Set(['10,6']);

  // --- 4. Place Static Obstacles ---
  
  // Step 3: Crate at Y=12
  for(let x=5; x<15; x++) state.tiles[12][x] = 0; // Wall row
  state.tiles[12][10] = 8; // Prop
  state.props['10,12'] = { type:'crate' }; 

  // Step 5: 3 Stunned Rats at Y=18
  state.enemies = [
    {x:9, y:18, type:'Rat', hp:1, atk:[0,0], xp:0, stunTicks:9999, tutorialDummy:true},
    {x:10, y:18, type:'Rat', hp:1, atk:[0,0], xp:0, stunTicks:9999, tutorialDummy:true},
    {x:11, y:18, type:'Rat', hp:1, atk:[0,0], xp:0, stunTicks:9999, tutorialDummy:true},
    // Step 6: 1 Melee Rat at Y=22
    {x:10, y:22, type:'Rat', hp:2, atk:[1,2], xp:0, tutorialDummy:false}, // Active rat
    // Step 8: 1 Stationary Rat at Y=30 (Bow Target)
    {x:10, y:30, type:'Rat', hp:1, atk:[0,0], xp:0, stunTicks:9999, tutorialDummy:true}
  ];

  // Step 12: Locked Door at Y=45
  for(let x=5; x<15; x++) state.tiles[45][x] = 0; 
  state.tiles[45][10] = 2; 
  state.lockedDoors = new Set(['10,45']);

  // Step 13: Chest at Y=48
  state.tiles[48][10] = 3;

  updateBars(); updateEquipUI(); draw();

  showBanner("Step 1: Move with WASD or Arrows. Press all 4 directions to continue.", 999999);
}


 function startClassic(e){
  if (e?.preventDefault) e.preventDefault();
  if (menu) menu.style.display = 'none';
  playGameBgm(CLASSIC_BGM_URL);

  // Mark mode
  state.gameMode = 'classic';
  
  // Trigger Restart logic (which now checks for Class Unlocks)
  // Passing null or undefined triggers the menu check
  doRestart(); 
}

function startEndless(e){
  if (e?.preventDefault) e.preventDefault();
  if (menu) menu.style.display = 'none';
  window.state = window.state || {};

  // Mark mode + music
  state.gameMode = 'endless';
  playGameBgm(ENDLESS_BGM_URL);

  // Trigger Restart logic (Checks for Classes)
  // Note: The "Pick 1 of 2" Omen will trigger automatically inside doRestart 
  // because we added the check at the bottom of doRestart in the previous batch.
  doRestart();
}



document.getElementById('btnEndless')?.addEventListener('click', startEndless);
syncEndlessUnlockUI();  // ‚Üê ensures the label shows ??? or Endless Mode on first load

document.getElementById('btnReturnToMenu')?.addEventListener('click', ()=>{
  // unlock Endless
  localStorage.setItem('endlessUnlocked', '1');

  // close the modal
  const m = document.querySelector('#classicClearModal');
  if (m){ m.style.display='none'; document.body.classList.remove('noscroll'); }

  // reflect unlock in the menu
  if (typeof syncEndlessUnlockUI === 'function') syncEndlessUnlockUI();
  
  // --- FIX: Go to Score Entry instead of Menu ---
  // This triggers the saveScore() logic which awards Soul Shards
  if (typeof openScoreEntry === 'function') {
      openScoreEntry();
  } else {
      if (typeof goMenu === 'function') goMenu();
  }
});



// Title: click/tap anywhere or press Enter/Space to go to Menu
if (title){
  const go = (e)=>{ goMenu(e); };

  // pointer/touch anywhere on title
  title.addEventListener('pointerdown', go, { once:true });
  title.addEventListener('touchstart',  go, { once:true, passive:true });

  // keyboard (Enter/Space)
  title.addEventListener('keydown', (e)=>{
    if (e.key === 'Enter' || e.key === ' ') goMenu(e);
  });

  // make container focusable for keyboard
  title.focus?.();
}



// Wire Menu buttons
  // -- Navigation Logic --
  const showMenuLayer = (id) => {
    ['mm-main','mm-play','mm-stats'].forEach(x => {
      const el = document.getElementById(x);
      if(el) el.style.display = (x === id) ? 'flex' : 'none';
    });
  };

  document.getElementById('btnMenuPlay')?.addEventListener('click', () => showMenuLayer('mm-play'));
  document.getElementById('btnMenuStats')?.addEventListener('click', () => showMenuLayer('mm-stats'));
  document.getElementById('btnMenuBackPlay')?.addEventListener('click', () => showMenuLayer('mm-main'));
  document.getElementById('btnMenuBackStats')?.addEventListener('click', () => showMenuLayer('mm-main'));

  // -- Actions --
  document.getElementById('btnTutorial')?.addEventListener('click', startTutorial);
  document.getElementById('btnClassic') ?.addEventListener('click', startClassic);
  document.getElementById('btnSettings')?.addEventListener('click', ()=>openModal('#settingsOverlay'));
  document.getElementById('btnCredits') ?.addEventListener('click', ()=>openModal('#creditsOverlay'));
  
// Leaderboard button in stats menu
  document.getElementById('btnShowLeaderboard')?.addEventListener('click', () => {
    const m = document.getElementById('scoreModal');
    const ent = document.getElementById('scoreEntry');
    const lst = document.getElementById('hiscoreList');
    if (m && lst) {
        m.style.zIndex = '10001';           // <--- FIX: Force z-index above Main Menu (9999)
        m.style.display = 'flex';
        if(ent) ent.style.display = 'none'; // Hide entry form
        lst.style.display = 'block';        // Show list
        if(typeof renderHiscores === 'function') renderHiscores();
    }
  });

  // --- NEW: Soul Shop Button ---
  document.getElementById('btnShop')?.addEventListener('click', (e)=>{
    e.preventDefault();
    // Ensure audio context is unlocked if clicking from a cold start
    try { if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); } catch{}
    
    renderShopUI();
    
    // Manual display set in case window.openModal isn't catching the z-index override
    const m = document.getElementById('shopModal');
    if(m) {
        m.style.display = 'flex';
        m.style.zIndex = '10001'; // Force it via JS too, just to be safe
    }
  });
  updateMainMenuShopLabel(); // Init label on load
  syncEndlessUnlockUI();                     // ‚Üê ensures label is correct on first open





  function syncEndlessUnlockUI(){
  const el = document.getElementById('btnEndless');
  if (!el) return;
  if (localStorage.getItem('endlessUnlocked') === '1'){
    el.textContent = 'Endless Mode';
    el.classList.remove('disabled');
    el.removeAttribute('aria-disabled');
    el.title = '';
  } else {
    el.textContent = '???';
    el.classList.add('disabled');
    el.setAttribute('aria-disabled','true');
    el.title = 'Unlock after beating Classic';
  }
}


  // Fallback: if overlays are missing, just start immediately (dev safety)
  if (!title && !menu){
    unlockAudioAndLoops();
    try { if (typeof boot === 'function') boot(); } catch {}
    requestAnimationFrame(()=>{ try { draw?.(); } catch {} });
  }
});




// (optional niceties)
document.addEventListener('visibilitychange', ()=>{
  if (document.visibilityState==='visible' && audioCtx && audioCtx.state==='suspended'){
    audioCtx.resume().catch(()=>{});
  }
});
window.addEventListener('beforeunload', ()=>{ try{ unloadBgm(); }catch{} });



// ---- Config (add this) ----
const ENABLE_RANDOM_DOORS = true;

// --- Healing percentages ---
const POTION_PCT = 0.25;   // 35% of Max HP (change as you like)
const TONIC_PCT  = 0.30;   // 40% of Max MP (change as you like)
// --- Heal spell percentage (per tier) ---
const HEAL_PCT_BASE     = 0.20; // Lv1 Heal = 20% of Max HP
const HEAL_PCT_PER_TIER = 0.075; // +7.5% per tier (Lv2=26%, Lv3=32%, etc.)
// === Magic config ===
// MP cost increment per tier (Lv1 is baseline)
const SPELL_COST_STEP_PER_TIER = 5;  // was 1
const SPELL_DMG_STEP_PER_TIER_MIN = 6;  // +1 to min per tier
const SPELL_DMG_STEP_PER_TIER_MAX = 6;  // +1 to max per tier



const DURABILITY = {
  Shortsword: 20,
  Claymore:   15,
  Spear:      18,
  Axe:        17,
  'Knuckle Duster': 24,     // ‚Üê added comma
  'Key of Destiny': 30      // <--- NEW: High durability
};
function defaultDurabilityFor(name){
  return Number.isFinite(DURABILITY[name]) ? DURABILITY[name] : null; // fists/null => no durability
}


// ====== Sprites (emoji-based; zero assets) ======
const SPRITES = {
  Rat: 'üêÄ',
  Goblin: 'üßå',   // surprise me
  Slime: 'üü¢',    // surprise me
  Skeleton: 'üíÄ',
  Mage: 'üßô',
  Door: 'üö™',
  Chest: 'üí∞'
};
function drawEmoji(ctx, glyph, x, y, w, h){
  // Draws a single emoji centered in the rect (x,y,w,h)
  const size = Math.min(w, h) * 0.9; // slight padding
  ctx.textAlign='center';
  ctx.textBaseline='middle';
  ctx.font = `bold ${size}px system-ui, Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji, sans-serif`;
  ctx.fillText(glyph, x + w/2, y + h/2);
}

// ====== Game State ======
const state = {
  floor:1,
  size: {w:64,h:64},
  tiles: [],          // 0 wall, 1 floor, 2 door, 3 chest, 4 stairs, 5 pickup
  rooms: [],
  corridor: new Set(),
  seen:new Set(),
    player:{
  x:0,y:0,hp:20,hpMax:20,mp:10,mpMax:10,level:1,xp:0,next:PLAYER_XP_START,
  weapon:{name:'Fists',min:1,max:2,type:'hand',base:{min:1,max:2},dur:null,durMax:null},
  poisoned:false, poisonTicks:0,
  facing:'down',
  bow:{ range:5, loaded:0 }     // ‚Üê NEW: starts unloaded; you have a bow on day one
},
    gameOver: false,
lockedDoors: new Set(),

  skills:{},          // type -> {lvl, xp, next, shown}
  enemies:[],         // {x,y,size,type,hp,atk:[a,b],xp,boss?}
  inventory:{ lockpicks:0, potions:0, tonics:0, antidotes:0, weapons:{}, arrows:0, gold:0 },
 // weapons counts
  spells:[],          // learned spells
  equippedSpell:null,          // currently equipped spell (object or null)
  spellUpgrades:{},     // { SpellName: { dmg:0..5, range:0..5, shards:0.. } }
  pickups:{},         // key(x,y) -> {kind, payload}
  fovRadius:5,
  _log:[],
  _hitParity:0,
  _shieldParity:0, // counts successful hits; durability -1 on every second success

// simple travelling FX (magic bolts / arrows)
  projectiles: [],
  _projectileAnimating: false,
  floatingText: [], 
  particles: [] // NEW: Visual particle effects (blood, dust, etc)
};

state.ui = state.ui || {};
state.ui.invTab = state.ui.invTab || 'items';


const logEl = document.getElementById('log');
function renderLog(){
  logEl.innerHTML='';
  for(const line of state._log){
    const d=document.createElement('div');
    d.textContent=String(line);
    logEl.appendChild(d);
  }
  logEl.scrollTop=logEl.scrollHeight;
}
function log(s){
  state._log.push(s);
  if(state._log.length>150) state._log.shift();
  renderLog();
}

function inBounds(x,y){return x>=0 && y>=0 && x<state.size.w && y<state.size.h}

function findFreeFloorTile(minDistFromPlayer = 2){
  for (let pass = 0; pass < 2; pass++){                   // pass 0: random in any room; pass 1: scan rooms
    // random tries first
    for (let t = 0; t < 800; t++){
      const r = state.rooms[rand(0, state.rooms.length-1)];
      if (!r) break;
      const x = rand(r.x+1, r.x+r.w-2), y = rand(r.y+1, r.y+r.h-2);
      if (!inBounds(x,y)) continue;
      if (state.tiles[y][x] !== 1) continue;              // must be floor
      if (enemyAt(x,y)) continue;
      if (dist(x,y,state.player.x,state.player.y) < minDistFromPlayer) continue;
      return {x,y};
    }
    // deterministic scan as a guaranteed fallback
    for (const r of state.rooms){
      for (let y = r.y+1; y < r.y+r.h-1; y++){
        for (let x = r.x+1; x < r.x+r.w-1; x++){
          if (!inBounds(x,y)) continue;
          if (state.tiles[y][x] !== 1) continue;
          if (enemyAt(x,y)) continue;
          if (dist(x,y,state.player.x,state.player.y) < minDistFromPlayer) continue;
          return {x,y};
        }
      }
    }
  }
  return null;
}


function enemyAt(x,y){
  for(const e of state.enemies){
    const s = e.size||1;
    if(x>=e.x && x<e.x+s && y>=e.y && y<e.y+s) return e;
  }
  return null;
}
function isPassableForPlayer(x,y){
  const t=state.tiles[y][x];
  if(enemyAt(x,y)) return false; // cannot pass through enemies

  // NEW: NPCs occupy floor tiles, so block walking through them
  if (typeof isMerchantTile === 'function' && isMerchantTile(x,y)) return false;
  if (typeof isBlacksmithTile === 'function' && isBlacksmithTile(x,y)) return false;
  if (typeof isJesterTile === 'function' && isJesterTile(x,y)) return false;
  if (typeof isCartographerTile === 'function' && isCartographerTile(x,y)) return false;

  return (t===1 || t===4 || t===5); // floor, stairs, pickups
}
function enemyCanEnter(x,y){
  if (!inBounds(x,y)) return false;
  if (x===state.player.x && y===state.player.y) return false;
  if (enemyAt(x,y)) return false;

  const inSafe = (r,xx,yy)=> r && xx>=r.x && xx<r.x+r.w && yy>=r.y && yy<r.y+r.h;
  if (inSafe(state.safeRect,  x, y)) return false;
  if (inSafe(state.safeRect2, x, y)) return false;
  if (inSafe(state.safeRect3, x, y)) return false;
  if (inSafe(state.safeRect4, x, y)) return false; // NEW: cartographer safe-room protection
  
  // --- NEW: Block enemies from walking on the Cleric ---
  if (state.cleric && x === state.cleric.x && y === state.cleric.y) return false;

  // --- NEW: Block Golden Well (2x2) ---
  if (state.goldWell) {
     const w = state.goldWell;
     if (x >= w.x && x <= w.x+1 && y >= w.y && y <= w.y+1) return false;
  }

  const t = state.tiles[y][x];
  return t===1 || t===4;
}



// Single canonical Mimic spawner (keep this one)
function spawnMimic(x, y){
  const f   = state.floor|0;
  const hp  = 10 + Math.floor(f * 1.2);
  const atkMin = 2 + Math.floor(f/3);
  const atkMax = 4 + Math.floor(f/2);
  const xp  = 12 + Math.floor(f * 1.5);

  state.enemies.push({
    x, y, size:1, boss:false,
    type:'Mimic',
    hp,
    atk:[atkMin, atkMax],
    xp,
    fast:(f >= 6)
  });
}


function dist(a,b,c,d){return Math.abs(a-c)+Math.abs(b-d)}

// Custom names per boss type
const BOSS_NAMES = {
  Rat:      'The Rat King',
  Bat:      'Count Fang',
  Spider:   'Broodmother',
  Slime:    'Sir Squish',
  Goblin:   'Carl',
  Skeleton: 'Mr. Humerus',
  Mage:     'Archon of Ash',
  Clone:    'Your Shadow' // floor 50 clone; change as you like
};

// Fallback to "<type> Boss" if you forget one
function getBossName(type){
  return BOSS_NAMES[type] || `${type} Boss`;
}


// ====== Map Gen ======
function gen(){
   state.noFog = false; 
  const W=state.size.w,H=state.size.h;
  state.tiles = Array.from({length:H},()=>Array.from({length:W},()=>0));
  state.rooms=[]; state.corridor=new Set(); state.seen=new Set();
  state.enemies=[]; state.pickups={};
  state.props={}; // <--- NEW: Init props
  state.lockedDoors = new Set();     // ‚Üê reset per-floor
state._starterChest = null;        // ‚Üê avoid stale pointer


// HARD RESET NPCs *before* any early return (boss floors)
state.merchant   = null;
state.blacksmith = null;
state.jester     = null;
state.cartographer = null;          // NEW
state.safeRect   = null;
state.safeRect2  = null;
state.safeRect3  = null;
state.safeRect4  = null;            // NEW

// ‚úÖ reset jester-per-floor usage
state.jesterSpun = false;

// NEW: Cartographer/map state reset (important for boss-floor early return)
state.cartographerMapBought   = false;
state.cartographerMapActive   = false;
state.cartographerArrowTarget = null;

stopMerchantAudio?.();
stopBlacksmithAudio?.();
stopJesterAudio?.();
stopCartographerAudio?.();





  // Boss floors are a single room with just the boss
if(state.floor % 10 === 0){
  const rw = Math.max(12, Math.floor(W*0.6));
  const rh = Math.max(12, Math.floor(H*0.6));
  const rx = Math.floor((W - rw)/2);
  const ry = Math.floor((H - rh)/2);

  for(let y=ry;y<ry+rh;y++) for(let x=rx;x<rx+rw;x++) state.tiles[y][x]=1;
  state.rooms=[{x:rx,y:ry,w:rw,h:rh}];
  state.player.x = rx + 3;
  state.player.y = ry + Math.floor(rh/2);

// turn off fog for boss floors and pre-reveal the whole boss room
state.noFog = true;
for (let y = ry; y < ry + rh; y++) {
  for (let x = rx; x < rx + rw; x++) {
    state.seen.add(key(x,y));
    
    // --- NEW: Throne Room Columns (Floor 50 only) ---
    if (state.floor === 50) {
      // Create pillars in a grid pattern (every 4th tile)
      // Keep center clear for the cutscene walking
      const relX = x - rx;
      const relY = y - ry;
      
      // Safety lane in the middle (height/2)
      const isCenterLane = Math.abs(relY - Math.floor(rh/2)) < 2;
      
      if (!isCenterLane && relX > 2 && relX < rw-2 && relX % 4 === 0 && relY % 3 === 0) {
        state.tiles[y][x] = 8; // Solid obstacle (Pillar)
        // Optional: Assign a prop look if you want specific pillar art
        if(!state.props) state.props = {};
        state.props[key(x,y)] = { type: 'pillar' }; 
      }
    }
    // ------------------------------------------------
  }
}



  // === BOSSES ===
// If floor 50, spawn a clone of the player; otherwise randomize a boss archetype.
let placed = false, guard = 0;
while (!placed && guard < 300){
  guard++;
  const bx = rand(rx+2, rx+rw-3);
  const by = rand(ry+2, ry+rh-3);
  if (dist(bx,by,state.player.x,state.player.y) < 10) continue;
  if (state.tiles[by][bx]!==1 || state.tiles[by][bx+1]!==1 || state.tiles[by+1][bx]!==1 || state.tiles[by+1][bx+1]!==1) continue;

  let boss;

  if (state.floor === 50){
    // --- 2√ó2 CLONE OF THE PLAYER ---
   const p = state.player;
const w = p.weapon || {min:1,max:2};

// depth-aware scaling knobs (mirrors boss math, but softened)
const f = state.floor|0;
const scale    = 1 + Math.max(0, f - 1) * 0.12;
const bossBump = (f % 10 === 0) ? 0.25 : 0;

// Compare player-based vs depth-based and take the tougher
const hpFromPlayer = Math.floor(p.hpMax * 1.6) + 20;           // beefed-up mirror
const hpFromDepth  = Math.round((24 + 4 * f) * (scale + bossBump));
const cloneHp      = Math.max(hpFromPlayer, Math.floor(hpFromDepth * 1.0)); // 22% of full boss HP

// ATK scales off your weapon but gets floor bonuses
const baseMin  = Math.max(1, w.min);
const baseMax  = Math.max(w.min + 1, w.max);
const cloneAtk = [baseMin + Math.floor(f / 4), baseMax + Math.floor(f / 3)];


    boss = {
    x: bx, y: by, size: 2, boss: true, xp: Math.round(60 * (1 + Math.max(0, (state.floor|0) - 1) * 0.10)),

    type: 'Clone',
    hp: cloneHp, atk: [cloneAtk[0], cloneAtk[1]],
    fast: !!(state.player.weapon?.type === 'two'),
    ranged: !!state.equippedSpell, range: 3,
    tint: 'hue-rotate(180deg) saturate(1.5) brightness(1.05)' // ‚Üê clone‚Äôs distinct look
  };

boss.hpMax = boss.hp;
boss.displayName = getBossName(boss.type);
 // change later if you like


  } else {
    // --- 2√ó2 BOSS FROM EXISTING MONSTER TYPES (with Endless extras) ---
const kinds = floorEnemyKinds();
const base  = kinds[Math.floor(Math.random() * kinds.length)];

const f = state.floor | 0;
const scale = 1 + Math.max(0, f - 1) * 0.12;
const bossBump = (f % 10 === 0) ? 0.25 : 0;
const hpBase = Math.round((24 + 4 * f) * (scale + bossBump));
const atkMin = base.atk[0] + Math.floor(f / 3);
const atkMax = base.atk[1] + Math.floor(f / 2);

let pickedSpecial = false;

// Endless only: fold the ‚Äúnon-cutscene Shadow and Mad King‚Äù into the rotation
if (state.gameMode === 'endless') {
  const r = Math.random();
  if (r < 0.15) {
    // Non-cutscene Shadow (Clone) ‚Äî size 1, no cutscene
    boss = makeCloneBoss(bx, by);            // returns a boss-flagged 1√ó1
    pickedSpecial = true;
  } else if (r < 0.30) {
    // Non-cutscene Mad King ‚Äî size 1, no cutscene
    boss = makeMadKing(bx, by);
    pickedSpecial = true;
  }
}

if (!pickedSpecial) {
  // Default: your existing 2√ó2 scaled ‚Äúking‚Äù from a base species
  boss = {
    x: bx, y: by, size: 2, boss: true,
    xp: Math.round(30 * (1 + Math.max(0, (state.floor|0) - 1) * 0.10)),
    type: base.type,
    hp: hpBase, atk: [atkMin, atkMax],
    tint: randomBossTint()
  };
  boss.hpMax = boss.hp;
  boss.displayName = getBossName(boss.type);

  // Behaviors so it still feels like a big version of the species
  if (base.type === 'Rat')      boss.poisonChance = 0.40;
  if (base.type === 'Bat')      boss.vampiric = true; // handled in enemyStep by type check, but good for flags
  if (base.type === 'Spider')   boss.webChance = 1.0; 
  if (base.type === 'Goblin') { boss.fast = true; boss.stealChance = 0.40; }
  if (base.type === 'Slime')  { boss.slow = true; boss._skipMove = false; }
  if (base.type === 'Skeleton'){ boss._revived = false; }
  if (base.type === 'Mage')   { boss.ranged = true; boss.range = 3; }
}
  }

    if (state.gameMode === 'classic' &&
    state.floor === 50 &&
    !(state.flags && state.flags.depth50IntroDone)) {
  // Classic only: let the cutscene spawn the boss
  placed = true;
} else {
  state.enemies.push(boss);
  placed = true;
}


}

// ensure no safe-room NPCs remain on boss floors
state.merchant  = null;
state.blacksmith = null;
state.safeRect  = null;
state.safeRect2 = null;
if (typeof stopMerchantAudio   === 'function') stopMerchantAudio();
if (typeof stopBlacksmithAudio === 'function') stopBlacksmithAudio();

state.seen.add(state.player.x + ',' + state.player.y);
return;
}


  // --- rooms with occasional corner notch ---
  const roomCount = 9;
  let attempts=0;
  while(state.rooms.length<roomCount && attempts<400){
    attempts++;
    const w=rand(6,12), h=rand(6,12);
    const x=rand(2,W-w-3), y=rand(2,H-h-3);
    let overlap=false;
    for(const r of state.rooms){
      if(!(x+w+2<r.x || y+h+2<r.y || x>r.x+r.w+2 || y>r.y+r.h+2)){overlap=true;break;}
    }
    if(!overlap){
      const r={x,y,w,h};
      state.rooms.push(r);
      for(let yy=y;yy<y+h;yy++) for(let xx=x;xx<x+w;xx++) state.tiles[yy][xx]=1;
      if(Math.random()<0.35){
        const nw=Math.max(1,Math.floor(w/4)), nh=Math.max(1,Math.floor(h/4));
        const cw=[0,w-1][Math.floor(Math.random()*2)];
        const ch=[0,h-1][Math.floor(Math.random()*2)];
        for(let dy=0;dy<nh;dy++){
          for(let dx=0;dx<nw;dx++){
            const tx = cw===0 ? x+dx : x+w-1-dx;
            const ty = ch===0 ? y+dy : y+h-1-dy;
            state.tiles[ty][tx]=0;
          }
        }
      }
    }
  }

  // Fallback: ensure at least one room exists so spawners have a target
if (state.rooms.length === 0) {
  const w = 10, h = 8;
  const x = Math.max(2, Math.floor(W/2 - w/2));
  const y = Math.max(2, Math.floor(H/2 - h/2));
  const r = { x, y, w, h };
  state.rooms.push(r);
  for (let yy = y; yy < y + h; yy++) {
    for (let xx = x; xx < x + w; xx++) {
      state.tiles[yy][xx] = 1; // carve floor
    }
  }
}

  // --- connect rooms (guarantee degree >= 2) ---
  const centers = state.rooms.map(r=>({x:Math.floor(r.x+r.w/2),y:Math.floor(r.y+r.h/2)}));
  const used=[0]; const edges=[];
  while(used.length<centers.length){
    let best=null;
    for(const i of used){
      for(let j=0;j<centers.length;j++){
        if(used.includes(j)) continue;
        const d = dist(centers[i].x,centers[i].y,centers[j].x,centers[j].y);
        if(!best||d<best.d) best={i,j,d};
      }
    }
    used.push(best.j);
    edges.push([best.i,best.j]);
  }
  const deg = Array(centers.length).fill(0);
  edges.forEach(([a,b])=>{deg[a]++;deg[b]++;});
  for(let i=0;i<centers.length;i++){
    if(deg[i] >= 2) continue;
    let bestJ=-1, bestD=Infinity;
    for(let j=0;j<centers.length;j++){
      if(j===i) continue;
      const already = edges.some(e=>(e[0]===i&&e[1]===j)||(e[0]===j&&e[1]===i));
      if(already) continue;
      const d = dist(centers[i].x,centers[i].y,centers[j].x,centers[j].y);
      if(d<bestD){ bestD=d; bestJ=j; }
    }
    if(bestJ!==-1){ edges.push([i,bestJ]); deg[i]++; deg[bestJ]++; }
  }

  // carve all corridors
  function carveCorr(x1,y1,x2,y2){
    let x=x1,y=y1;
    const dx=Math.sign(x2-x1), dy=Math.sign(y2-y1);
    while(x!==x2){ state.tiles[y][x]=1; state.corridor.add(key(x,y)); x+=dx; }
    while(y!==y2){ state.tiles[y][x]=1; state.corridor.add(key(x,y)); y+=dy; }
    state.tiles[y][x]=1; state.corridor.add(key(x,y));
  }
  for(const [ai,bi] of edges){
    const a=centers[ai], b=centers[bi];
    if(Math.random()<0.5){
      carveCorr(a.x,a.y,b.x,a.y); carveCorr(b.x,a.y,b.x,b.y);
    }else{
      carveCorr(a.x,a.y,a.x,b.y); carveCorr(a.x,b.y,b.x,b.y);
    }
  }

// --- doors on corridor-room thresholds (narrow halls only, no clusters, never in rooms) ---
const Hm = H - 1, Wm = W - 1;
const doorChance = 0.30; // tune if you want more/fewer doors

function isWall(x,y){ return inBounds(x,y) && state.tiles[y][x] === 0; }
function isFloor(x,y){ return inBounds(x,y) && state.tiles[y][x] === 1; }
function inRoomCell(x,y){
  return state.rooms.some(r => x>=r.x && x<r.x+r.w && y>=r.y && y<r.y+r.h);
}

for (let y = 1; y < Hm; y++) for (let x = 1; x < Wm; x++) {
  // must be a corridor floor cell (not room interior)
  if (state.tiles[y][x] !== 1) continue;
  if (inRoomCell(x,y)) continue; // hard stop: don't place in rooms

  const kxy = x+','+y;
  if (!state.corridor.has(kxy)) continue;

  // must touch a room on exactly one side (a threshold)
  const rN = inRoomCell(x, y-1), rS = inRoomCell(x, y+1), rE = inRoomCell(x+1, y), rW = inRoomCell(x-1, y);
  const touchesRoom = (rN||rS||rE||rW) && !(rN&&rS) && !(rE&&rW);
  if (!touchesRoom) continue;

  // must be a 1-tile-wide hallway:
  // walls on L/R with floor N/S  OR  walls on U/D with floor E/W
  const narrowVertical   = isWall(x-1,y) && isWall(x+1,y) && isFloor(x,y-1) && isFloor(x,y+1);
  const narrowHorizontal = isWall(x,y-1) && isWall(x,y+1) && isFloor(x-1,y) && isFloor(x+1,y);
  if (!(narrowVertical || narrowHorizontal)) continue;

  // avoid door clusters
  let ok = true;
  for (const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1],[2,0],[-2,0],[0,2],[0,-2]]) {
    if (inBounds(x+dx,y+dy) && state.tiles[y+dy][x+dx] === 2) { ok = false; break; }
  }

  if (ENABLE_RANDOM_DOORS && ok && Math.random() < doorChance) {
  state.tiles[y][x] = 2;
  // ~50% of placed doors start locked (tweak as you like)
  if (Math.random() < 0.5) state.lockedDoors.add(x+','+y);
}

}


// remove any door not in a 1-tile-wide hallway (safety cleanup)
for (let y = 1; y < H-1; y++) for (let x = 1; x < W-1; x++) {
  if (state.tiles[y][x] !== 2) continue;
  const narrowV = state.tiles[y][x-1]===0 && state.tiles[y][x+1]===0 && state.tiles[y-1][x]===1 && state.tiles[y+1][x]===1;
  const narrowH = state.tiles[y-1][x]===0 && state.tiles[y+1][x]===0 && state.tiles[y][x-1]===1 && state.tiles[y][x+1]===1;
  if (!(narrowV || narrowH)) state.tiles[y][x] = 1;
}

// purge locks for any doors that got removed by cleanup
state.lockedDoors.forEach(k=>{
  const [dx,dy] = k.split(',').map(Number);
  if (state.tiles?.[dy]?.[dx] !== 2) state.lockedDoors.delete(k);
});

function ensurePathToStairsUnlocked(){
  // find stairs position
  let sx=-1, sy=-1;
  for(let y=0;y<state.size.h;y++){
    for(let x=0;x<state.size.w;x++){
      if(state.tiles[y][x]===4){ sx=x; sy=y; break; }
    }
    if(sx!==-1) break;
  }
  if(sx===-1) return;

  const W=state.size.w, H=state.size.h;
  const q=[[state.player.x, state.player.y]];
  const seen=new Set([state.player.x+','+state.player.y]);
  const parent=new Map();

  const passable = (x,y)=>{
    if(!inBounds(x,y)) return false;
    const t = state.tiles[y][x];
    // treat doors as passable for search; we‚Äôll open them afterwards
    return (t===1 || t===2 || t===3 || t===4 || t===5);
  };

  while(q.length){
    const [x,y]=q.shift();
    if(x===sx && y===sy) break;
    for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
      const nx=x+dx, ny=y+dy, k=nx+','+ny;
      if(seen.has(k) || !passable(nx,ny)) continue;
      seen.add(k); parent.set(k, x+','+y); q.push([nx,ny]);
    }
  }

  // backtrack stairs ‚Üí start and open any door tiles on the path
  let k = sx+','+sy;
  while(k && parent.has(k)){
    const [px,py] = k.split(',').map(Number);
    if(state.tiles[py][px]===2){
      state.tiles[py][px]=1;           // open permanently
      state.lockedDoors.delete(k);     // remove lock if any
    }
    k = parent.get(k);
  }
}




 // --- spawn point ---
const startRoom = state.rooms[0];
state.player.x = Math.floor(startRoom.x+startRoom.w/2);
state.player.y = Math.floor(startRoom.y+startRoom.h/2);

// keep a reference to the current floor's spawn room
state.startRoom = startRoom;

// a padded rectangle inside the start room that enemies can NEVER spawn in
const pad = 1; // keep 1 tile of padding from walls; tweak if you like
state.spawnRect = {
  x1: startRoom.x + pad,
  y1: startRoom.y + pad,
  x2: startRoom.x + startRoom.w - 1 - pad,
  y2: startRoom.y + startRoom.h - 1 - pad,
};

// tiny helper
function inSpawnRect(x, y){
  const r = state.spawnRect;
  return r && x >= r.x1 && x <= r.x2 && y >= r.y1 && y <= r.y2;
}


// --- stairs in farthest room center ---
let farIdx=0, farD=-1;
for(let i=0;i<state.rooms.length;i++){
  const c={x:Math.floor(state.rooms[i].x+state.rooms[i].w/2), y:Math.floor(state.rooms[i].y+state.rooms[i].h/2)};
  const d=dist(c.x,c.y,state.player.x,state.player.y);
  if(d>farD){farD=d; farIdx=i;}
}
const rr=state.rooms[farIdx];
const sx=Math.floor(rr.x+rr.w/2), sy=Math.floor(rr.y+rr.h/2);
state.tiles[sy][sx] = 4;
// remember the room that contains the stairs (for spawn exclusions)
state._stairsRoom = rr;


// --- starter chest only on floor 1 adjacent ---
if (state.floor===1){
  const adj = shuffle([[1,0],[-1,0],[0,1],[0,-1]]);
  for (const [dx,dy] of adj){
    const x=state.player.x+dx, y=state.player.y+dy;
    if (inBounds(x,y) && state.tiles[y][x]===1){
      state.tiles[y][x]=3;
      state._starterChest = x + ',' + y;   // <‚Äî mark the starter chest coords
      break;
    }
  }
}

state.mimicChests = new Set();


// --- Shrines (tile 6) ---
ensurePathToStairsUnlocked(); 

if (state.gameMode === 'endless' || state.gameMode === 'classic') {
  let shrineCount = rand(1, 2); 
  const shrineRooms = new Set();

  while(shrineCount > 0){ 
    // Pick a random room index
    const roomIndex = rand(0, state.rooms.length-1);
    const r = state.rooms[roomIndex]; 

    if(!r) break; 
    
    // NEW: Skip this room if a shrine is already placed here
    if (shrineRooms.has(roomIndex)) {
        continue; // Try picking a new room index
    }
    
    // Pick a random tile within that room
    const x = rand(r.x+1, r.x+r.w-2); 
    const y = rand(r.y+1, r.y+r.h-2); 

    // Only place on empty floor tiles (t===1) and ensure no enemy is there 
    if(state.tiles[y][x] === 1 && !enemyAt(x,y)){ 
      state.tiles[y][x] = 6; // Place Shrine (Tile ID 6) 
      shrineCount--; 
      // NEW: Mark the room as used
      shrineRooms.add(roomIndex);
    } 
  }
}
// --- NEW: Spike Traps (Tile 7) ---
// Scale with floor: 2 traps at floor 1, up to 12 at floor 50
let trapCount = Math.min(12, 2 + Math.floor(state.floor / 5));
let trapSafe = 0;
while(trapCount > 0 && trapSafe < 500){
  trapSafe++;
  // Pick random room
  const r = state.rooms[rand(0, state.rooms.length-1)];
  if(!r) continue;
  
  // Pick spot
  const x = rand(r.x+1, r.x+r.w-2);
  const y = rand(r.y+1, r.y+r.h-2);
  
  // Check validity: must be floor, no enemies, not start room
  if(state.tiles[y][x] === 1 && !enemyAt(x,y) && r !== state.startRoom){
    state.tiles[y][x] = 7;
    trapCount--;
  }
}


// ===== Merchant & Blacksmith safe-room spawns =====
state.merchant = null;
  state.blacksmith = null;
  state.jester = null;
  state.cartographer = null;
  state.safeRect = null;
  state.safeRect2 = null;
  state.safeRect3 = null;
  state.safeRect4 = null;
  stopMerchantAudio();
stopBlacksmithAudio();
stopJesterAudio?.();
stopCartographerAudio?.();
stopClericAudio?.(); // <--- NEW

  // Cartographer/map state gets cleared every floor
  state.cartographerMapBought  = false;
  state.cartographerMapActive  = false;
  state.cartographerArrowTarget = null;

  let spawnedMerchant   = false;
  let spawnedBlacksmith = false;
  let spawnedJester     = false;
  let spawnedCartographer = false;
  let spawnedCleric     = false; // <--- NEW


if (state.gameMode !== 'tutorial' && state.floor % 10 !== 0 && Math.random() < MERCHANT_SPAWN_CHANCE){
  const rooms = state.rooms
  .slice(1)                                   // avoid start room
  .filter(r => r !== state._stairsRoom);      // NEW: never the stairs room
const pick  = rooms.length ? rooms[rand(0, rooms.length-1)] : null;

  if (pick){
    // safe room interior bounds
    const rx = pick.x+1, ry = pick.y+1;
    const rw = Math.max(1, pick.w-2), rh = Math.max(1, pick.h-2);

    // need at least 3 interior tiles horizontally
    if (rw >= 3){
      const cx = rand(rx+1, rx+rw-2); // center so left/right fit inside
      const cy = rand(ry,    ry+rh-1);

      state.merchant = {
  x: cx, y: cy,
  left:  { x: cx-1, y: cy },
  right: { x: cx+1, y: cy },
  room: { x: rx, y: ry, w: rw, h: rh },
  stock: null            // ‚Üê per-floor, filled on first Buy open
};

      state.safeRect = { x: rx, y: ry, w: rw, h: rh };
spawnedMerchant = true;
ensureMerchantAudio();

    }
  }
}

// ---- Blacksmith safe-room spawn (25%) ‚Äî 3-wide: [anvil][smith][anvil]
if (state.gameMode !== 'tutorial' && state.floor % 10 !== 0 && Math.random() < BLACKSMITH_SPAWN_CHANCE){
  // Rooms eligible: not start, not stairs, and NOT the merchant's room
  const rooms2 = state.rooms
    .slice(1)
    .filter(r => r !== state._stairsRoom)
    .filter(r => {
      if (!state.merchant?.room) return true;
      // skip if this room's interior equals the merchant safe interior
      const rx = r.x+1, ry = r.y+1;
      const rw = Math.max(1, r.w-2), rh = Math.max(1, r.h-2);
      const mr = state.merchant.room;
      return !(rx===mr.x && ry===mr.y && rw===mr.w && rh===mr.h);
    });

  const pick2 = rooms2.length ? rooms2[rand(0, rooms2.length-1)] : null;
  if (pick2){
    const rx2 = pick2.x+1, ry2 = pick2.y+1;
    const rw2 = Math.max(1, pick2.w-2), rh2 = Math.max(1, pick2.h-2);
    if (rw2 >= 3){
      const cx2 = rand(rx2+1, rx2+rw2-2);
      const cy2 = rand(ry2,    ry2+rh2-1);

      state.blacksmith = {
        x: cx2, y: cy2,
        left:  { x: cx2-1, y: cy2 },
        right: { x: cx2+1, y: cy2 },
        room:  { x: rx2, y: ry2, w: rw2, h: rh2 }
      };

      state.safeRect2 = { x: rx2, y: ry2, w: rw2, h: rh2 };
      spawnedBlacksmith = true;
      ensureBlacksmithAudio();
    }
  }
}

// ---- Jester spawn (20% chance on non-boss floors) ----
if (state.gameMode === 'endless' && state.floor % 10 !== 0 && Math.random() < JESTER_SPAWN_CHANCE){
  // Eligible rooms: not start, not stairs, not merchant/blacksmith rooms
  const rooms3 = state.rooms
    .slice(1)
    .filter(r => r !== state._stairsRoom)
    .filter(r => {
      // skip merchant and blacksmith safe rooms
      const mr = state.merchant?.room, br = state.blacksmith?.room;
      const rx = r.x+1, ry = r.y+1;
      const rw = Math.max(1, r.w-2), rh = Math.max(1, r.h-2);
      if (mr && rx===mr.x && ry===mr.y && rw===mr.w && rh===mr.h) return false;
      if (br && rx===br.x && ry===br.y && rw===br.w && rh===br.h) return false;
      return true;
    });
  const pick3 = rooms3.length ? rooms3[rand(0, rooms3.length-1)] : null;
  if (pick3){
    const rx3 = pick3.x+1, ry3 = pick3.y+1;
    const rw3 = Math.max(1, pick3.w-2), rh3 = Math.max(1, pick3.h-2);
    if (rw3 >= 3){
      const cx3 = rand(rx3+1, rx3+rw3-2);
      const cy3 = rand(ry3,    ry3+rh3-1);
      state.jester = {
        x: cx3, y: cy3,
        left:  { x: cx3-1, y: cy3 },
        right: { x: cx3+1, y: cy3 },
        room:  { x: rx3, y: ry3, w: rw3, h: rh3 }
      };
      state.safeRect3 = { x: rx3, y: ry3, w: rw3, h: rh3 };
      spawnedJester = true;
      ensureJesterAudio();
    }
  }
}

// --- NEW: Gold Well (Rare 2x2 Prop) ---
// 25% Chance on non-boss floors (Can now co-exist with NPCs)
state.goldWell = null;
if (state.gameMode !== 'tutorial' && state.floor % 10 !== 0 && Math.random() < 0.25) {
  const r = state.rooms[rand(1, state.rooms.length-1)];
  if (r && r.w >= 4 && r.h >= 4) {
     const wx = Math.floor(r.x + r.w/2) - 1;
     const wy = Math.floor(r.y + r.h/2) - 1;
     
     // Ensure space is floor AND not occupied by an existing NPC
     if (state.tiles[wy][wx]===1 && state.tiles[wy+1][wx+1]===1 &&
         !isMerchantTile(wx, wy) && !isBlacksmithTile(wx, wy) && 
         !isJesterTile(wx, wy) && !isCartographerTile(wx, wy)) {
         
       state.goldWell = { x:wx, y:wy, used:false };
       showBanner("A Golden Well shimmers nearby...", 4000); 
     }
  }
}

// ---- Cartographer safe-room spawn ----
  if ((state.gameMode === 'endless' || state.gameMode === 'classic') && state.floor % 10 !== 0 && Math.random() < CARTOGRAPHER_SPAWN_CHANCE) {
    const rooms4 = state.rooms
      .slice(1)
      .filter(r => r !== state._stairsRoom)
      .filter(r => {
        const mr = state.merchant?.room;
        const br = state.blacksmith?.room;
        const jr = state.jester?.room;
        const rx = r.x+1, ry = r.y+1;
        const rw = Math.max(1, r.w-2), rh = Math.max(1, r.h-2);
        if (mr && rx===mr.x && ry===mr.y && rw===mr.w && rh===mr.h) return false;
        if (br && rx===br.x && ry===br.y && rw===br.w && rh===br.h) return false;
        if (jr && rx===jr.x && ry===jr.y && rw===jr.w && rh===jr.h) return false;
        return true;
      });

    const pick4 = rooms4.length ? rooms4[rand(0, rooms4.length-1)] : null;
    if (pick4) {
      const rx4 = pick4.x+1, ry4 = pick4.y+1;
      const rw4 = Math.max(1, pick4.w-2), rh4 = Math.max(1, pick4.h-2);
      if (rw4 >= 3) {
        const cx4 = rand(rx4+1, rx4+rw4-2);
        const cy4 = rand(ry4,   ry4+rh4-1);
        state.cartographer = {
          x: cx4, y: cy4,
          left:  { x: cx4-1, y: cy4 },
          right: { x: cx4+1, y: cy4 },
          room:  { x: rx4, y: ry4, w: rw4, h: rh4 }
        };
        state.safeRect4 = { x: rx4, y: ry4, w: rw4, h: rh4 };
spawnedCartographer = true;
ensureCartographerAudio();
      }
    }
  }

  // --- NEW: Cleric Spawn (15% chance, non-boss floors) ---
  state.cleric = null; // Reset
  // RESTRICTED: Endless Mode only
if (state.gameMode === 'endless' && state.floor % 10 !== 0 && Math.random() < 0.15) { // <--- Removed random check     // Reuse logic: Find a room not used by others
     const rooms5 = state.rooms.slice(1).filter(r => r !== state._stairsRoom && !state.merchant?.room && !state.blacksmith?.room && !state.jester?.room && !state.cartographer?.room);
     const pick5 = rooms5.length ? rooms5[rand(0, rooms5.length-1)] : null;
     
     if (pick5) {
       const cx = Math.floor(pick5.x + pick5.w/2);
       const cy = Math.floor(pick5.y + pick5.h/2);
       // Simple single tile spawn in center
       state.cleric = { x:cx, y:cy };
       spawnedCleric = true;
       ensureClericAudio();
     }
  }
  // ------------------------------------------------------


// --- NEW: Dynamic Spawn Message (Handles any combination of 5 NPCs) ---
const sounds = [];
if (spawnedMerchant)     sounds.push("jingling coins");
if (spawnedBlacksmith)   sounds.push("a hammer ringing");
if (spawnedJester)       sounds.push("raucous laughter");
if (spawnedCartographer) sounds.push("parchment rustling");
if (spawnedCleric)       sounds.push("soft chanting");

if (sounds.length > 0) {
  // Join with commas and an Oxford comma/and
  let text = "you hear " + sounds[0];
  if (sounds.length === 2) {
    text = `you hear ${sounds[0]} and ${sounds[1]} nearby`;
  } else if (sounds.length > 2) {
    const last = sounds.pop();
    text = `you hear ${sounds.join(", ")}, and ${last} nearby`;
  } else {
    text = `you hear ${sounds[0]} nearby`;
  }
  showBanner(text, 3600);
}
// ---------------------------------------------------------------------





  
// --- extra random chests ---
  let chestCount = rand(1,3) + Math.floor(state.floor/4);
  let safe=0;
  while(chestCount>0 && safe<2000){
    safe++;
    const r = state.rooms[rand(0,state.rooms.length-1)];
    if(!r) continue;
    const x=rand(r.x+1,r.x+r.w-2), y=rand(r.y+1,r.y+r.h-2);

    // NEW: never place chests on top of NPC tiles
if (isMerchantTile(x,y) || isBlacksmithTile(x,y) || isJesterTile(x,y) || isCartographerTile(x,y)) continue;


    if(x===state.player.x && y===state.player.y) continue;
    if(state.tiles[y][x]!==1) continue;
    if(state.tiles[y][x]===4) continue;
    if(state.floor===1 && r===startRoom) continue;
    // always place a chest tile
    state.tiles[y][x] = 3;


// 25% chance: this chest is actually a Mimic (revealed when opened)
const key = `${x},${y}`;
if (key !== state._starterChest && Math.random() < 0.25) {
  state.mimicChests.add(key);
}

chestCount--;
  }

// --- enemies ---
let toSpawn = (state.floor === 1 ? rand(5,8) : rand(6,10) + Math.floor(state.floor/2));
const kinds = floorEnemyKinds();  // ‚Üê use floor-scaled templates

let guard = 0;
while (toSpawn > 0 && guard < 2000) {
  guard++;

  // pick a room and coordinates you already consider valid
  // inside spawnEnemies while (toSpawn > 0) { ... }
const r = state.rooms[rand(0, state.rooms.length - 1)];
if (!r) continue;

// ‚õî NEW: never spawn in the player's spawn room
if (r === state.startRoom) continue;

const x = rand(r.x + 1, r.x + r.w - 2);
const y = rand(r.y + 1, r.y + r.h - 2);

// ‚õî NEW: keep the start-room interior clear
if (typeof inSpawnRect === 'function' && inSpawnRect(x, y)) continue;

// ... keep your existing legality checks (floor, not blocked, etc.)

  if (!inBounds(x,y)) continue;
  if (state.tiles[y][x] !== 1) continue;       // floor tile
  if (enemyAt(x,y)) continue;                  // no stacking
  if (x === state.player.x && y === state.player.y) continue;
    
// SAFE ROOMS: block initial spawns here
const inSafe = (r,x,y)=> r && x>=r.x && x<r.x+r.w && y>=r.y && y<r.y+r.h;
if (
      inSafe(state.safeRect,  x, y) ||
      inSafe(state.safeRect2, x, y) ||
      inSafe(state.safeRect3, x, y) ||
      inSafe(state.safeRect4, x, y)
    ) continue;


// pick kind and build enemy
  const k = kinds[Math.floor(Math.random() * kinds.length)];
  const e = { x, y, size:1, boss:false, type:k.type, hp:k.hp, atk:[...k.atk], xp:k.xp };

  // SHADOW LABYRINTH: 40% chance to spawn a Heartless instead
  if (state.floorEffect === 'ShadowLabyrinth' && Math.random() < 0.40) {
    e.type = 'Heartless';
    e.hp = Math.max(1, Math.floor(e.hp * 0.8)); // Slightly weaker than avg
    e.fast = true;                              // But fast/twitchy
    e.xp = Math.max(1, e.xp - 1);               // Worth slightly less XP
    // Reset specific traits from the original roll
    e.poisonChance = 0; 
    e.stealChance = 0;
    e.ranged = false;
  }

  // per-type traits (mirror what you do elsewhere)
  if (k.type === 'Rat')      { e.poisonChance = 0.20; }
  if (k.type === 'Goblin')   { e.fast = true; e.stealChance = 0.20; }
  if (k.type === 'Slime')    { e.slow = true; e._skipMove = false; }
  if (k.type === 'Skeleton') { e._revived = false; }
  if (k.type === 'Mage')     { e.ranged = true; e.range = 3; }


  state.enemies.push(e);
  toSpawn--;
}


  // keep cap in sync
// --- NEW: Mini-Boss Spawn (Floors 5, 15, 25... in Endless) ---
  if (state.gameMode === 'endless' && state.floor % 5 === 0 && state.floor % 10 !== 0) {
      // Try 50 times to find a valid room center
      for(let i=0; i<50; i++) {
          const r = state.rooms[rand(0, state.rooms.length-1)];
          const ex = Math.floor(r.x + r.w/2);
          const ey = Math.floor(r.y + r.h/2);
          
          // Don't spawn on top of player, existing enemy, or NPCs
          if (dist(ex, ey, state.player.x, state.player.y) > 5 && !enemyAt(ex, ey) &&
              !isMerchantTile(ex,ey) && !isBlacksmithTile(ex,ey)) {
              
              const miniBoss = {
                  type: 'Warlord', 
                  x: ex, y: ey,
                  hp: 45 + (state.floor * 4), 
                  hpMax: 45 + (state.floor * 4),
                  atk: [8 + Math.floor(state.floor/3), 12 + Math.floor(state.floor/2)],
                  xp: 100, 
                  miniBoss: true, // Flag for rewards
                  size: 1
              };
              state.enemies.push(miniBoss);
              log("A Warlord guards this floor...");
              break; 
          }
      }
  }

  state.enemyCap = state.enemies.length;

  // --- NEW: Scenery / Props Generation ---
// Add 8-15 random flavor objects (passable) per floor
// --- NEW: Scenery / Props Generation ---
let propCount = rand(8, 15);
let propSafe = 0;
while(propCount > 0 && propSafe < 1000){
  propSafe++;
  const rx = rand(1, state.size.w-2);
  const ry = rand(1, state.size.h-2);
  
  // 1. NEW: Must be strictly inside a room (padded by 1) to avoid blocking hallways/doors
  const inRoom = state.rooms.some(r => 
    rx >= r.x + 1 && rx < r.x + r.w - 1 && 
    ry >= r.y + 1 && ry < r.y + r.h - 1
  );
  if (!inRoom) continue;

  // Must be empty floor (1), no pickup (5), no stairs (4), no trap (7)
  if (state.tiles[ry][rx] !== 1) continue; 
  if (state.pickups[key(rx,ry)]) continue;
  if (enemyAt(rx,ry)) continue;
  if (rx===state.player.x && ry===state.player.y) continue;
  
// Don't put on NPC tiles
  if (isMerchantTile(rx,ry) || isBlacksmithTile(rx,ry) || isJesterTile(rx,ry) || isCartographerTile(rx,ry)) continue;

// Determine prop pool based on floor depth
  let types = ['crate','barrel','rubble']; // Default fallback
  const f = state.floor;
  
  if (f <= 10) { // Sewers
    types = ['crate','barrel','rubble','slime puddle','pipe debris','rat nest','broken grate','toxic barrel'];
  } else if (f <= 20) { // Crypt
    types = ['coffin','urn','bones','broken tomb','candle stand','gargoyle','spider web','skull pile'];
  } else if (f <= 30) { // Magma
    types = ['obsidian_shard','ash pile','magma rock','burnt cage','lava vent','iron chain','dragon bone'];
  } else if (f <= 40) { // Jungle/Ruins
    types = ['fern','broken pillar','vine cluster','mossy rock','giant flower','stone idol','ancient pot'];
  } else if (f <= 50) { // Void
    types = ['floating rock','crystal shard','void tendril','star mote','dark monolith','energy swirl'];
  } else { // Gilded
    types = ['gold vase','statue head','velvet stool','treasure pile','red carpet','chandelier fallen'];
  }

  state.props[key(rx,ry)] = { type: types[rand(0, types.length-1)] };
  
  // Set tile to 8 (Obstacle)
  state.tiles[ry][rx] = 8;
  
  propCount--;
}
// ---------------------------------------


// === PICKUP TOP-UP: guarantee a higher amount per floor ===
state.enemyCap    = state.enemies.length;
state.respawnTick = 0;
state.respawnEvery = 50 + Math.floor(state.floor/2); // tweak pacing here



// --- pickups ---
  let pickupCount = rand(4,8);
  let tries=0;
  while(pickupCount>0 && tries<3000){
    tries++;
    const r=state.rooms[rand(0,state.rooms.length-1)];
    if(!r) continue;
    const x=rand(r.x+1,r.x+r.w-2), y=rand(r.y+1,r.y+r.h-2);

    // NEW: never place floor loot on NPC tiles
if (isMerchantTile(x,y) || isBlacksmithTile(x,y) || isJesterTile(x,y) || isCartographerTile(x,y)) continue;


    if(state.tiles[y][x]!==1) continue;
    if(dist(x,y,state.player.x,state.player.y)<3) continue;
    const kxy=key(x,y);
    if(state.pickups[kxy]) continue;

    const roll = Math.random();
    let kind, payload;
// ORDER MATTERS: lowest ‚Üí highest
if (roll < 0.14) { kind='weapon';    payload=randomWeapon(); }  // was 0.18
else if (roll < 0.35) { kind='potion';    payload=1; }
else if (roll < 0.47) { kind='tonic';     payload=1; }
else if (roll < 0.65) { kind='lockpicks'; payload=rand(1,3); }
else if (roll < 0.75) { kind='antidote';  payload=1; }
else if (roll < 0.87) { kind='arrows';    payload=rand(4,9); }
else { kind='spell';   payload=randomSpell(); }


    state.pickups[kxy]={kind,payload};
    state.tiles[y][x]=5;
    pickupCount--;
  }

  // --- SAFETY FALLBACKS (guarantee minimum spawns) ---
  // If no enemies made it onto the map, seed a few
  if (state.enemies.length === 0) {
    const kinds = floorEnemyKinds();
    const want = Math.max(3, Math.floor(3 + state.floor / 6));
    let placed = 0, guardAll = 0;

    while (placed < want && guardAll++ < 2000) {
      const r = state.rooms[rand(1, state.rooms.length - 1)] || state.rooms[0];
      if (!r) break;
      const x = rand(r.x + 1, r.x + r.w - 2);
      const y = rand(r.y + 1, r.y + r.h - 2);

      if (!inBounds(x,y)) continue;
      if (state.tiles[y][x] !== 1) continue;
      if (enemyAt(x,y)) continue;
      if (x === state.player.x && y === state.player.y) continue;

// SAFE ROOM: block respawns (merchant, blacksmith, jester)
    const inSafeRoom = (r)=> r && x >= r.x && x < r.x+r.w && y >= r.y && y < r.y+r.h;
    if (inSafeRoom(state.safeRect) || inSafeRoom(state.safeRect2) || inSafeRoom(state.safeRect3)) continue;


      const k = kinds[Math.floor(Math.random() * kinds.length)];
      state.enemies.push({ x, y, size:1, boss:false, type:k.type, hp:k.hp, atk:[...k.atk], xp:k.xp });

      // mirror your per-type traits
      if (k.type === 'Rat')      state.enemies[state.enemies.length-1].poisonChance = 0.20;
      if (k.type === 'Goblin') { state.enemies[state.enemies.length-1].fast = true; state.enemies[state.enemies.length-1].stealChance = 0.20; }
      if (k.type === 'Slime')  { state.enemies[state.enemies.length-1].slow = true; state.enemies[state.enemies.length-1]._skipMove = false; }
      if (k.type === 'Skeleton') state.enemies[state.enemies.length-1]._revived = false;
      if (k.type === 'Mage')    { state.enemies[state.enemies.length-1].ranged = true; state.enemies[state.enemies.length-1].range = 3; }

      placed++;
    }
  }

  // If pickups failed to place, drop at least one near‚Äîbut not next to‚Äîthe player
  if (Object.keys(state.pickups).length === 0) {
    let tries2 = 0;
    while (tries2++ < 500) {
      const r = state.rooms[rand(0, state.rooms.length-1)];
      if (!r) break;
      const x = rand(r.x + 1, r.x + r.w - 2);
      const y = rand(r.y + 1, r.y + r.h - 2);
      if (!inBounds(x,y)) continue;
      if (state.tiles[y][x] !== 1) continue;
      if (dist(x,y,state.player.x,state.player.y) < 3) continue;
      const kxy = key(x,y);
      if (state.pickups[kxy]) continue;

      state.pickups[kxy] = { kind:'potion', payload:1 };
      state.tiles[y][x] = 5;
      break;
    }
  }

  // Sync respawn cap with whatever we actually have now
  state.enemyCap = state.enemies.length;



// If pickups are still 0, force-drop a potion at a valid tile.
if (Object.keys(state.pickups).length === 0){
  const spot = findFreeFloorTile(3);               // keep a little distance from player
  if (spot){
    const kxy = key(spot.x,spot.y);
    state.pickups[kxy] = { kind:'potion', payload:1 };
    state.tiles[spot.y][spot.x] = 5;
  }
}

// Keep your respawn cap in sync with whatever we ended up with
state.enemyCap = state.enemies.length;

// === FINAL GUARANTEE (cannot fail) ===
if (state.enemies.length === 0){
  const spot = findFreeFloorTile(2);
  if (spot){
    const kinds = floorEnemyKinds();
    const k = kinds[Math.floor(Math.random()*kinds.length)];
    const e = { x:spot.x, y:spot.y, size:1, boss:false, type:k.type, hp:k.hp, atk:[...k.atk], xp:k.xp };
    if (k.type === 'Rat')      e.poisonChance = 0.20;
    if (k.type === 'Goblin') { e.fast = true; e.stealChance = 0.20; }
    if (k.type === 'Slime')  { e.slow = true; e._skipMove = false; }
    if (k.type === 'Skeleton') e._revived = false;
    if (k.type === 'Mage')   { e.ranged = true; e.range = 3; }
    state.enemies.push(e);
  } else if (state.rooms.length) {
    // deterministic last-ditch: first interior cell of the first room
    // fallback: pick the first NON-start room, else default to rooms[0]
const r = state.rooms.find(room => room !== state.startRoom) || state.rooms[0];

// choose a safe interior cell
let x = Math.min(r.x + 2, r.x + r.w - 2);
let y = Math.min(r.y + 2, r.y + r.h - 2);

// ‚õî also respect the no-spawn rectangle here
if (typeof inSpawnRect === 'function' && inSpawnRect(x, y)) {
  // walk the room until you find a cell outside the spawn rect
  outer:
  for (let yy = r.y + 1; yy < r.y + r.h - 1; yy++) {
    for (let xx = r.x + 1; xx < r.x + r.w - 1; xx++) {
      if (!inSpawnRect(xx, yy)) { x = xx; y = yy; break outer; }
    }
  }
}


// SAFE ROOM: if this spot is inside, pick an alternate free tile
if (state.safeRect){
  const sr = state.safeRect;
  if (x >= sr.x && x < sr.x+sr.w && y >= sr.y && y < sr.y+sr.h){
    const alt = (typeof findFreeFloorTile === 'function') ? findFreeFloorTile(2) : null;
    if (alt){ x = alt.x; y = alt.y; }
  }
}

state.enemies.push({ x, y, size:1, boss:false, type:'Rat', hp:4, atk:[1,2], xp:3 });

  }
}

if (Object.keys(state.pickups).length === 0){
  const spot = findFreeFloorTile(3);
  if (spot){
    const kxy = key(spot.x,spot.y);
    state.pickups[kxy] = { kind:'potion', payload:1 };
    state.tiles[spot.y][spot.x] = 5;
  } else if (state.rooms.length) {
    // deterministic last-ditch: opposite corner of start room
    const r = state.rooms[0];
    const x = Math.min(r.x + r.w - 3, r.x + 2);
    const y = Math.min(r.y + r.h - 3, r.y + 2);
    const kxy = key(x,y);
    state.pickups[kxy] = { kind:'potion', payload:1 };
    state.tiles[y][x] = 5;
  }
}

// keep cap in sync

// === ONE ELITE ENEMY PER FLOOR (non-boss floors) ===
// Elite = tinted like bosses, but weaker than bosses (size 1, no stairs on death)
if ((state.gameMode === 'endless' || state.gameMode === 'classic') && (state.floor % 10) !== 0 && Array.isArray(state.enemies) && state.enemies.length) {
  const candidates = state.enemies.filter(e => e && !e.boss && e.size === 1 && !e.elite);
  if (candidates.length) {
    const elite = candidates[rand(0, candidates.length - 1)];
    elite.elite = true;
    elite.tint  = randomBossTint();

    // Slightly stronger (but not boss-tier)
elite.hp = Math.max(1, Math.round((elite.hp || 1) * 1.50));
elite.hpMax = elite.hp;

if (Array.isArray(elite.atk) && elite.atk.length === 2) {
  elite.atk[0] = Math.max(0, Math.floor(elite.atk[0] * 1.25) + 1);
  elite.atk[1] = Math.max(elite.atk[0], Math.floor(elite.atk[1] * 1.25) + 1);
}

elite.xp = Math.max(1, Math.round((elite.xp || 1) * 2.00));
  }
}


state.enemyCap = state.enemies.length;


// === PICKUP TOP-UP: guarantee a higher amount per floor ===



// === PICKUP TOP-UP: guarantee a higher amount per floor ===
// target = base (2) + 60% of rooms + small depth bonus (max +4)
{
  const base = 2;
  const roomBonus = Math.round(state.rooms.length * 0.6);
  const depthBonus = Math.min(4, Math.floor((state.floor|0) / 3));
  const want = base + roomBonus + depthBonus;

  const isFreeFloor = (x,y)=> inBounds(x,y) && state.tiles[y][x] === 1
    && dist(x,y,state.player.x,state.player.y) >= 2
    && !enemyAt(x,y);

  // local helper: try random room cells, then scan deterministically
  const pickSpot = ()=>{
    // random tries across rooms
    for (let t = 0; t < 600; t++){
      const r = state.rooms[rand(0, state.rooms.length-1)];
      if (!r) break;
      const x = rand(r.x+1, r.x+r.w-2);
      const y = rand(r.y+1, r.y+r.h-2);
      if (isFreeFloor(x,y)) return {x,y};
    }
    // deterministic scan so we never fail entirely
    for (const r of state.rooms){
      for (let y = r.y+1; y < r.y+r.h-1; y++){
        for (let x = r.x+1; x < r.x+r.w-1; x++){
          if (isFreeFloor(x,y)) return {x,y};
        }
      }
    }
    return null;
  };

  let tries = 1200;
  while (Object.keys(state.pickups).length < want && tries-- > 0){
    const spot = pickSpot();
    if (!spot) break;
    const kxy = key(spot.x, spot.y);
    if (state.pickups[kxy]) continue;   
    // keep NPC tiles clear
if (typeof isMerchantTile === 'function' && isMerchantTile(spot.x, spot.y)) continue;
if (typeof isBlacksmithTile === 'function' && isBlacksmithTile(spot.x, spot.y)) continue;
if (typeof isJesterTile === 'function' && isJesterTile(spot.x, spot.y)) continue;
if (typeof isCartographerTile === 'function' && isCartographerTile(spot.x, spot.y)) continue;
if (typeof isClericTile === 'function' && isClericTile(spot.x, spot.y)) continue; // --- NEW ---
    
         // already something here

    // simple, stable distribution; tweak as you like
    // NEW: wider pool so weapons (and a few others) can appear
// simple, stable distribution; tweak as you like
// simple, stable distribution; tweak as you like
let kind, payload;
const r = Math.random();

if (r < 0.12){
  kind = 'weapon';                      // ~12%
  payload = randomWeapon();
} else if (r < 0.18){
  kind = 'spell';                       // +6%
  payload = randomSpell();
} else if (r < 0.24){
  kind = 'arrows';                      // +6%
  payload = rand(2, 6);
} else if (r < 0.27){                   // --- NEW: 3% Chance for Bomb
  kind = 'bomb';
  payload = 1;
} else if (r < 0.29){                   // --- NEW: 2% Chance for Warp Stone
  kind = 'warp';
  payload = 1;
} else if (r < 0.52){                   // Adjusted thresholds to fit
  kind = 'potion';                      
  payload = 1;
} else if (r < 0.75){
  kind = 'tonic';                       
  payload = 1;
} else if (r < 0.81){
  kind = 'shield';                      
  payload = 1;
} else {
  kind = 'antidote';                    
  payload = 1;
}


state.pickups[kxy] = { kind, payload };
state.tiles[spot.y][spot.x] = 5;
            // mark pickup tile
  }
}



// (debug log below stays as-is)

  // Debug: show what ultimately spawned this floor
  //    if (typeof log === 'function') {
  //    log(`Depth ${state.floor}: spawned ${state.enemies.length} enemies, ${Object.keys(state.pickups).length} pickups`);
  //    } 

  

  // === ACCESS GUARANTEE PASSES ===
  function thresholdsForRoom(r){
    const list=[];
    let open=0, doors=0;
    const inRoom=(xx,yy)=> xx>=r.x&&xx<r.x+r.w&&yy>=r.y&&yy<r.y+r.h;
    state.corridor.forEach(k=>{
      const [cx,cy]=k.split(',').map(Number);
      const t = state.tiles[cy]?.[cx];
      if(t!==1 && t!==2) return;
      const rN=inRoom(cx,cy-1), rS=inRoom(cx,cy+1), rE=inRoom(cx+1,cy), rW=inRoom(cx-1,cy);
      const touches = (rN||rS||rE||rW) && !(rN&&rS) && !(rE&&rW);
      if(!touches) return;
      list.push([cx,cy]);
      if(t===1) open++; else doors++;
    });
    return {list, open, doors};
  }

  for(const r of state.rooms){
    let info = thresholdsForRoom(r);
    if(info.list.length >= 2) continue;
    let bestK=null, bestD=Infinity, bestC=null;
    state.corridor.forEach(k=>{
      const [cx,cy]=k.split(',').map(Number);
      if(info.list.some(([x,y])=>x===cx&&y===cy)) return;
      const rx = (cx < r.x) ? r.x : (cx > r.x + r.w - 1 ? r.x + r.w - 1 : cx);
      const ry = (cy < r.y) ? r.y : (cy > r.y + r.h - 1 ? r.y + r.h - 1 : cy);
      const d = Math.abs(cx - rx) + Math.abs(cy - ry);
      if(d < bestD){ bestD=d; bestK=k; bestC={cx,cy,rx,ry}; }
    });
    if(bestK){
      const {cx,cy,rx,ry} = bestC;
      let tx = cx, ty = cy;
      while (tx !== rx) {
  if (state.tiles[ty][tx] === 0 || state.tiles[ty][tx] === 2) {
    state.tiles[ty][tx] = 1;
    state.corridor.add(key(tx,ty));
  }
  tx += Math.sign(rx - tx);
}
      while (ty !== ry) {
  if (state.tiles[ty][tx] === 0 || state.tiles[ty][tx] === 2) {
    state.tiles[ty][tx] = 1;
    state.corridor.add(key(tx,ty));
  }
  ty += Math.sign(ry - ty);
}

      if (state.tiles[ty][tx] === 0 || state.tiles[ty][tx] === 2) {
  state.tiles[ty][tx] = 1;
  state.corridor.add(key(tx,ty));
}

      info = thresholdsForRoom(r);
    }
  }

  for(const r of state.rooms){
    const info = thresholdsForRoom(r);
    if(info.list.length === 0) continue;
    if(info.open === 0){
      const [cx,cy] = info.list[0];
      if (state.tiles[cy][cx] === 0 || state.tiles[cy][cx] === 2) {
  state.tiles[cy][cx] = 1;
}

    }
  }

  state.seen.add(key(state.player.x,state.player.y));
}



function tierForDepth(floor){
  if (floor >= 41) return 5; // 41‚Äì50 ‚Üí Lv5
  if (floor >= 31) return 4; // 31‚Äì40 ‚Üí Lv4
  if (floor >= 21) return 3; // 21‚Äì30 ‚Üí Lv3
  if (floor >= 11) return 2; // 11‚Äì20 ‚Üí Lv2
  return 1;                  // 1‚Äì10  ‚Üí Lv1
}


function currentSpellTier(name){
  const s = state.spells?.find(sp => sp.name === name);
  return Math.max(1, s?.tier || 1);
}
function baseForTier(name, tier){
  const def = SPELL_BOOK[name];
  if (!def) return { baseMin:2, baseMax:4, baseRange:4, cost:2 };

  // MP cost still scales per tier (yours may use the constant if you added it)
  const tiersAbove = Math.max(0, (tier|0) - 1);
  const cost = Math.max(1, def.cost + tiersAbove * (typeof SPELL_COST_STEP_PER_TIER === 'number' ? SPELL_COST_STEP_PER_TIER : 1));

  // NEW: flat damage bump per tier
  const minTier = def.baseMin + tiersAbove * SPELL_DMG_STEP_PER_TIER_MIN;
  const maxTier = def.baseMax + tiersAbove * SPELL_DMG_STEP_PER_TIER_MAX;

  const bonus = getSpellBonusFor(name); // { dmg, range }

const skillBonus = magicPowerBonus(); // +1 dmg bonus for every 2 Magic levels (up to +6)

  return {
    baseMin: minTier + bonus.dmg + skillBonus, // <--- MODIFIED
        baseMax: maxTier + bonus.dmg + skillBonus, // <--- MODIFIED
        baseRange: def.baseRange + bonus.range,
        cost
  };
}





function randomWeapon(){
const pool=[
    {name:'Shortsword',min:3,max:5,type:'one'},
    {name:'Claymore',min:5,max:9,type:'two'},
    {name:'Spear',min:4,max:7,type:'spear'},
    {name:'Axe',min:4,max:8,type:'axe'},
    {name:'Knuckle Duster',min:3,max:5,type:'hand'},
    {name:'Key of Destiny',min:5,max:7,type:'one'},
    // New Melee
    {name:'Warhammer',min:6,max:10,type:'two'},
    {name:'Battleaxe',min:5,max:10,type:'axe'},
    {name:'Halberd',min:5,max:9,type:'spear'},
    {name:'Claws',min:4,max:6,type:'hand'},
    // Staffs
    {name:'Fire Staff',min:2,max:4,type:'staff'},
    {name:'Ice Staff',min:2,max:4,type:'staff'},
    {name:'Lightning Staff',min:2,max:4,type:'staff'},
    {name:'Wind Staff',min:2,max:4,type:'staff'},
    {name:'Earth Staff',min:2,max:4,type:'staff'},
    // Shields
    {name:'Buckler',min:1,max:2,type:'shield'},
    {name:'Kite Shield',min:2,max:3,type:'shield'},
    {name:'Tower Shield',min:3,max:4,type:'shield'},
    {name:'Ancient Shield',min:2,max:4,type:'shield'}
  ];
  let choice = { ...pool[rand(0,pool.length-1)] }; // Shallow copy to avoid modifying the template

  // --- NEW: Affix System (25% chance) ---
  // MODIFIED: Exclude Key of Destiny from getting random affixes
  if (choice.name !== 'Key of Destiny' && Math.random() < 0.25) {
    const roll = Math.random();
    
    // --- NEW: Cursed Weapons (5% chance within affix roll) ---
    if (roll < 0.05) { // Ultra Rare
      const cTypes = ['blood', 'greed', 'rust', 'frailty'];
      const type = cTypes[Math.floor(Math.random() * cTypes.length)];
      const niceType = type.charAt(0).toUpperCase() + type.slice(1); // Capitalize

      choice.name = 'Cursed ' + niceType + ' ' + choice.name; 
      
      // Scale bonus based on weapon type
      let bonus = 4; // Standard
      if (choice.type === 'two' || choice.type === 'axe') bonus = 6; // Heavy
      if (choice.type === 'staff' || choice.type === 'hand' || choice.type === 'shield') bonus = 3; // Light

      choice.min += bonus; 
      choice.max += (bonus + 1); 
      choice.cursed = true;
      choice.curseType = type;
      
      // Unlock specific curse in Codex
      const key = 'Curse_' + choice.curseType.charAt(0).toUpperCase() + choice.curseType.slice(1);
      unlockCodex(key, true);
    }
    // Standard Affixes
    else if (roll < 0.3) {
      choice.name = 'Sharp ' + choice.name;
      choice.min += 1; choice.max += 1;
      unlockCodex('Sharp'); // <--- Unlock
    } else if (roll < 0.6) {
      choice.name = 'Heavy ' + choice.name;
      choice.max += 3; 
      unlockCodex('Heavy'); // <--- Unlock
    } else if (roll < 0.8) {
      choice.name = 'Vampiric ' + choice.name;
      choice.vampiric = true; 
      unlockCodex('Vampiric'); // <--- Unlock
    } else {
      choice.name = 'Ancient ' + choice.name;
      choice.min += 2; choice.max += 2;
      unlockCodex('Ancient'); // <--- Unlock
    }
  }
  return choice;
}
function randomSpell(){
  const pool = [
    {name:'Spark',  cost:2},
    {name:'Ember',  cost:3},
    {name:'Frost',  cost:3},
    {name:'Gust',   cost:2},
    {name:'Pebble', cost:1},
    {name:'Heal',   cost:4}
  ];
  const base = pool[rand(0,pool.length-1)];
  const tier = tierForDepth(state.floor);
  return { ...base, tier };
}




// ====== Spell scaling (duplicate scroll upgrades) ======
const SPELL_BOOK = {
  // Buffed: Spark cost 2->1. Gust cost 2->1.
  Spark:  { cost:1, baseMin:2, baseMax:3, baseRange:2 },
  Ember:  { cost:3, baseMin:3, baseMax:5, baseRange:3 },
  Frost:  { cost:3, baseMin:2, baseMax:4, baseRange:3 },
  Gust:   { cost:1, baseMin:1, baseMax:3, baseRange:2 }, 
  Pebble: { cost:1, baseMin:1, baseMax:4, baseRange:3 },
  Heal:   { cost:4, baseMin:4, baseMax:6, baseRange:0 }
};

const MAX_SPELL_BONUS = 5; // cap for +dmg and +range
const SHARDS_PER_UPGRADE = 5; // how many duplicate shards to buy one upgrade


function isOffensiveSpell(name){
  return name !== 'Heal' && Object.prototype.hasOwnProperty.call(SPELL_BOOK, name);
}

function getSpellBonusFor(name){
  const up = (state.spellUpgrades && state.spellUpgrades[name]) || {};
  return {
    dmg:   Math.min(MAX_SPELL_BONUS, (up.dmg   | 0)),
    range: Math.min(MAX_SPELL_BONUS, (up.range | 0))
  };
}


function ensureSpellUpgradeSlot(name){
  if (!state.spellUpgrades[name]){
    state.spellUpgrades[name] = { dmg:0, range:0, shards:0 };
  }
  return state.spellUpgrades[name];
}



function getSpellStats(name){
  const t    = currentSpellTier(name);
  const base = baseForTier(name, t);

  const up   = (state.spellUpgrades && state.spellUpgrades[name]) || { dmg:0, range:0 };
  const dmgBonus = Math.min(MAX_SPELL_BONUS, up.dmg|0);
  const rngBonus = Math.min(MAX_SPELL_BONUS, up.range|0);

  // New: Heal uses percentage instead of flat values
  if (name === 'Heal'){
    const pct = Math.max(0, HEAL_PCT_BASE + (t - 1) * HEAL_PCT_PER_TIER);
    return {
      cost:  base.cost,   // still scales +1 MP per tier via baseForTier
      pct,                 // e.g., 0.20, 0.26, 0.32...
      range: 0
    };
  }

// Offensive spells: shards + Magic level both boost damage
const pow = magicPowerBonus();  // +1 power every 2 Magic levels
return {
  cost:  base.cost,
  min:   base.baseMin + dmgBonus + pow,
  max:   base.baseMax + dmgBonus + pow,
  range: base.baseRange + rngBonus
};
}



// ====== Spell upgrade modal wiring (duplicate scroll shards) ======
document.addEventListener('DOMContentLoaded', () => {
  const modal = document.getElementById('spellUpModal');
  const titleEl = document.getElementById('spellUpTitle');
  const msgEl   = document.getElementById('spellUpMsg');
  const btnDmg  = document.getElementById('btnSpellUpDmg');
  const btnRng  = document.getElementById('btnSpellUpRange');

  function openUpgrade(spellName){
  if (!modal) return false;
  ensureSpellUpgradeSlot(spellName);
  const up = state.spellUpgrades[spellName];
  if (!isOffensiveSpell(spellName)) return false;
  if ((up.shards|0) < SHARDS_PER_UPGRADE) return false;

  modal.dataset.spell = spellName;
  titleEl.textContent = `Upgrade ${spellName}`;
  msgEl.textContent   = `You have ${up.shards} shard${up.shards===1?'':'s'}. Spend ${SHARDS_PER_UPGRADE} for +1 Damage or +1 Range.`;
  setMobileControlsVisible(false);            // ‚Üê add this
  modal.style.display = 'flex';
  return true;
}

function spend(kind){
  const spellName = modal.dataset.spell;
  if (!spellName) { modal.style.display='none'; setMobileControlsVisible(true); return; }

  const up = ensureSpellUpgradeSlot(spellName);
  if ((up.shards|0) < SHARDS_PER_UPGRADE) { modal.style.display='none'; setMobileControlsVisible(true); return; }

  // ... your existing upgrade logic ...

  // close if we can't chain another upgrade
  if (!openUpgrade(spellName)) { modal.style.display = 'none'; setMobileControlsVisible(true); }


    up.shards -= SHARDS_PER_UPGRADE;
    if (kind === 'dmg') {
      up.dmg = Math.min(MAX_SPELL_BONUS, (up.dmg|0) + 1);
      log(`${spellName} upgraded: +1 Damage (now +${up.dmg}).`);
    } else {
      up.range = Math.min(MAX_SPELL_BONUS, (up.range|0) + 1);
      log(`${spellName} upgraded: +1 Range (now +${up.range}).`);
    }

    updateSpellBody();

    // If they still have enough shards for another upgrade, keep the modal open
    if (!openUpgrade(spellName)) { modal.style.display = 'none'; setMobileControlsVisible(true); }
}

  if (btnDmg) btnDmg.onclick = () => spend('dmg');
  if (btnRng) btnRng.onclick = () => spend('range');

  // expose a hook your loot code can call
  window.__maybePromptSpellUpgrade = (name) => openUpgrade(name);
  if (modal) modal.style.display = 'none';

});




// ====== Combat & XP ======


// Chance to award gold on kill
const GOLD_DROP_CHANCE = 0.50;


// --- Gold reward helper ---
function goldFor(enemy){
  const table = {
    Rat:[1,3], Slime:[1,2],
    Goblin:[2,5], Skeleton:[3,6], Mage:[3,6]
  };
  const [lo, hi]   = table[enemy.type] || [1,3];
  const depthBonus = Math.floor((state.floor|0)/3);

  const base = rand(lo + depthBonus, hi + depthBonus);
  if (state.gameMode !== 'classic' && state.floorEffect === 'Bloodhunt'){
    return Math.max(1, Math.round(base * 1.35));
  }
  return base;
}



// ---- Survivability damage reduction: +5% DR every 5 levels (5,10,15,...)
function damageAfterDR(raw){
  let dr = 0;
  const sv = state.skills?.survivability;
  if (sv){ dr += Math.min(0.05 * (sv.lvl||0), 0.50); }

  let usedShield = false;
  const sh = state.player?.shield;
  if (sh && sh.dur > 0){ 
      // Use specific block chance (Buckler 15%, Tower 35%, etc)
      const chance = state.player.blockChance || 0.20; 
      if (Math.random() < chance) {
          dr += SHIELD_DR; 
          usedShield = true;
          log(`Blocked with ${state.player.shieldName}!`);
      }
  }

  // Cleric Blessing: +20% Damage Reduction
  if (state.player.blessTicks > 0) { dr += 0.20; }

dr = Math.min(dr, 0.80);                 // cap total DR at 80%
  let dmg = Math.ceil(raw * (1 - dr));

  // Frailty Curse: You take +2 damage from everything
  if (state.player.weapon?.curseType === 'frailty' && dmg > 0) {
    dmg += 2;
  }

  if (usedShield && dmg > 0){              // only when it actually reduced real damage           // only when it actually reduced real damage
  state._shieldParity = (state._shieldParity + 1);
  if (state._shieldParity % 2 === 0){    // every other hit taken
    sh.dur = Math.max(0, (sh.dur|0) - 1);
    if (sh.dur <= 0){
      state.player.shield = null;
      log('Your shield shatters!');
    }
    updateEquipUI?.();
  }
}

  return dmg;
}




function baseAccuracy(type){
  return ({hand:0.9, one:0.85, spear:0.8, axe:0.75, two:0.7}[type] ?? 0.90);
}
function accuracyBonusFromSkill(type){
  const s = state.skills[type];
  if (!s) return 0;
  const extra = Math.max(0, (s.lvl || 1) - 1);
  const base = 0.02 * extra;                   // all melee skills
  const bowBonus = (type === 'bow') ? 0.01*extra : 0; // +1%/level more for Bow
  return base + bowBonus;
}
// +5% success per level after 1 (L2=+5%, L3=+10%, ...)
function lockpickBonusFromSkill(){
  const L = (state.skills?.lockpicking?.lvl || 1);
  return 0.05 * Math.max(0, L - 1);
}


function rollHitFor(type){
  if (type === 'magic'){
    // Magic accuracy: every 2 Magic levels improves hit chance
    const tiers = magicPowerBonus();   // 0,1,2,... based on Magic lvl
    const base  = 0.75;
    const bonus = tiers * 0.02;       // +2% per 2 Magic levels
    const p = Math.max(0.05, Math.min(0.99, base + bonus));
    return Math.random() < p;
  }

  // Weapons: use baseAccuracy + skill bonus, clamped so we never hit 100%
  const raw = baseAccuracy(type) + accuracyBonusFromSkill(type);
  const p   = Math.max(0.05, Math.min(0.99, raw));
  return Math.random() < p;
}

// ======== Weapon Quirk Tunables & Helpers ========
const QUIRK_CAP = 0.40;       // hard cap 40%
const BLEED_TICKS = 5;        // spear
const BLEED_DMG   = 1;
const SLOW_TICKS  = 3;        // axe
const STUN_TICKS  = 3;        // hand-to-hand

// 2% per skill level (beyond 1), capped (feel free to tweak the 0.02)
function quirkChance(type){
  const lvl = (state.skills?.[type]?.lvl || 1);
  const extra = Math.max(0, lvl - 1);
  return Math.min(QUIRK_CAP, 0.02 * extra);
}
const proc = (p)=> Math.random() < p;

// enemy status applicators
function applyBleed(e, ticks=BLEED_TICKS, perTick=BLEED_DMG){
  e.bleedTicks = Math.max(e.bleedTicks|0, 0) + ticks;
  e.bleedDmg   = perTick;
}
function applySlow(e, ticks=SLOW_TICKS){
  e.slowTicks = Math.max(e.slowTicks|0, 0) + ticks;
  e._skipMove = false; // used for every-other-turn slow
}
function applyStun(e, ticks=STUN_TICKS){
  e.stunTicks = Math.max(e.stunTicks|0, 0) + ticks;
}




// === Magic power scaling (caps the bonus) ===
function magicPowerBonus(){
  const ml = (state.skills?.magic?.lvl || 1);
  // +1 power every 2 Magic levels starting at lvl 3: 3,5,7,9...
  // Cap the total bonus so early spells don‚Äôt overtake late-game spells
  return Math.min(6, Math.max(0, Math.floor((ml - 1) / 2)));
}

// XP gain when you pick up an extra copy of a spell scroll
const MAGIC_SCROLL_XP = 4;

function ensureSkill(type){
  if(!state.skills[type]) state.skills[type]={lvl:1,xp:0,next:SKILL_XP_START,shown:false}
}

function skillDamageBonus(type){
  const s=state.skills[type];
  if(!s) return 0;
  return Math.floor((s.lvl-1)/2);
}
function recomputeWeapon(){
  const w = state.player.weapon;
  if (!w || !w.base) return;

  // --- FIX: Staffs do not benefit from generic physical ATK omens ---
  let flat = state.globalWeaponFlatBonus || 0;
  if (w.type === 'staff') flat = 0; 
  // ----------------------------------------------------------------

  const bonus = skillDamageBonus(w.type) + flat;

  w.min = w.base.min + bonus;
  w.max = w.base.max + bonus;
}

function awardKill(type,amount){
  incrementMetaStat('kills_' + type); // <--- NEW: Track kills by weapon type (kills_axe, kills_magic)

  if (state.gameMode !== 'classic' && state.floorEffect === 'Bloodhunt'){
    amount = Math.max(1, Math.round(amount * 1.35));
  }

  state.player.xp += amount;
  let leveled=false;
  while(state.player.xp>=state.player.next){
    state.player.xp-=state.player.next;
    state.player.level++;
    state.player.next = Math.floor(state.player.next * PLAYER_XP_GROWTH);
    leveled=true;
  }


  // Tutorial: after your first kill, move to the spell-menu step
  if (state.gameMode === 'tutorial' && state.tutorialStep === 3) {
    state.tutorialStep = 4;
    say("Nice! You killed a rat. Now press P to open your spell menu.");
  }

  if (leveled){
    SFX.levelUp();
    // HARD-LOCK player input until a choice is made
    state._inputLocked = true;

  // Optional: hide on-screen mobile controls while locked
  if (typeof setMobileControlsVisible === 'function') setMobileControlsVisible(false);

  // Show the choice modal
  document.getElementById('lvlupModal').style.display = 'flex';
}


  ensureSkill(type);
  const s=state.skills[type];
  s.xp+=amount;
  if(!s.shown){ s.shown=true; }
  let up=false;
  while(s.xp>=s.next){ s.xp-=s.next; s.lvl++; s.next = Math.floor(s.next * SKILL_XP_GROWTH); up=true; }
  if(up){ log(typeNice(type)+' advanced to '+s.lvl+'.'); }

  // NEW: Survivability also gains XP from kills
  ensureSkill('survivability');
  const sv = state.skills['survivability'];
  sv.xp += amount;
  if(!sv.shown){ sv.shown = true; }
  let upS = false;
  while(sv.xp >= sv.next){
    sv.xp -= sv.next;
    sv.lvl++;
    sv.next = Math.floor(sv.next * SKILL_XP_GROWTH);
    upS = true;
  }
  if (upS){ log('Survivability advanced to ' + sv.lvl + '.'); }

  if(state.player.weapon.type===type){
    recomputeWeapon();
  }
  updateEquipUI();
  renderSkills();
}

function typeNice(type){
  return ({
    hand:'Hand to Hand',
    one:'One-Handed',
    two:'Two-Handed',
    spear:'Polearm', // Changed display name
    axe:'Hafted',
    bow:'Archery',
    lockpicking:'Lockpicking',
    magic:'Magic',
    survivability:'Survivability'
  })[type] || type;
}


// ====== Rendering ======
const canvas=document.getElementById('view');
const ctx=canvas.getContext('2d');
function setupCanvas(){
  const dpr=window.devicePixelRatio||1;
  const wrap=document.getElementById('cw');
  const w=wrap.clientWidth, h=wrap.clientHeight;
  canvas.width=w*dpr; canvas.height=h*dpr; canvas.style.width=w+'px'; canvas.style.height=h+'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.imageSmoothingEnabled=false;
}
window.addEventListener('resize',setupCanvas,{passive:true});

// Centers an N√óN pixel grid inside a tile.
// Returns { s, bx, by, R } where R(cx,cy,w,h,color) draws a rect in grid units.
function gridN(ctx, x, y, tile, N){
  const s   = Math.max(1, Math.floor(tile / N));
  const off = Math.floor((tile - s * N) / 2);
  const bx  = x + off, by = y + off;
  const R   = (cx,cy,w,h,c)=>{ ctx.fillStyle=c; ctx.fillRect(bx + cx*s, by + cy*s, w*s, h*s); };
  return { s, bx, by, R };
}



// 12√ó12 grid helper
function _R12(ctx, px, py, s, cx, cy, w, h, color){
  ctx.fillStyle = color;
  ctx.fillRect(px + cx*s, py + cy*s, w*s, h*s);
}

// === Simple projectile helpers (magic bolts + arrows) ===
function projectileColorForMagic(name){
  switch(name){
    case 'Spark':  return '#ffd93b'; // bright yellow
    case 'Ember':  return '#ff7f50'; // orange / fire
    case 'Frost':  return '#6ec5ff'; // icy blue
    case 'Gust':   return '#f5f5f5'; // pale wind
    case 'Pebble': return '#b8b2a0'; // stone
    default:       return '#ffffff';
  }
}


// --- OPTIMIZED: Float Text with Hard Cap ---
const MAX_FLOAT_TEXT = 8; // Limit overlapping numbers

function spawnFloatText(text, x, y, color='#fff') {
  if(!state.floatingText) state.floatingText = [];
  
  state.floatingText.push({
    text: String(text),
    x: x, 
    y: y, 
    start: Date.now(),      
    duration: 1200,         // Reduced duration (was 2000ms) to clear buffer faster
    color: color
  });

  // Culling: If too many numbers, remove the oldest
  if (state.floatingText.length > MAX_FLOAT_TEXT) {
    state.floatingText.shift(); 
  }

  if (!state._animating) { state._animating = true; requestAnimationFrame(draw); }
}

// --- OPTIMIZED: Particle Spawner with Hard Cap ---
const MAX_PARTICLES = 30; // Hard limit on total particles

function spawnParticles(x, y, color, count=4) {
  if(!state.particles) state.particles = [];
  
  // 1. Reduced count for low-end safety (default was 5-6)
  const safeCount = Math.min(count, 4); 
  
  for(let i=0; i<safeCount; i++){
    state.particles.push({
      x: x, 
      y: y,
      vx: (Math.random() - 0.5) * 0.15, 
      vy: (Math.random() - 0.5) * 0.15, 
      life: rand(40, 70), // Slightly shorter life
      color: color,
      size: rand(2, 3)
    });
  }

  // 2. FIFO Culling: If we have too many, remove the oldest ones immediately
  if (state.particles.length > MAX_PARTICLES) {
    // Remove the excess from the beginning of the array
    state.particles.splice(0, state.particles.length - MAX_PARTICLES);
  }

  if (!state._animating) { state._animating = true; requestAnimationFrame(draw); }
}

// draws one projectile in a tile-sized slot (screenX,screenY are in pixels)
function drawProjectilePixel(ctx, proj, screenX, screenY, tile){
  const { R } = gridN(ctx, screenX, screenY, tile, 12);
  const c = proj.color || '#ffffff';

  if (proj.kind === 'arrow'){
    // very simple arrow, oriented by dx/dy
    if (Math.abs(proj.dx) === 1){
      // horizontal arrow
      R(1,5,10,2,c);                 // shaft
      if (proj.dx > 0){
        R(10,4,2,4,c);               // head ‚Üí
      } else {
        R(0,4,2,4,c);                // head ‚Üê
      }
    } else {
      // vertical arrow
      R(5,1,2,10,c);
      if (proj.dy > 0){
        R(4,10,4,2,c);               // head ‚Üì
      } else {
        R(4,0,4,2,c);                // head ‚Üë
      }
    }
  } else {
    // magic bolt: little diamond
    R(5,3,2,2,c);
    R(4,5,4,2,c);
    R(5,7,2,2,c);
  }
}

// Spawns a projectile that moves from (fromX,fromY) to (toX,toY)
// and then runs onDone(). If the enemy is right next to the player,
// we just resolve immediately with NO animation.
function spawnProjectileEffect(opts){
  const fromX = opts.fromX, fromY = opts.fromY;
  const toX   = opts.toX,   toY   = opts.toY;
  const dx    = (opts.dx !== undefined ? opts.dx : Math.sign(toX - fromX));
  const dy    = (opts.dy !== undefined ? opts.dy : Math.sign(toY - fromY));

  const tiles = Math.max(Math.abs(toX - fromX), Math.abs(toY - fromY));

  // "Right up next to the player" -> 1 tile away or same tile: no animation
  if (!Number.isFinite(tiles) || tiles <= 1){
    if (typeof opts.onDone === 'function') opts.onDone();
    return;
  }

  const kind  = opts.kind || 'magic';
  const color = opts.color ||
    (kind === 'magic' ? projectileColorForMagic(opts.element) : '#f7e9c5');

  const proj = {
    kind,
    element: opts.element || null,
    color,
    fromX, fromY,
    toX, toY,
    dx, dy,
    t: 0,
    // a bit slower for farther shots
    duration: 120 + tiles * 40,
    startTime: performance.now(),
    onDone: opts.onDone || null
  };

  if (!Array.isArray(state.projectiles)) state.projectiles = [];
  state.projectiles.push(proj);
  state._projectileAnimating = true;

  const wasLocked = !!state._inputLocked;
  state._inputLocked = true;

  function step(now){
    if (!state._projectileAnimating) return;
    const elapsed = now - proj.startTime;
    proj.t = Math.min(1, elapsed / proj.duration);

    // redraw with updated projectile position
    draw();

    if (proj.t >= 1){
      // reach target ‚Üí clean up
      state.projectiles = state.projectiles.filter(p => p !== proj);
      state._projectileAnimating = false;

      // let enemies take their turn, then unlock input
      if (typeof proj.onDone === 'function') proj.onDone();
      state._inputLocked = wasLocked;
      draw();
    } else {
      requestAnimationFrame(step);
    }
  }

  requestAnimationFrame(step);
}


// Updated drawPlayerHelmet (original lines ~4211‚Äì4244) ‚Äì added outline pixels and extra shading for clarity
function drawPlayerHelmet(ctx, x, y, tile, facing='down') {
  const { s, R } = gridN(ctx, x, y, tile, 12);
  const steel = '#a7b3c1', dark = '#0b141d', plume = '#9d1d2b', shine = '#dfe6ee';

  // plume (with outline)
  R(5,0,2,1,plume);
  R(4,0,1,1,dark); R(7,0,1,1,dark);  // add dark pixels at plume edges

  // dome (enhanced with outline)
  R(2,1,8,1,steel);
  R(1,2,10,1,steel);
  R(1,3,10,1,steel);
  R(2,4,8,1,steel);
  R(3,5,6,1,steel);
  // outline around helmet dome silhouette
  R(1,1,1,1,dark); R(10,1,1,1,dark);
  R(0,2,1,1,dark); R(11,2,1,1,dark);
  R(0,3,1,1,dark); R(11,3,1,1,dark);
  R(1,4,1,1,dark); R(10,4,1,1,dark);
  R(2,5,1,1,dark); R(9,5,1,1,dark);

  // cheek plates (with outline)
  R(1,7,3,3,steel);
  R(8,7,3,3,steel);
  // border around cheek pieces
  R(0,7,1,1,dark); R(4,7,1,1,dark); R(7,7,1,1,dark); R(11,7,1,1,dark);
  R(0,8,1,1,dark); R(4,8,1,1,dark); R(7,8,1,1,dark); R(11,8,1,1,dark);
  R(0,9,1,1,dark); R(4,9,1,1,dark); R(7,9,1,1,dark); R(11,9,1,1,dark);

  // highlights
  R(3,2,2,1,shine);
  R(4,3,2,1,shine);

  // visor by facing (same dark color as outline)
  if (facing==='up') {
    R(3,4,6,1,dark); R(4,3,4,1,dark);
  } else if (facing==='left') {
    R(1,6,7,1,dark); R(1,5,2,1,dark);
  } else if (facing==='right') {
    R(4,6,7,1,dark); R(9,5,2,1,dark);
  } else { // down
    R(3,7,6,1,dark);
  }
}

// Updated drawChestPixel (original lines ~4247‚Äì4278) ‚Äì added a dark frame outline for clarity
function drawChestPixel(ctx, x, y, tile){
  const { s, R } = gridN(ctx, x, y, tile, 12);
  const woodD = '#5a381f', woodM = '#7a4a26', woodL = '#b87946';
  const metal = '#c9b26a', lockC = '#0b141d', shade = '#2a1a10';
  const dark = '#0b141d';

  // frame outline (dark border around chest edges)
  R(0,3,1,8,dark);   // left edge
  R(11,3,1,8,dark);  // right edge
  R(0,10,12,1,dark); // bottom edge

  // chest body fills most of tile
  R(1,3,10,8,woodM);

  // lid and top edge highlight
  R(1,3,10,1,woodD); // top edge (wood dark)
  R(1,4,10,1,woodL); // band of lighter wood below

  // vertical board seams
  R(3,3,1,8,woodD);
  R(8,3,1,8,woodD);

  // metal band
  R(1,7,10,1,metal);

  // bottom shadow line so it sits on ground
  R(1,10,10,1,shade);

  // lock plate and keyhole
  R(5,5,2,3,metal);
  R(6,6,1,1,lockC);
}

// --- NEW: Draw Scenery Props ---
function drawPropPixel(ctx, type, px, py, tile){
  const { R } = gridN(ctx, px, py, tile, 12);
  
  if (type === 'crate') {
    const wood = '#8b5a2b', dark = '#5c3a1e', nail = '#d7b46a';
    R(1,2,10,9,wood);           // body
    R(1,2,10,1,dark); R(1,10,10,1,dark); // top/bottom rim
    R(1,2,1,9,dark);  R(10,2,1,9,dark);  // side rims
    R(2,3,8,7,wood);            // inner
    R(2,3,1,1,nail); R(9,3,1,1,nail); // nails
    R(2,9,1,1,nail); R(9,9,1,1,nail);
    // diagonal brace
    R(3,4,1,1,dark); R(4,5,1,1,dark); R(5,6,2,1,dark); R(7,7,1,1,dark); R(8,8,1,1,dark);
  } 
  else if (type === 'barrel') {
    const wood = '#a0522d', hoop = '#111827', top = '#6d3c1d';
    R(2,3,8,8,wood);            // body
    R(2,3,8,1,top);             // top lid
    R(2,4,8,1,hoop);            // top hoop
    R(2,9,8,1,hoop);            // bottom hoop
    R(1,4,1,6,wood); R(10,4,1,6,wood); // bulge sides
  }
  else if (type === 'bones') {
    const bone = '#e5e7eb', shadow = '#374151';
    // skull
    R(2,8,3,2,bone); R(2,9,1,1,shadow); R(4,9,1,1,shadow);
    // rib
    R(6,9,4,1,bone); R(7,8,1,2,bone);
  }
else if (type === 'rubble') {
    const stone = '#6b7280', dust = '#9ca3af';
    R(2,9,2,2,stone); R(5,10,1,1,dust); 
    R(8,8,2,2,stone); R(9,7,1,1,dust);
    R(4,5,1,1,dust);
  }
  // --- NEW: Pillar Visual ---
else if (type === 'pillar') {
    const marble = '#d1d5db', shadow = '#9ca3af', dark = '#4b5563';
    // Tall vertical column
    R(2,1,8,10,marble); R(3,1,1,10,shadow); R(9,1,1,10,shadow);
    R(1,0,10,2,dark); R(1,10,10,2,dark);
  }
  // --- BIOME SPECIFIC PROPS ---
  else if (['coffin','broken_tomb'].includes(type)) { // Crypt
    R(3,2,6,8,'#4b5563'); R(4,3,4,6,'#1f2937'); // Stone box
    if(type==='broken_tomb') R(3,5,6,1,'#000'); // Crack
  }
  else if (['urn','gold_vase'].includes(type)) { // Crypt/Gilded
    const c = type==='gold_vase' ? '#fbbf24' : '#b45309';
    R(4,7,4,4,c); R(3,5,6,2,c); R(4,4,4,1,c); // Pot shape
  }
  else if (['magma_rock','obsidian_shard'].includes(type)) { // Magma
    R(2,8,8,3,'#1f2937'); R(3,7,2,2,'#1f2937');
    if(type==='magma_rock') { R(4,9,1,1,'#ef4444'); R(7,9,1,1,'#f97316'); } // Glow
  }
  else if (['fern','vine_cluster'].includes(type)) { // Jungle
    R(5,9,2,2,'#166534'); // Base
    R(2,6,3,3,'#22c55e'); R(7,6,3,3,'#22c55e'); R(5,3,2,4,'#22c55e'); // Leaves
  }
else if (['crystal_shard','floating_rock'].includes(type)) { // Void
    const c = type==='crystal_shard' ? '#a855f7' : '#4b5563';
    R(5,4,2,6,c); R(4,6,1,2,c); R(7,6,1,2,c); // Spikey/Floaty
  }
  // --- NEW: Extended Prop Visuals ---
  else if (type === 'rat_nest') { 
    R(2,9,8,3,'#5c4033'); R(3,8,6,1,'#4a3728'); R(4,9,1,1,'#000'); // Messy pile
  }
  else if (type === 'broken_grate') {
    R(2,2,8,8,'#374151'); R(3,3,6,6,'#111827'); // Frame + Hole
    R(4,2,1,8,'#4b5563'); R(7,2,1,8,'#4b5563'); // Bars
  }
  else if (type === 'toxic_barrel') {
    R(2,3,8,8,'#166534'); R(2,4,8,1,'#000'); R(2,9,8,1,'#000'); // Green barrel
    R(5,5,2,2,'#a3e635'); // Ooze leak
  }
  else if (type === 'gargoyle') {
    R(4,6,4,4,'#6b7280'); // Body
    R(2,4,2,4,'#4b5563'); R(8,4,2,4,'#4b5563'); // Wings
    R(5,5,1,1,'#ef4444'); R(6,5,1,1,'#ef4444'); // Eyes
  }
  else if (type === 'spider_web') {
    ctx.globalAlpha = 0.4;
    R(0,0,4,4,'#e5e7eb'); R(8,0,4,4,'#e5e7eb'); // Corners
    ctx.globalAlpha = 1.0;
  }
  else if (type === 'skull_pile') {
    R(4,9,4,3,'#e5e7eb'); R(2,10,3,2,'#d1d5db'); R(7,10,3,2,'#d1d5db'); // Pile
    R(5,10,1,1,'#000'); R(7,10,1,1,'#000'); // Eyes
  }
  else if (type === 'lava_vent') {
    R(2,8,8,4,'#451a03'); // Mound
    R(4,8,4,2,'#ef4444'); // Magma top
    R(5,7,2,3,'#f97316'); // Plume
  }
  else if (type === 'iron_chain') {
    R(5,0,2,12,'#9ca3af'); // Vertical chain
  }
  else if (type === 'giant_flower') {
    R(5,8,2,4,'#166534'); // Stalk
    R(2,4,8,4,'#db2777'); // Petals
    R(5,5,2,2,'#fdf4ff'); // Center
  }
  else if (type === 'stone_idol') {
    R(3,2,6,10,'#78716c'); // Head
    R(4,4,1,1,'#000'); R(7,4,1,1,'#000'); // Eyes
    R(4,8,4,1,'#000'); // Mouth
  }
  else if (type === 'star_mote') {
    R(5,5,2,2,'#f0abfc'); // Core
    ctx.shadowColor = '#e879f9'; ctx.shadowBlur = 10;
    R(6,2,1,8,'#fae8ff'); R(2,6,8,1,'#fae8ff'); // Rays
    ctx.shadowBlur = 0;
  }
  else if (type === 'dark_monolith') {
    R(4,1,4,11,'#000'); // Black pillar
    R(5,3,2,6,'#4c1d95'); // Rune glow
  }
  else if (type === 'treasure_pile') {
    R(2,9,8,3,'#eab308'); // Gold base
    R(3,8,6,2,'#facc15'); // Mid
    R(4,7,4,2,'#fef08a'); // Top
    R(3,9,1,1,'#fff'); R(8,10,1,1,'#fff'); // Sparkles
  }
  else if (type === 'red_carpet') {
    R(2,0,8,12,'#991b1b'); // Red strip
    R(1,0,1,12,'#facc15'); R(10,0,1,12,'#facc15'); // Gold trim
  }
  else {
    // Default fallback (Rubbish pile)
    R(3,9,6,2,'#4b5563'); R(4,8,4,1,'#6b7280');
  }
}

function drawShadowPixel(ctx, x, y, tile){
  const { s, R } = gridN(ctx, x, y, tile, 12);
  const dark='#0b141d', deep='#060a10';
  // oval silhouette
  R(3,2,6,2,dark);
  R(2,4,8,6,dark);
  R(3,10,6,1,deep);
}
function drawHeartlessPixel(ctx, x, y, tile){
  const { s, R } = gridN(ctx, x, y, tile, 12);
  const body = '#0f172a'; // Ink black
  const eye  = '#facc15'; // Glowing yellow

  // Twitchy antenna animation (shifts based on time)
  const twitch = Math.floor(Date.now() / 200) % 2; 

  // Antennae
  if (twitch === 0) {
    R(4,1, 1,3, body); R(7,2, 1,2, body);
  } else {
    R(5,2, 1,2, body); R(8,1, 1,3, body);
  }

  // Round head + small body
  R(3,4, 6,5, body); // Head
  R(4,9, 4,2, body); // Body/Feet base

  // GLOWING YELLOW EYES
  R(4,5, 1,1, eye); 
  R(7,5, 1,1, eye);
}
function drawHoodedPixel(ctx, x, y, tile){
  const { s, R } = gridN(ctx, x, y, tile, 12);
  // palette
  const hood='#0d1118', inner='#06090e', trim='#334257', pin='#b7c6e1';
  const robe='#131c28', fold='#101a25', arm='#101723', hands='#cbbba0';

  // shadowed hood silhouette + inner darkness
  R(2,0,8,3,hood);             // crown of hood
  R(3,1,6,1,inner);            // deep shadow inside hood

  // hood trim + brooch pin
  R(2,3,8,1,trim);
  R(5,4,2,1,pin);

  // shoulders / arms (clearer outline)
  R(1,4,2,2,arm);              // left shoulder block
  R(9,4,2,2,arm);              // right shoulder block

  // robe body with 2 fold bands for depth
  R(2,5,8,6,robe);
  R(3,7,6,1,fold);
  R(3,9,6,1,fold);

  // tiny hands peeking (helps readability)
  R(3,10,1,1,hands);
  R(8,10,1,1,hands);
}





/* ================= MIMIC (chest look, subtle tells) ================= */
function drawMimicPixel(ctx, x, y, tile){
  const { s, R } = gridN(ctx, x, y, tile, 12);

  // base chest colors (same family as chest)
  const woodD = '#53341e';
  const woodM = '#734425';
  const woodL = '#c58753';
  const metal = '#d4be74';
  const shadow= '#22150d';

  // body (same silhouette)
  R(1,3,10,8,woodM);
  R(1,3,10,1,woodD);   // top edge
  R(1,4,10,1,woodL);   // highlight
  R(3,3,1,8,woodD);    // boards
  R(8,3,1,8,woodD);
  R(1,7,10,1,metal);   // band
  R(1,10,10,1,shadow); // sit shadow

  // ‚Äútells‚Äù: off-center lock + tiny teeth + peeking tongue
  const lockC = '#0b141d';
  R(6,5,2,3,metal);     // lock plate shifted right a bit
  R(7,6,1,1,lockC);

  // little teeth (white nubs) under the band
  const tooth = '#e9e9e9';
  R(4,8,1,1,tooth);
  R(7,8,1,1,tooth);

  // tongue (just a hint)
  const tongue = '#b54646';
  R(5,9,2,1,tongue);
}

function drawBatPixel(ctx, x, y, tile){
  const { s, R } = gridN(ctx, x, y, tile, 12);
  const dark = '#0b141d', body = '#4b3d44', wing = '#2a2328', eye = '#ef4444';

  // Wings: Wider M-shape silhouette
  // Left Wing
  R(1,3,1,2,wing); // tip
  R(2,2,1,4,wing); // arch
  R(3,3,1,3,wing); // mid
  R(4,4,1,2,wing); // connector

  // Right Wing
  R(10,3,1,2,wing); // tip
  R(9,2,1,4,wing);  // arch
  R(8,3,1,3,wing);  // mid
  R(7,4,1,2,wing);  // connector

  // Body
  R(5,4,2,4,body);

  // Ears (Tall and pointy)
  R(4,2,1,2,body); R(7,2,1,2,body);

  // Eyes (Glowing Red)
  R(5,5,1,1,eye); R(6,5,1,1,eye);
  
  // Feet
  R(5,8,1,1,dark); R(6,8,1,1,dark);
}

function drawSpiderPixel(ctx, x, y, tile){
  // Arachnophobia Mode Override
  if (window._arachnophobiaMode) {
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(x, y, tile, tile);
    
    ctx.fillStyle = '#000000';
    ctx.font = 'bold ' + Math.floor(tile/3.5) + 'px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('SPIDER', x + tile/2, y + tile/2);
    return;
  }

  const { s, R } = gridN(ctx, x, y, tile, 12);
  const dark = '#0b141d', body = '#27272a', leg = '#3f3f46', eye = '#ef4444', mark = '#ef4444';

  // Legs (8 total, 4 per side)
  // Left legs
  R(1,3,1,1,leg); R(2,4,1,1,leg); R(3,5,1,1,leg);
  R(0,6,2,1,leg); R(2,6,1,1,leg);
  R(0,8,2,1,leg); R(2,7,1,1,leg);
  R(1,10,1,1,leg); R(2,9,1,1,leg); R(3,8,1,1,leg);

  // Right legs (mirror)
  R(10,3,1,1,leg); R(9,4,1,1,leg); R(8,5,1,1,leg);
  R(10,6,2,1,leg); R(9,6,1,1,leg);
  R(10,8,2,1,leg); R(9,7,1,1,leg);
  R(10,10,1,1,leg); R(9,9,1,1,leg); R(8,8,1,1,leg);

  // Abdomen (rear)
  R(4,6,4,4,body);
  // Red hourglass/mark
  R(5,7,2,2,mark);

  // Cephalothorax (head)
  R(5,4,2,2,body);
  
  // Eyes
  R(5,4,1,1,eye); R(6,4,1,1,eye);
}

// Updated drawRatPixel (original lines ~4358‚Äì4370) ‚Äì added outline pixels for body and tail
function drawRatPixel(ctx, x, y, tile){
  const { s, R } = gridN(ctx, x, y, tile, 12);
  const fur = '#6b5444', shade = '#4b382c', ear = '#e7b4b4', nose = '#cc6b6b', eye = '#0b141d', tail = '#c99586';
  const dark = '#0b141d';

  // body (brown fur) and outline on edges
  R(2,7,9,3,fur); R(9,7,2,3,shade);
  R(0,7,1,1,dark); R(11,7,1,1,dark);

  // head and ear
  R(1,6,1,1,ear);
  R(1,7,2,2,fur);
  R(0,6,1,1,dark); R(2,6,1,1,dark); // outline around ear
  R(0,7,1,1,dark); // left side outline at head

  // face (eye and nose) with outline
  R(2,7,1,1,eye); R(1,8,1,1,nose);
  R(0,8,1,1,dark); R(11,8,1,1,dark);
  R(1,9,1,1,dark); R(11,9,1,1,dark);

  // tail (extends to right edge) with corner outlines
  R(10,7,1,1,tail); R(10,8,1,1,tail);
  R(9,9,1,1,tail); R(8,10,2,1,tail);
  R(7,10,1,1,dark); R(10,10,1,1,dark);
}

// Updated drawGoblinPixel (original lines ~4373‚Äì4388) ‚Äì added outline pixels for head/ears
function drawGoblinPixel(ctx, x, y, tile){
  const { s, R } = gridN(ctx, x, y, tile, 12);
  const skin = '#2f7e37', shade = '#205a26', eye = '#e8f0ff', pupil = '#0b141d', tooth = '#f4f4f4';
  const dark = '#0b141d';

  // big head (green) with black outline
  R(2,2,8,8,skin);
  R(1,2,1,1,dark); R(10,2,1,1,dark); // outline left/top & right/top
  R(1,3,1,1,dark); R(10,3,1,1,dark);
  R(1,4,1,1,dark); R(10,4,1,1,dark);

  // ears (same green color) and outline to border
  R(1,5,1,3,skin); R(10,5,1,3,skin);
  R(0,5,1,1,dark); R(11,5,1,1,dark); // outline at ear top
  R(0,6,1,1,dark); R(11,6,1,1,dark); // outline at ear middle
  R(0,7,1,1,dark); R(11,7,1,1,dark); // outline at ear bottom

  // brow/jaw shadow stripe
  R(2,2,8,1,shade); R(2,9,8,1,shade);

  // eyes and pupils
  R(3,6,2,1,eye); R(7,6,2,1,eye);
  R(4,6,1,1,pupil); R(8,6,1,1,pupil);

  // tooth (white)
  R(6,10,1,1,tooth);
}

function drawSlimePixel(ctx, x, y, tile){
  const { s, R } = gridN(ctx, x, y, tile, 12);
  const body='#3fcf7a', body2='#2ea664', shine='#9ff3c9', dark='#0b141d';

  // big blob touching sides
  R(1,8,10,3,body);
  R(2,5,8,3,body);
  R(1,10,10,1,body2);

  // face
  R(4,8,1,1,dark); R(7,8,1,1,dark);
  R(5,9,2,1,dark);

  // gloss
  R(3,6,3,1,shine); R(4,7,2,1,shine);
}

function drawMadKingPixel(ctx, x, y, tile){
  const { s, R } = gridN(ctx, x, y, tile, 12);
  // palette
  const gold='#e0c14f', gem='#64d2ff', ruby='#ff6b6b';
  const steel='#a7b1c4', plate='#8a96ab';
  const face='#ecd9bf', eye='#0b141d', hair='#b88d3a', beard='#a67c2e';
  const fur='#cfc8b6', cape='#5c0a16', capeDeep='#3d080f', shade='#0b141d';

  // crown with 3 points + gems
  R(2,0,8,1,gold); R(4,-1,1,1,gold); R(6,-1,1,1,gold); R(8,-1,1,1,gold);
  R(5,0,1,1,gem); R(7,0,1,1,ruby);

  // hair fringe and face
  R(3,1,6,1,hair);
  R(3,2,6,3,face);
  R(4,3,1,1,eye); R(7,3,1,1,eye);   // eyes
  R(5,4,2,1,beard);                  // moustache

  // beard / jaw
  R(4,5,4,1,beard);

  // fur mantle for shoulders
  R(1,6,10,1,fur);

  // chest plate + highlight
  R(3,7,6,3,plate);
  R(4,8,4,1,steel);

  // cape behind shoulders (gives silhouette)
  R(1,7,1,4,cape); R(10,7,1,4,cape);
  R(0,8,1,3,capeDeep); R(11,8,1,3,capeDeep);

  // belt line / shadow line
  R(3,10,6,1,shade);
}


function drawSkeletonPixel(ctx, x, y, tile){
  const { s, R } = gridN(ctx, x, y, tile, 12);
  const bone='#e6e6e6', dark='#0b141d';

  // skull big
  R(2,1,8,4,bone);
  R(3,2,2,1,dark); R(7,2,2,1,dark); // eyes
  R(5,4,2,1,dark);                   // teeth slit

  // ribs & spine occupying width
  R(3,7,6,1,bone); R(3,8,6,1,bone);
  R(6,7,1,3,bone);

  // arms to edge
  R(0,7,3,1,bone); R(9,7,3,1,bone);

  // pelvis/legs
  R(5,10,2,1,bone);
  R(4,11,1,1,bone); R(7,11,1,1,bone);
}

function drawMagePixel(ctx, x, y, tile){
  const { s, R } = gridN(ctx, x, y, tile, 12);
  const hood='#2f1b4d', robe='#5f2e86', sash='#8b55c3', face='#e8d9c0', staff='#a5793f', gem='#66d0ff', dark='#0b141d';

  // hood fills upper
  R(2,1,8,3,hood); R(4,2,4,1,dark); R(5,2,2,1,face);
  // robe wide
  R(2,4,8,7,robe); R(2,8,8,1,sash);
  // staff to full height on right
  R(10,1,1,10,staff); R(10,1,1,1,gem);
  // glow hint
  ctx.save(); ctx.globalAlpha=0.7; R(9,1,1,1,gem); ctx.restore();
}






// Generic dispatcher, scales to tile or 2*tile for bosses
// Backward-compatible: accepts (ctx, type, x, y, sizePx) OR (ctx, enemyObj, x, y, sizePx)
function drawEnemyPixel(ctx, typeOrEnemy, x, y, sizePx){
  const enemy = (typeof typeOrEnemy === 'string' || !typeOrEnemy || !typeOrEnemy.type)
    ? { type: typeOrEnemy }
    : typeOrEnemy;

  // apply boss/elite tint or damage/heal flash
ctx.save();
if (enemy._flashColor && enemy._flashTime > Date.now()) {
    // Override filter for flash effect
    // Red flash (damage) or Green flash (heal)
    const color = enemy._flashColor;
    // Simple filter hack: brightness/sepia/hue-rotate to approximate color
    if (color === 'red') ctx.filter = 'brightness(0.6) sepia(1) hue-rotate(-50deg) saturate(5)'; 
    else if (color === 'green') ctx.filter = 'brightness(1.2) sepia(1) hue-rotate(50deg) saturate(5)';
} else if ((enemy.boss || enemy.elite) && enemy.tint){
  ctx.filter = enemy.tint;
}

  const t = String(enemy.type || '').toLowerCase();
    if (t.includes('mad') && t.includes('king')) { drawMadKingPixel(ctx, x, y, sizePx); ctx.restore(); return; }
  if (t.includes('hood'))                     { drawHoodedPixel(ctx, x, y, sizePx);  ctx.restore(); return; }
  if (t.includes('shadow'))                   { drawShadowPixel(ctx, x, y, sizePx);  ctx.restore(); return; }
if (t.includes('heartless')) { drawHeartlessPixel(ctx, x, y, sizePx); ctx.restore(); return; } // <--- NEW
  if (t.includes('rat'))       { drawRatPixel(ctx, x, y, sizePx); ctx.restore(); return; }
  if (t.includes('bat'))       { drawBatPixel(ctx, x, y, sizePx); ctx.restore(); return; }
  if (t.includes('spider'))    { drawSpiderPixel(ctx, x, y, sizePx); ctx.restore(); return; }
  if (t.includes('goblin'))    { drawGoblinPixel(ctx, x, y, sizePx); ctx.restore(); return; }
  if (t.includes('slime'))     { drawSlimePixel(ctx, x, y, sizePx); ctx.restore(); return; }
  if (t.includes('skeleton'))  { drawSkeletonPixel(ctx, x, y, sizePx); ctx.restore(); return; }
  if (t.includes('mage'))      { drawMagePixel(ctx, x, y, sizePx); ctx.restore(); return; }
  if (t.includes('mimic')) { drawMimicPixel(ctx, x, y, sizePx); ctx.restore(); return; } // Added ctx.restore()
  if (t.includes('clone') || t.includes('mirror')){
    drawPlayerHelmet(ctx, x, y, sizePx, state.player.facing || 'down');
    ctx.restore();
    return;
  }
if (t === 'warlord') {
      ctx.fillStyle = '#ef4444'; 
      ctx.font = 'bold ' + (sizePx) + 'px monospace';
      ctx.textAlign = 'center'; ctx.textBaseline='middle';
      ctx.fillText('W', x + sizePx/2, y + sizePx/2);
      ctx.restore(); return;
  }
  // fallback blocky monster
  const s = Math.max(1, Math.floor(sizePx/6)), px=x, py=y;
  const R=(cx,cy,w,h,c)=>{ctx.fillStyle=c;ctx.fillRect(px+cx*s,py+cy*s,w*s,h*s);};
  R(1,2,4,3,'#7a2b2b'); R(2,3,1,1,'#0b141d'); R(3,3,1,1,'#0b141d');
  ctx.restore();
}


// Full-tile door (flush to edges). Variants: 'wood' (default) or 'iron'.
function drawDoorPixel(ctx, x, y, tile, variant='wood'){
  const { s, R } = gridN(ctx, x, y, tile, 12);

  if (variant === 'iron'){
    // outer shadow border (full tile)
    R(0,0,12,12,'#0b141d');
    // thick steel frame
    R(1,1,10,10,'#2a343f');
    // inner slab
    R(2,2,8,8,'#3a4654');
    // rivets
    R(3,3,1,1,'#c7d0db'); R(8,3,1,1,'#c7d0db');
    R(3,8,1,1,'#c7d0db'); R(8,8,1,1,'#c7d0db');
    // hinge strip (left)
    R(1,3,1,2,'#0b141d'); R(1,7,1,2,'#0b141d');
    // handle
    R(8,6,1,1,'#e6edf5'); R(9,6,1,1,'#9aa7b5');
    return;
  }

  // === WOOD (default) ===
  // outer shadow border (full tile)
  R(0,0,12,12,'#0b141d');

  // heavy frame filling the tile minus 1px inset
  const frame   = '#2b1c10';
  R(1,1,10,10,frame);

  // wood slab inside the frame
  const wood1   = '#7a4f2b';
  const wood2   = '#684225';
  const hi      = '#9b6a3c';
  const shadow  = '#20150c';
  const brass   = '#d7b46a';

  // horizontal planks (fill the entire inner area)
  R(2,2,8,2,wood2);
  R(2,4,8,2,wood1);
  R(2,6,8,2,wood2);
  R(2,8,8,2,wood1);

  // subtle bevel: top highlight & bottom shadow on the frame
  R(1,1,10,1,hi);           // top rim highlight
  R(1,10,10,1,shadow);      // bottom rim shadow
  R(1,1,1,10,shadow);       // left rim shadow
  R(10,1,1,10,shadow);      // right rim shadow

  // hinges (left) for visual read
  R(1,3,1,2,shadow);
  R(1,7,1,2,shadow);

  // handle (right)
  R(9,6,1,1,brass);
  R(8,6,1,1,'#b0894e');     // tiny shade behind the knob
}



// Full-tile 12√ó12 pickup sprites (scaled to the tile with no padding)
function drawPickupPixel(ctx, item, px, py, tile){
  const kind = item?.kind;
  const u = (tile || 12) / 12;                   // exact scale (floats OK)
  const P = (x,y,c,w=1,h=1)=>{                   // grid painter
    ctx.fillStyle = c;
    ctx.fillRect(px + x*u, py + y*u, w*u, h*u);
  };

  // palette
  const steel='#9ca3af', edge='#e5e7eb', dark='#374151', grip='#8b5a2b', wood='#b45309';
  const red='#ef4444', blue='#60a5fa', green='#10b981', grey='#9ca3af', white='#ffffff', black='#0b141d';
  const gold='#f6d66a', bronze='#bfae86', purple='#7c3aed', brass='#d97706', shadow='#78350f';

  // ===== Consumables / utility (now using the full 12√ó12 box) =====
  if (kind === 'potion'){ // tall red bottle
    P(5,1,grey,2,1); P(5,2,white,2,1);
    P(3,3,red,6,6);                         // body fills width
    P(3,9,red,1,1); P(8,9,red,1,1);
    P(4,10,red,4,1);
    return;
  }
  if (kind === 'tonic'){ // tall blue bottle
    P(5,1,grey,2,1); P(5,2,white,2,1);
    P(3,3,blue,6,6);
    P(3,9,blue,1,1); P(8,9,blue,1,1);
    P(4,10,blue,4,1);
    return;
  }
  if (kind === 'antidote'){ // green vial w/ stopper
    P(4,1,white,4,1); P(4,2,white,4,1);
    P(3,3,green,6,5);
    P(5,8,black,2,1);
    return;
  }
  if (kind === 'arrows'){ // 3 long shafts that touch top/bottom
    [2,6,10].forEach(x => { P(x,2,white,1,1); P(x,3,wood,1,7); P(x,10,dark,1,1); });
    return;
  }
  if (kind === 'spell'){ // large scroll with rune
    P(2,4,bronze,8,1); P(2,5,bronze,8,1);
    P(1,6,bronze,1,1); P(10,6,bronze,1,1);
    P(3,6,purple,6,1);
    P(2,7,bronze,8,1);
    return;
  }
  if (kind === 'lockpicks'){ // long picks across tile
    P(2,4,grey,8,1);
    P(3,6,grey,7,1);
    P(4,8,grey,6,1);
    return;
  }
if (kind === 'key'){ // big horizontal key
    P(3,4,gold,3,3);               // bow
    P(6,5,gold,5,1);               // shaft
    P(9,6,gold,1,1); P(10,6,gold,1,1); // teeth
    return;
  }

  // --- NEW: Consumable Sprites ---
  if (kind === 'bomb'){
    // Round black body
    P(3,4,'#1f2937',6,6);
    // Highlight
    P(4,5,'#4b5563',2,2);
    // Fuse cap
    P(5,3,'#9ca3af',2,1);
    // Fuse
    P(6,1,'#d97706',1,2);
    // Spark
    P(6,0,'#ef4444',1,1); P(7,1,'#fbbf24',1,1);
    return;
  }
  if (kind === 'warp'){
    // Advanced Warp Rune
    const core = '#22d3ee'; // Cyan
    const dark = '#0c4a6e'; // Deep blue
    const outer= '#0ea5e9'; // Sky blue
    
    // Outer diamond
    P(6,2,outer,1,1); P(5,3,outer,1,1); P(7,3,outer,1,1);
    P(4,4,outer,1,1); P(8,4,outer,1,1);
    P(3,5,outer,1,1); P(9,5,outer,1,1);
    P(6,10,outer,1,1); P(5,9,outer,1,1); P(7,9,outer,1,1);
    P(4,8,outer,1,1); P(8,8,outer,1,1);
    P(3,7,outer,1,1); P(9,7,outer,1,1);
    
    // Inner dark stone
    P(4,5,dark,5,3);
    
    // Glowing rune symbol
    P(6,5,core,1,3); P(5,6,core,3,1);
    
    // Pulse animation
    const tick = Math.floor(Date.now() / 200);
    if(tick % 2 === 0) P(2,2, '#fff',1,1); // Sparkle
    return;
  }



// inside drawPickupPixel(ctx, item, px, py, tile) ...
// Catch generic shields OR weapons that are actually shields
const isShieldWeapon = (kind === 'weapon' && (item.payload?.type === 'shield' || (item.payload?.name && getWeaponType(item.payload.name) === 'shield')));

if (kind === 'shield' || isShieldWeapon){ // round wood shield using full 12√ó12 grid
  const rim = '#bd9245', wood = '#8a5a2e', edge = '#0b141d';
  const boss = '#c7ced9', hl = '#eef3ff';

  // helper: draw a filled circle on the 12√ó12 logical grid
  const C = (r, color)=>{
    ctx.fillStyle = color;
    for (let dy = -r; dy <= r; dy++){
      const hw = Math.floor(Math.sqrt(r*r - dy*dy));    // half-width at this scanline
      // center at (6,6) and scale by u so it fills the tile
      const x = 6 - hw, y = 6 + dy, w = 2*hw + 1, h = 1;
      ctx.fillRect(px + x*u, py + y*u, w*u, h*u);
    }
  };

  const MARGIN = 1;                 // tweak to taste (0..2 looks good)
const rOuter = 6 - MARGIN;

C(rOuter,     edge);              // now 1px in from the edge
C(rOuter - 1, rim);
C(rOuter - 2, wood);

  // center boss + highlight
  ctx.fillStyle = boss; ctx.fillRect(px + 5*u, py + 5*u, 2*u, 2*u);
  ctx.fillStyle = hl;   ctx.fillRect(px + 6*u, py + 6*u, 1*u, 1*u);
  return;
}







// ===== Weapons (payload.type: 'one'|'two'|'spear'|'axe'|future 'hand') =====
  if (kind === 'weapon'){
    // Fix: Capture the specific name for visual overrides, separate from the type
    const nameStr = String(item?.payload?.name || '').toLowerCase();
    const t = String((item?.payload?.type || item?.payload?.name || item?.payload || '')).toLowerCase();

    // KINGDOM HEARTS REFERENCE (Visuals)
    if (nameStr.includes('key of destiny') || t.includes('keyblade')) {
      const yellow = '#facc15', blade = '#e5e7eb', grip = '#1f2937';
      
      // Guard (The yellow hand protection)
      P(2,4, yellow, 1, 5); // Vertical guard bar
      P(1,4, yellow, 2, 1); // Top guard hook
      P(1,8, yellow, 2, 1); // Bottom guard hook
      
      // Grip (Dark handle inside guard)
      P(0,6, grip, 2, 1); 

      // Shaft (Long silver blade)
      P(3,6, blade, 7, 1); 

      // Teeth (The crown-shaped keys at the tip)
      P(8,7, blade, 1, 2); 
      P(9,7, blade, 1, 1);

      
      return;
    }

    // One-Handed Sword ‚Äì long blade across tile
    if (t === 'one' || t.includes('one-handed') || (t.includes('sword') && !t.includes('two'))){
      P(2,6,grip,2,1);                   // hilt
      P(4,4,dark,1,5);                   // crossguard
      P(5,5,steel,5,3);                  // blade
      P(10,5,edge,1,1); P(10,7,edge,1,1);// tip shine
      return;
    }

    // Two-Handed Sword ‚Äì even wider blade + longer grip
    if (t === 'two' || t.includes('two-handed') || t.includes('greatsword') || t.includes('2h')){
      P(1,6,grip,3,1);                   // long grip
      P(4,4,dark,1,5); P(4,3,dark,1,1);  // big guard
      P(5,4,steel,5,4);                  // wide blade
      P(10,4,edge,1,1); P(10,6,edge,1,1);
      P(7,6,dark,1,1);                   // fuller hint
      return;
    }

    // Spear ‚Äì full-length shaft with tall head
    if (t === 'spear' || t.includes('spear') || t.includes('pike')){
      P(2,6,wood,7,1);                   // shaft span
      P(9,4,edge,2,1);                   // head top
      P(9,5,steel,2,2);                  // head body
      P(9,7,edge,2,1);                   // head bottom
      return;
    }

    // Axe ‚Äì big head + long haft
    if (t === 'axe' || t.includes('ax')){
      P(4,8,wood,1,4);                   // haft to bottom
      P(5,4,steel,4,3);                  // head
      P(8,5,edge,1,1);                   // edge
      return;
    }

    // Hand-to-Hand ‚Äì full width knuckle/gauntlet plate
    if (t === 'hand' || t.includes('hand-to-hand') || t.includes('gauntlet') || t.includes('knuckle') || t.includes('fist')){
      P(3,6,brass,6,2);                  // bar
      P(3,5,black,1,1); P(5,5,black,1,1); P(7,5,black,1,1); // finger holes
      P(3,8,shadow,2,1); P(7,8,shadow,2,1);
      return;
    }

    // Fallback mini blade (should rarely show)
    P(3,6,grip,1,1); P(4,6,steel,6,1); P(10,6,edge,1,1);
    return;
  }

  // unknown kind: small gold block centered
  P(5,5,gold,2,2);
}





// Tiny pixel stairs (12√ó12 grid) ‚Äî rotated 180¬∞ so longest tread is at bottom
function drawStairsPixel(ctx, x, y, tile){
  // fill full tile background first (unchanged look)
  ctx.fillStyle = '#0b141d';
  ctx.fillRect(x, y, tile, tile);

  const { s, R } = gridN(ctx, x, y, tile, 12);
  const stone='#7c8a99', stoneHi='#a9b6c4', shadow='#0b141d';

  // background fill so it clearly occupies full tile
  R(0,0,12,12,'#0b141d');

  // treads (widest bottom, stepping up)
  R(1,9,10,1,stoneHi);
  R(1,7,8,1,stone);
  R(1,5,6,1,stoneHi);
  R(1,3,4,1,stone);
  R(1,1,2,1,stoneHi);

  // risers (right-side shadows)
  R(11,9,1,1,shadow);
  R(9,7,1,1,shadow);
  R(7,5,1,1,shadow);
  R(5,3,1,1,shadow);

  // bottom pit mouth
  R(9,10,2,1,shadow);
}

function drawCandlePixel(ctx, x, y, tile){
  const { s, R } = gridN(ctx, x, y, tile, 12);
  const wax   = '#f6f1d5';
  const wick  = '#3b2f2f';
  const flame = '#f9d65c';
  const glow  = '#ffef9a';
  const base  = '#6b3f1f';

  // base holder
  R(4,9,4,2,base);
  // wax
  R(5,6,2,3,wax);
  // wick
  R(6,5,1,1,wick);
  // flame core + glow
  R(6,4,1,1,flame);
  R(5,4,1,1,glow); R(7,4,1,1,glow);
}

// NEW: a "two candles" tile used by merchant/cartographer stands
function drawCandlesPixel(ctx, x, y, tile){
  const { R } = gridN(ctx, x, y, tile, 12);
  const wax   = '#f6f1d5';
  const wick  = '#3b2f2f';
  const flame = '#f9d65c';
  const glow  = '#ffef9a';
  const base  = '#6b3f1f';

  // subtle pooled light so the tile reads as "lit"
  ctx.save();
  ctx.globalAlpha = 0.18;
  R(1,8,10,4,glow);
  ctx.restore();

  // LEFT candle
  R(2,9,3,2,base);
  R(3,6,1,3,wax);
  R(3,5,1,1,wick);
  R(3,4,1,1,flame);
  R(2,4,1,1,glow); R(4,4,1,1,glow);

  // RIGHT candle
  R(7,9,3,2,base);
  R(8,6,1,3,wax);
  R(8,5,1,1,wick);
  R(8,4,1,1,flame);
  R(7,4,1,1,glow); R(9,4,1,1,glow);
}


function drawMerchantNpcPixel(ctx, x, y, tile){
  const { s, R } = gridN(ctx, x, y, tile, 12);
  const hood  = '#2a4466';
  const robe  = '#335a86';
  const trim  = '#6b3f1f';
  const face  = '#efd8b8';
  const hair  = '#3b2f2f';
  const eyes  = '#0b141d';
  const gold  = '#f2c94c';

  // boots
  R(4,10,2,1,trim); R(6,10,2,1,trim);

  // robe
  R(3,6,6,4,robe);
  R(3,8,6,1,hood);
  // belt / coin pouch
  R(3,8,1,1,trim); R(8,8,1,1,trim);
  R(6,8,1,1,gold);

  // arms
  R(2,7,1,2,robe);
  R(9,7,1,2,robe);

  // head + hood
  R(4,3,4,3,face);
  R(4,3,1,1,hair); R(7,3,1,1,hair);
  R(4,4,1,1,eyes); R(7,4,1,1,eyes);
  R(3,2,6,2,hood);
  R(3,4,1,1,hood); R(8,4,1,1,hood);
}

function drawAnvilPixel(ctx, x, y, tile){
  const { R } = gridN(ctx, x, y, tile, 12);
  const steel='#8a98a6', dark='#0b141d';
  R(2,8,8,1,steel);   // base
  R(3,7,6,1,steel);   // body
  R(4,6,4,1,steel);   // top
  R(8,5,2,1,steel);   // horn
  R(9,6,1,1,dark);    // horn shadow
}

// --- ADD: Blacksmith forge tile (12x12) ---
function drawForgePixel(ctx, x, y, tile){
  const { R } = gridN(ctx, x, y, tile, 12);
  const bg    = '#0b141d';
  const stone = '#374151';
  const stone2= '#4b5563';
  const iron  = '#9ca3af';
  const dark  = '#111827';
  const ember = '#ef4444';
  const glow1 = '#f97316';
  const glow2 = '#fbbf24';

  // background
  // R(0,0,12,12,bg);

  // forge body
  R(1,7,10,5,stone);
  R(2,8,8,3,stone2);

  // opening
  R(3,9,6,2,dark);

  // coals
  R(4,10,1,1,ember);
  R(5,10,1,1,glow1);
  R(6,10,1,1,glow2);
  R(7,10,1,1,glow1);

  // grate lip
  R(3,8,6,1,iron);

  // chimney
  R(5,1,2,6,stone2);
  R(5,0,2,1,stone);

  // tiny sparks
  R(4,2,1,1,glow2);
  R(7,3,1,1,glow1);
}

// --- ADD: Merchant table tile (12x12) ---
function drawTablePixel(ctx, x, y, tile){
  const { R } = gridN(ctx, x, y, tile, 12);
  const bg     = '#0b141d';
  const wood1  = '#6b3f1f';
  const wood2  = '#8b5a2b';
  const shadow = '#3b2f2f';
  const hi     = '#b0894e';
  const gold   = '#f2c94c';

  // background
  // R(0,0,12,12,bg);

  // tabletop + apron
  R(1,4,10,1,wood2);
  R(1,5,10,3,wood1);
  R(1,8,10,1,wood2);

  // simple depth
  R(1,6,10,1,shadow);
  R(2,5,8,1,hi);

  // legs
  R(2,9,2,3,wood2);
  R(8,9,2,3,wood2);

  // little coin pile
  R(5,6,2,1,gold);
  R(6,7,1,1,gold);
}

// --- ADD: 2-candle stand tile (matches your drawCandlesPixel calls) ---
function drawCandlesPixel(ctx, x, y, tile){
  const { R } = gridN(ctx, x, y, tile, 12);
  const bg    = '#0b141d';
  const cloth = '#152231';
  const wax   = '#f6f1d5';
  const wick  = '#3b2f2f';
  const flame = '#f9d65c';
  const glow  = '#ffef9a';
  const base  = '#6b3f1f';

  // R(0,0,12,12,bg);

  // little table/cloth patch so the candles read
  R(1,7,10,4,cloth);

  // left candle
  R(3,9,2,2,base);
  R(3,6,2,3,wax);
  R(4,5,1,1,wick);
  R(4,4,1,1,flame);
  R(3,4,1,1,glow); R(5,4,1,1,glow);

  // right candle
  R(7,9,2,2,base);
  R(7,6,2,3,wax);
  R(8,5,1,1,wick);
  R(8,4,1,1,flame);
  R(7,4,1,1,glow); R(9,4,1,1,glow);
}

function drawBlacksmithNpcPixel(ctx, x, y, tile){
  const { R } = gridN(ctx, x, y, tile, 12);
  const apron='#4b5563', shirt='#9ca3af', skin='#f3d7b6', hair='#3b2f2f', eye='#0b141d';
  R(4,10,2,1,apron); R(6,10,2,1,apron);         // boots
  R(3,6,6,4,apron);                              // apron
  R(4,3,4,3,skin); R(4,4,1,1,eye); R(7,4,1,1,eye); // head
  R(3,2,6,1,hair);
  R(2,7,1,2,shirt); R(9,7,1,2,shirt);           // arms
}


function drawJesterNpcPixel(ctx, x, y, tile) {
  const { s, R } = gridN(ctx, x, y, tile, 12);
  // Colors: 3-point hat (red, green, blue), two-tone tunic (purple, red), white face, black eyes
  const hatRed    = '#bd2220', hatGreen = '#22c55e', hatBlue  = '#2252be';
  const tunicPurple = '#5a2b9a', tunicRed = '#bd2220';
  const faceColor = '#ffffff', eyeColor = '#000000';
  const shoeColor = '#6e7378';
  // Hat: three points with bells (top row and second row)
  R(3, 0, 2, 1, hatRed);
  R(5, 0, 2, 1, hatGreen);
  R(7, 0, 2, 1, hatBlue);
  R(3, 1, 1, 1, hatRed);
  R(5, 1, 4, 1, hatGreen); // spans cols 5‚Äì8
  R(7, 1, 3, 1, hatBlue);
  // Face (white) and eyes
  R(4, 3, 4, 2, faceColor);
  R(5, 4, 1, 1, eyeColor);
  R(7, 4, 1, 1, eyeColor);
  // Tunic/body: left half purple, right half red, with arms
  R(3, 5, 3, 4, tunicPurple);
  R(6, 5, 3, 4, tunicRed);
  R(2, 5, 1, 3, tunicPurple); // left sleeve
  R(9, 5, 1, 3, tunicRed);    // right sleeve
  // Shoes (pointy)
  R(3, 9, 2, 1, shoeColor);
  R(7, 9, 2, 1, shoeColor);
}

// NEW: Cartographer pixel sprite (12x12)
function drawCartographerNpcPixel(ctx, x, y, tile){
  const { R } = gridN(ctx, x, y, tile, 12);
  const cloak = '#2f6b4f';
  const cloak2= '#24523c';
  const face  = '#efd8b8';
  const hair  = '#3b2f2f';
  const eyes  = '#0b141d';
  const belt  = '#6b3f1f';
  const paper = '#f6f1d5';
  const ink   = '#213a57';
  const boots = '#2b2b2b';

  // boots
  R(4,10,2,1,boots); R(6,10,2,1,boots);

  // cloak/body
  R(3,6,6,4,cloak);
  R(3,8,6,1,cloak2);

  // belt
  R(3,8,6,1,belt);

  // arms
  R(2,7,1,2,cloak);
  R(9,7,1,2,cloak);

  // head
  R(4,3,4,3,face);
  R(4,3,1,1,hair); R(7,3,1,1,hair);
  R(4,4,1,1,eyes); R(7,4,1,1,eyes);

  // scroll/map in hands
  R(5,7,3,2,paper);
  R(5,7,3,1,ink); // top ink line
  R(5,8,1,1,ink); R(7,8,1,1,ink); // dots
}

function drawJesterWheelPixel(ctx, x, y, tile) {

  const { s, R } = gridN(ctx, x, y, tile, 12);
  const red = '#bd2220', green = '#22c55e';
  // Draw a 10-slice wheel pattern (alternating red/green) on a 12√ó12 grid.
  // Row 0
  R(3, 0, 3, 1, red);
  R(6, 0, 2, 1, green);
  // Row 1
  R(2, 1, 4, 1, red);
  R(6, 1, 2, 1, green);
  R(8, 1, 2, 1, red);
  // Row 2
  R(1, 2, 2, 1, green);
  R(3, 2, 3, 1, red);
  R(6, 2, 1, 1, green);
  R(7, 2, 3, 1, red);
  // Row 3
  R(0, 3, 4, 1, green);
  R(4, 3, 2, 1, red);
  R(6, 3, 1, 1, green);
  R(7, 3, 3, 1, red);
  R(10,3, 1, 1, green);
  // Row 4
  R(0, 4, 3, 1, red);
  R(3, 4, 1, 1, green);
  R(4, 4, 4, 1, red);
  R(8, 4, 3, 1, green);
  // Row 5
  R(0, 5, 8, 1, red);
  R(8, 5, 3, 1, green);
  // Row 6
  R(0, 6, 3, 1, red);
  R(3, 6, 2, 1, green);
  R(5, 6, 1, 1, red);
  R(6, 6, 1, 1, green);
  R(7, 6, 1, 1, red);
  R(8, 6, 3, 1, green);
  // Row 7
  R(0, 7, 1, 1, red);
  R(1, 7, 3, 1, green);
  R(4, 7, 2, 1, red);
  R(6, 7, 1, 1, green);
  R(7, 7, 4, 1, red);
  // Row 8
  R(1, 8, 3, 1, green);
  R(4, 8, 2, 1, red);
  R(6, 8, 2, 1, green);
  R(8, 8, 2, 1, red);
  // Row 9
  R(2, 9, 1, 1, green);
  R(3, 9, 3, 1, red);
  R(6, 9, 3, 1, green);
  // Row 10
  R(3,10, 3, 1, red);
  R(6,10, 2, 1, green);
  // (Row 11 left blank)
}

// --- NEW: Biome & Trap Visuals ---
function getBiomePalette(floor) {
  // Define the Biome Cycle (Order matters)
  const BIOMES = [
    { name: 'Sewers',          wall:'#061018', floor:'#152231', top:'#111c26' }, // 1-10
    { name: 'Crypt',           wall:'#1a1a24', floor:'#2a2a35', top:'#252530' }, // 11-20
    { name: 'Magma Caverns',   wall:'#261010', floor:'#3d1c1c', top:'#331515' }, // 21-30
    { name: 'Overgrown Ruins', wall:'#0f291e', floor:'#1b3b2b', top:'#163024' }, // 31-40 (New: Green/Jungle)
    { name: 'The Void',        wall:'#000000', floor:'#1a0b2e', top:'#0d001a' }, // 41-50 (New: Deep Purple/Space)
    { name: 'Gilded Halls',    wall:'#2e2616', floor:'#423825', top:'#594d33' }  // 51-60 (New: Gold/Brown)
  ];

  // Calculate index based on floor (1-10 = 0, 11-20 = 1, etc.)
  // The % BIOMES.length ensures it loops forever (Endless safe)
  const cycleIndex = Math.floor((floor - 1) / 10) % BIOMES.length;
  
  return BIOMES[cycleIndex];
}

function drawSpikePixel(ctx, x, y, tile) {
  const { R } = gridN(ctx, x, y, tile, 12);
  // Background (Floor)
  // R(0,0,12,12, bg); // Assumes drawn over floor
  
  const steel = '#9ca3af';
  const dark  = '#4b5563';
  const tip   = '#e5e7eb';
  const blood = '#ef4444';

  // 3 Spikes in a pattern
  // Spike 1 (Top Left)
  R(2,3,1,3,steel); R(2,2,1,1,tip); R(3,5,1,1,dark);
  
  // Spike 2 (Bottom Right)
  R(8,7,1,3,steel); R(8,6,1,1,tip); R(7,9,1,1,dark);
  
  // Spike 3 (Center)
  R(5,5,1,4,steel); R(5,4,1,1,tip); R(6,8,1,1,dark);
  
  // Blood stain (random chance for flavor, deterministic by coord would be better but static is fine)
  R(5,6,1,1,blood);
}




function draw(){
  setupCanvas();
  const w = canvas.width/(window.devicePixelRatio||1), h = canvas.height/(window.devicePixelRatio||1);
  const tile = 35;
  const viewW = Math.floor(w/tile), viewH = Math.floor(h/tile);

  // --- NEW: Smooth Movement Math ---
  // 1. Init if missing (legacy save safety)
  if (state.player.rx === undefined) { state.player.rx = state.player.x; state.player.ry = state.player.y; }

  // 2. Interpolate (Lerp) towards target. 0.25 = move 25% of the distance per frame.
  const lerp = 0.25; 
  state.player.rx += (state.player.x - state.player.rx) * lerp;
  state.player.ry += (state.player.y - state.player.ry) * lerp;

  // 3. Snap if very close to stop micro-jitter
  if (Math.abs(state.player.x - state.player.rx) < 0.01) state.player.rx = state.player.x;
  if (Math.abs(state.player.y - state.player.ry) < 0.01) state.player.ry = state.player.y;
  // --------------------------------

  const ox = state.player.x - Math.floor(viewW/2);
  const oy = state.player.y - Math.floor(viewH/2);
  const rad = state.player.tempVisionRange || state.fovRadius;

  const bossesToDraw = []; // {sym, px, py}
  const fogRects = [];     // {px, py}
  
  // --- NEW: Fetch Palette ---
  const pal = getBiomePalette(state.floor); 

  for (let y=-1; y+oy<state.size.h && y<viewH+1; y++){
    for (let x=-1; x+ox<state.size.w && x<viewW+1; x++){
      const gx=ox+x, gy=oy+y;
      const px=x*tile, py=y*tile;

      ctx.fillStyle='#0b141d'; // Void color
      ctx.fillRect(px,py,tile,tile);
      if(!inBounds(gx,gy)) continue;

      const d = Math.abs(gx-state.player.x)+Math.abs(gy-state.player.y);
      const vis = d<=rad;
      const kxy = key(gx,gy);
      if (vis) state.seen.add(kxy);
      const seen = state.seen.has(kxy);

      if (!seen){ ctx.fillStyle='#081018'; ctx.fillRect(px,py,tile,tile); fogRects.push({px,py}); continue; }

      const t = state.tiles[gy][gx];

      // base floor
      if (t===0){ 
        // --- NEW: Dynamic Wall Colors ---
        ctx.fillStyle = pal.wall; 
        ctx.fillRect(px,py,tile,tile); 
        
        ctx.fillStyle = pal.top; 
        ctx.fillRect(px, py, tile, tile - 10); 
        
        fogRects.push({px,py}); 
        continue; 
      }
      
     // --- NEW: Dynamic Floor Color ---
      ctx.fillStyle = pal.floor;
      ctx.fillRect(px,py,tile,tile);

      // props
      // --- NEW: Render Scenery (Tile 8) ---
      if (t===8) {
        if (state.props && state.props[kxy]) {
          drawPropPixel(ctx, state.props[kxy].type, px, py, tile);
        }
      }
      // ------------------------------------
      // --- NEW: Render Spikes (Tile 7) ---
      if (t===7) {
        drawSpikePixel(ctx, px, py, tile);
      }
      // -----------------------------------
      
if (t===2){
  const locked = state.lockedDoors?.has(kxy);
  drawDoorPixel(ctx, px, py, tile, !!locked);
}
else if (t===3){
  drawChestPixel(ctx, px, py, tile);
}
else if (t===4){
  drawStairsPixel(ctx, px, py, tile);
}


else if (t===5){
  const it = state.pickups[kxy];
  if (it){ + drawPickupPixel(ctx, it, px, py, tile); }
}
else if (t===6){
  // Background: Dark floor
  // ctx.fillStyle = '#0b141d'; ctx.fillRect(px,py,tile,tile); 
  
  const { R } = gridN(ctx, px, py, tile, 12);
  R(2,8,8,1,'#4a5d75'); 
  R(3,7,6,1,'#4a5d75'); 
  R(4,3,4,4,'#6d88ad');

  ctx.shadowColor = '#7df9ff'; 
  ctx.shadowBlur = 10;
  R(5,2,2,2,'#7df9ff'); 
  ctx.shadowBlur = 0;
}
// --- NEW: Draw Gold Well (2x2) ---
    if (state.goldWell) {
       const gw = state.goldWell;
       // FIX: Draw when at the BOTTOM-RIGHT tile so we render ON TOP of the floor
       if (gx === gw.x + 1 && gy === gw.y + 1) {
          const s = tile; // base size
          // Draw 2x2 Well (Calculate Top-Left relative to current Bottom-Right)
          const wx = (gw.x - ox) * tile;
          const wy = (gw.y - oy) * tile;
          
          const water = gw.used ? '#374151' : '#facc15'; // Gold if unused, Grey if used
          
          // Advanced Well Art (2x2)
          const { R } = gridN(ctx, wx, wy, s*2, 24); // 24x24 pixel grid spread over 2 tiles
          
          // 1. Base Platform (Stone steps)
          R(1, 1, 22, 22, '#1f2937'); // Dark shadow/base
          R(2, 2, 20, 20, '#374151'); // Stone Step 1
          
          // 2. The Well Wall (Marble/White Stone)
          R(4, 4, 16, 16, '#9ca3af'); // Outer wall
          R(5, 5, 14, 14, '#e5e7eb'); // Inner rim highlight
          R(5, 5, 14, 1,  '#f3f4f6'); // Top lip highlight

          // 3. The Liquid (Gold or Empty)
          if (gw.used) {
             R(6, 6, 12, 12, '#111827'); // Empty/Dark
          } else {
             R(6, 6, 12, 12, '#eab308'); // Gold Base
             R(7, 7, 10, 10, '#facc15'); // Gold Shine
             
             // Dynamic Sparkles inside liquid
             const tick = Math.floor(Date.now() / 300);
             if (tick % 3 === 0) R(8, 8, 2, 2, '#fff');
             if (tick % 3 === 1) R(13, 10, 2, 2, '#fff');
             if (tick % 3 === 2) R(10, 13, 2, 2, '#fff');
          }

          // 4. Roof Structure (Wooden supports & Roof)
          // Pillars
          R(3, 8, 2, 12, '#5c4033'); // Left Pillar
          R(19, 8, 2, 12, '#5c4033'); // Right Pillar
          
          // Roof (Triangle ish)
          R(2, 6, 20, 2, '#78350f'); // Base beam
          R(3, 4, 18, 2, '#92400e'); // Roof mid
          R(5, 2, 14, 2, '#b45309'); // Roof top
          R(11, 0, 2, 2, '#fcd34d'); // Gold finial on top

          // 5. Aura (if active)
          if (!gw.used) {
             ctx.save();
             ctx.shadowColor = '#facc15'; ctx.shadowBlur = 20;
             ctx.fillStyle = 'rgba(250, 204, 21, 0.15)';
             ctx.fillRect(wx, wy, s*2, s*2);
             ctx.restore();
          }
       }
    }

// Merchant / Blacksmith NPC stands
    if (state.merchant){
      if (gx===state.merchant.left.x && gy===state.merchant.left.y){
        drawCandlesPixel(ctx, px, py, tile);
      } else if (gx===state.merchant.x && gy===state.merchant.y){
        drawMerchantNpcPixel(ctx, px, py, tile);
      } else if (gx===state.merchant.right.x && gy===state.merchant.right.y){
        drawTablePixel(ctx, px, py, tile);
      }
    }
    if (state.blacksmith){
      if (gx===state.blacksmith.left.x && gy===state.blacksmith.left.y){
        drawAnvilPixel(ctx, px, py, tile);
      } else if (gx===state.blacksmith.x && gy===state.blacksmith.y){
        drawBlacksmithNpcPixel(ctx, px, py, tile);
      } else if (gx===state.blacksmith.right.x && gy===state.blacksmith.right.y){
        drawForgePixel(ctx, px, py, tile);
      }
    }
    // Cartographer NPC stand
    if (state.cartographer){
      if (gx===state.cartographer.left.x && gy===state.cartographer.left.y){
        // tiny map table or candle reused
        drawCandlesPixel(ctx, px, py, tile);
      } else if (gx===state.cartographer.x && gy===state.cartographer.y){
        drawCartographerNpcPixel(ctx, px, py, tile);
      } else if (gx===state.cartographer.right.x && gy===state.cartographer.right.y){
        drawCandlesPixel(ctx, px, py, tile);
      }
    }

// After fix (only draw on right side of the jester)
if (state.jester) {
    if (gx === state.jester.x && gy === state.jester.y) {
        drawJesterNpcPixel(ctx, px, py, tile);
    } else if (gx === state.jester.right.x && gy === state.jester.right.y) {
        drawJesterWheelPixel(ctx, px, py, tile);
    }
}



      
// --- NEW: Draw Volatile Aether Bombs ---
if (state.explosions) {
  for (const bomb of state.explosions) {
    if (!state.seen.has(key(bomb.x, bomb.y))) continue;
    
    // Draw pulsing red zone
    const sx = (bomb.x - ox) * tile;
    const sy = (bomb.y - oy) * tile;
    
    ctx.fillStyle = `rgba(255, 69, 0, ${0.3 + (Math.sin(Date.now() / 100) * 0.1)})`;
    ctx.fillRect(sx, sy, tile, tile);
    
    // Draw Text Timer
    ctx.font = "bold 16px monospace";
    ctx.fillStyle = '#fff';
    ctx.textAlign = "center";
    ctx.fillText(bomb.timer, sx + tile/2, sy + tile/2 + 5);
  }
}
// ---------------------------------------

// enemies (collect bosses for later, now pixel-based)
for (const e of state.enemies){
  const s = e.size || 1;
  
  // Handle flash expiration
  if (e._flashTime && Date.now() > e._flashTime) {
    e._flashTime = 0; e._flashColor = null;
  }

  if (s === 1){
    if (e.x === gx && e.y === gy) drawEnemyPixel(ctx, e, px, py, tile); 
  } else {
    if (gx === e.x && gy === e.y) bossesToDraw.push({ enemy: e, px, py }); // keep the whole enemy
  }
}



      if (!vis) fogRects.push({px,py});
    }
  }

  // draw stretched bosses AFTER tiles (2√ó footprint)
  for (const b of bossesToDraw){
    drawEnemyPixel(ctx, b.enemy, b.px, b.py, tile*2); // pass enemy object
  }

  // projectiles (magic bolts / arrows) on top of tiles, under player
  if (Array.isArray(state.projectiles) && state.projectiles.length){
    for (const proj of state.projectiles){
      // interpolate world ‚Üí screen position
      const gx = proj.fromX + (proj.toX - proj.fromX) * proj.t;
      const gy = proj.fromY + (proj.toY - proj.fromY) * proj.t;
      const sx = (gx - ox) * tile;
      const sy = (gy - oy) * tile;

      // only draw if on-screen
      if (sx + tile < 0 || sy + tile < 0 || sx > w || sy > h) continue;
      drawProjectilePixel(ctx, proj, sx, sy, tile);
    }
  }

// player on top (pixel helmet) - USE SMOOTH COORDS (rx/ry)
const ppx = (state.player.rx-ox)*tile, ppy = (state.player.ry-oy)*tile;

// --- NEW: Draw Aura ---
if (state.player.blessTicks > 0) {
  ctx.save();
  // Pulsing gold glow
  ctx.globalAlpha = 0.3 + (Math.sin(Date.now() / 200) * 0.1); 
  ctx.fillStyle = '#fbbf24'; 
  ctx.beginPath();
  ctx.arc(ppx + tile/2, ppy + tile/2, tile * 0.75, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}
// ----------------------

drawPlayerHelmet(ctx, ppx, ppy, tile, state.player.facing || 'down');

// --- NEW: Draw Cleric NPC ---
if (state.cleric) {
  const cx = (state.cleric.x - ox) * tile;
  const cy = (state.cleric.y - oy) * tile;
  if (state.seen.has(key(state.cleric.x, state.cleric.y))) {
     // High Priestess Sprite
     const { R } = gridN(ctx, cx, cy, tile, 12);
     const robe = '#f8fafc', gold = '#fbbf24', skin = '#ffe4c4';
     const hoodShadow = '#94a3b8';
     
     // Robe Base
     R(3,4, 6,8, robe); 
     
     // Gold Trim (Vertical Vestment)
     R(4,4, 1,8, gold); R(7,4, 1,8, gold);
     
     // Head/Hood
     R(3,1, 6,3, robe); // Hood shape
     R(4,2, 4,2, skin); // Face
     R(4,1, 4,1, hoodShadow); // Inner hood shadow
     
     // Staff
     R(9,1, 1,11, '#d4d4d8'); // Silver staff
     R(8,1, 3,1, gold);       // Top cross
     R(9,2, 1,2, gold);       // Top head
     
     // Magic Aura
     const tick = Math.floor(Date.now() / 300);
     if (tick % 2 === 0) R(2,2, 1,1, '#fff'); // Sparkle left
     else R(10,5, 1,1, '#fff'); // Sparkle right
  }
}
// ----------------------------

// NEW: cartographer arrow overlay (points to stairs)
drawCartographerStairsArrow(ctx, ox, oy, tile);



updateMerchantAudio();
if (merchantAudio && merchantAudio.muted && audioCtx && audioCtx.state === 'running') merchantAudio.muted = false;

updateBlacksmithAudio();
if (blacksmithAudio && blacksmithAudio.muted && audioCtx && audioCtx.state === 'running') blacksmithAudio.muted = false;

updateJesterAudio();
if (jesterAudio && jesterAudio.muted && audioCtx && audioCtx.state === 'running') jesterAudio.muted = false;

updateCartographerAudio();
if (cartographerAudio && cartographerAudio.muted && audioCtx && audioCtx.state === 'running') cartographerAudio.muted = false;

// --- FIX: Add Cleric Here ---
updateClericAudio();
if (clericAudio && clericAudio.muted && audioCtx && audioCtx.state === 'running') clericAudio.muted = false;
// ----------------------------


  // fog last so it still darkens bosses & player outside FOV
  if (!state.noFog && !state.cartographerMapActive) {
    ctx.fillStyle='rgba(0,0,0,0.55)';
    for (const f of fogRects) ctx.fillRect(f.px, f.py, tile, tile);
  }


  updateBossHud();

  // --- NEW: Miasma Chamber green screen tint ---
  if (state.floorEffect === 'MiasmaChamber' && !state.gameOver) {
    ctx.fillStyle = 'rgba(0, 80, 0, 0.22)';
    ctx.fillRect(0, 0, w, h);
  }
  // --- END: Miasma tint ---

  if (state.player.hp / state.player.hpMax <= 0.30 && !state.gameOver) {
    const grad = ctx.createRadialGradient(
      w/2, h/2, 40,
      w/2, h/2, Math.max(w,h)/1.2
    );
    grad.addColorStop(0, 'rgba(140,0,0,0)');
    grad.addColorStop(1, 'rgba(140,0,0,0.62)');
ctx.fillStyle = grad;
    ctx.fillRect(0, 0, w, h);
  }

  // --- NEW: Enemy Intent Icons ---
  ctx.font = "bold 16px sans-serif";
  ctx.textAlign = "center";
  for (const e of state.enemies) {
    // Only show intent if we can see the enemy
    const kxy = key(e.x, e.y);
    if (!state.seen.has(kxy)) continue;
    
    // Convert logic coords to screen coords (same math as main loop)
    const sx = (e.x - ox) * tile + tile/2;
    const sy = (e.y - oy) * tile - 10; // Floating above head

    if (e.charging) {
      ctx.fillStyle = '#ff0000';
      ctx.fillText("‚ö†Ô∏è", sx, sy); // Telegraphed Attack Warning
    } else if (e.stunTicks > 0) {
      ctx.fillText("üí´", sx, sy); // Stunned
    } else if (e.sleep) {
      ctx.fillText("üí§", sx, sy); // Asleep
    }
  }

  

  // --- Particle Rendering (Optimized) ---
  let activeEffects = false;

  if (state.particles && state.particles.length > 0) {
    activeEffects = true;
    state.particles = state.particles.filter(p => p.life > 0);
    state.particles.forEach(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.life--;
      
      const sx = (p.x - ox) * tile + tile/2;
      const sy = (p.y - oy) * tile + tile/2;
      
      ctx.fillStyle = p.color;
      ctx.globalAlpha = p.life < 20 ? p.life / 20 : 1.0;
      ctx.fillRect(sx, sy, p.size, p.size);
      ctx.globalAlpha = 1.0;
    });
  }

  // --- Floating Text (Time-Based & Optimized) ---
// --- Floating Text (Highly Optimized) ---
  if (state.floatingText && state.floatingText.length > 0) {
    activeEffects = true;
    const now = Date.now();
    ctx.font = "bold 14px monospace";
    ctx.textAlign = "center";
    
    // Filter expired
    state.floatingText = state.floatingText.filter(ft => now < ft.start + ft.duration);
    
    state.floatingText.forEach(ft => {
      const elapsed = now - ft.start;
      const pct = elapsed / ft.duration;
      
      const rise = pct * 30; 
      
      // OPTIMIZATION: Math.floor coords prevents sub-pixel rendering lag
      const sx = Math.floor((ft.x - ox) * tile + tile/2);
      const sy = Math.floor((ft.y - oy) * tile - rise); 
      
      // Fade out logic
      if (pct > 0.8) ctx.globalAlpha = 1 - (pct - 0.8) * 5;
      
      // OPTIMIZATION: Removed the black shadow text draw. 
      // It doubles the render cost. If visibility is an issue, 
      // use a darker background color or just keep it simple.
      
      ctx.fillStyle = ft.color;
      ctx.fillText(ft.text, sx, sy);
      
      ctx.globalAlpha = 1.0;
    });
  }

  // Smart Loop: Run if effects active OR player is still sliding
  const isMoving = (Math.abs(state.player.x - state.player.rx) > 0.01 || Math.abs(state.player.y - state.player.ry) > 0.01);
  
  state._animating = activeEffects || isMoving;
  if (state._animating) {
    requestAnimationFrame(draw);
  }
}




function updateBars(){
  document.querySelector('.bar.hp')?.classList.toggle('poison', !!state.player.poisoned); // <‚Äî add
  document.getElementById('hpText').textContent = state.player.hp + '/' + state.player.hpMax;
  document.getElementById('mpText').textContent = state.player.mp + '/' + state.player.mpMax;
  document.getElementById('hpFill').style.width = clamp((state.player.hp/state.player.hpMax)*100,0,100)+'%';
  document.getElementById('mpFill').style.width = clamp((state.player.mp/state.player.mpMax)*100,0,100)+'%';
  
  // --- NEW: Update Stamina Bar ---
  const stm = state.player.stamina || 0;
  const stmMax = state.player.staminaMax || 10;
  document.getElementById('stmText').textContent = stm + '/' + stmMax;
  document.getElementById('stmFill').style.width = clamp((stm/stmMax)*100, 0, 100)+'%';
  
  document.getElementById('levelChip').textContent = `Lvl ${state.player.level} ‚Äî ${state.player.xp}/${state.player.next}`;
  document.getElementById('floorChip').textContent = `Depth ${state.floor}`;
}

function currentBoss(){
  return state.enemies?.find(e => e && e.boss);
}

function updateBossHud(){
  const hud = document.getElementById('bossHud');
  if (!hud) return;

 // NEW: allow cutscenes to hide the boss bar even if a boss entity exists
  if (state._suppressBossHud) { hud.style.display = 'none'; return; }

  const b = currentBoss();

  if (!b){
    hud.style.display = 'none';
    return;
  }

  // Ensure boss has a max for the bar
  if (!Number.isFinite(b.hpMax)) b.hpMax = Math.max(b.hp|0, 1);

  document.getElementById('bossName').textContent =
    b.displayName || (b.type ? `${b.type} Boss` : 'Boss');

  const pct = clamp((b.hp / (b.hpMax||1))*100, 0, 100);
  document.getElementById('bossHpFill').style.width = pct + '%';
  document.getElementById('bossHpText').textContent = `${Math.max(0, b.hp|0)}/${b.hpMax|0}`;

  hud.style.display = 'block';
}

function unlockControls(src){
  state._inputLocked = false;
  state._suppressBossHud = false;
  updateBossHud?.();
  enemyStep?.();          // ‚Üê ADD: let enemies act after cutscenes
  draw?.();
}


function updateEquipUI(){
  const w=state.player.weapon;
  const showDur = Number.isFinite(w?.durMax);
  
  // --- NEW: Show Art Status ---
  let artStatus = "";
  if (state.player.artCooldown > 0) {
    artStatus = ` [Art: ${state.player.artCooldown}]`;
  } else {
    artStatus = ` [Art: Ready]`;
  }
  
  const nameTxt = (showDur ? `${w.name} (Dur ${w.dur}/${w.durMax})` : w.name) + artStatus;
  document.getElementById('equipName').textContent = nameTxt;

  // --- NEW: Calculate True Weapon Damage ---
  let effMin = w.min, effMax = w.max;
  if (state.floorEffect === 'AntiMagic') {
    effMin = Math.ceil(effMin * 1.5);
    effMax = Math.ceil(effMax * 1.5);
  } else if (state.floorEffect === 'ArcaneFlux') {
    effMin = Math.max(1, Math.ceil(effMin * 0.25));
    effMax = Math.max(1, Math.ceil(effMax * 0.25));
  }
  document.getElementById('equipAtk').textContent = `ATK: ${effMin}‚Äì${effMax}`;
  // ----------------------------------------

  const es = state.equippedSpell;
if (es){
  const st   = getSpellStats(es.name);
  const mp   = st.cost|0;
  
  // --- NEW: Calculate True Spell Damage ---
  let sMsg = "";
  if (es.name === 'Heal') {
     sMsg = `${es.name} (${mp} MP)`;
  } else if (state.floorEffect === 'AntiMagic') {
     sMsg = `${es.name} (SILENCED)`;
  } else {
     let sMin = st.min, sMax = st.max;
     if (state.floorEffect === 'ArcaneFlux') {
       sMin = Math.ceil(sMin * 1.5);
       sMax = Math.ceil(sMax * 1.5);
     }
     sMsg = `${es.name} (${mp} MP) ${sMin}‚Äì${sMax} Dmg`;
  }
  document.getElementById('equipSpell').textContent = sMsg;
  // ----------------------------------------
} else {
  document.getElementById('equipSpell').textContent = 'No Spells';
}


  // NEW: Bow (Loaded/Total)
  const loaded = state.player.bow.loaded|0;
  const total  = loaded + (state.inventory.arrows|0);
  document.getElementById('equipBow').textContent = `Bow (${loaded}/${total})`;

  const sh = state.player.shield;
  // Fix: Use the shield's own name property, defaulting to constant if missing
  const sName = sh ? (sh.name || SHIELD_NAME) : 'No Shield';
  
  const shText = sh
    ? `${sName} (Dur ${sh.dur}/${SHIELD_DUR})`
    : 'No Shield';
  document.getElementById('equipShield').textContent = shText;
}




function renderSkills(){
  const wrap = document.getElementById('skillsList'); 
  if (!wrap) return;
  wrap.innerHTML = '';

  for (const [type, s] of Object.entries(state.skills)){
    if (!s.shown) continue;

    const chip = document.createElement('button');
    chip.className   = 'skill';
    chip.type        = 'button';
    chip.dataset.type= type;
    chip.textContent = `${typeNice(type)} (${s.lvl}) ‚Äî ${s.xp}/${s.next}`;
    chip.onclick     = () => showSkillDetails(type);

    wrap.appendChild(chip);
  }
}

// ===== Skill Details UI =====
function ensureSkillInfoModal(){
  let m = document.getElementById('skillInfoModal');
  if (m) return m;

  m = document.createElement('div');
  m.id = 'skillInfoModal';
  m.className = 'modal';
  m.style.display = 'none';
  m.innerHTML = `
    <div class="sheet">
      <div class="row">
        <div class="title" id="skillInfoTitle">Skill Details</div>
        <button class="btn" id="btnCloseSkillInfo">Close</button>
      </div>
      <div id="skillInfoBody" style="margin:8px 0 6px;"></div>
    </div>`;
  document.body.appendChild(m);

  const close = () => {
    m.style.display = 'none';
    if (typeof setMobileControlsVisible === 'function') setMobileControlsVisible(true);
  };
  m.querySelector('#btnCloseSkillInfo')?.addEventListener('click', close);
  m.addEventListener('click', (e)=>{ if (e.target === m) close(); });

  return m;
}

function pct(x){ return Math.round(x*100) + '%'; }
function lvlOf(type){ return (state.skills?.[type]?.lvl || 1); }
function extraLevels(type){ return Math.max(0, lvlOf(type) - 1); }

// Use same formula as quirks: 2% per level beyond 1, hard-capped at 40%
function quirkChanceUI(type){
  const chance = 0.02 * extraLevels(type);
  return Math.min(0.40, chance);
}

function showSkillDetails(type){
  if (!type) return;
  const modal = document.getElementById('skillModal');
  const title = document.getElementById('skTitle');
  const msg   = document.getElementById('skMsg');
  if (!modal || !title || !msg) return;

  const s = (state.skills?.[type]) || { lvl:1 };
  const L = s.lvl|0;

  // helpers that mirror your existing formulas
  const accBonusPct = (t)=>{
    // non-magic: +2%/lvl after 1; magic: +1%/lvl after 1
    if (t === 'magic'){
      return Math.round(Math.max(0, (L || 1) - 1) * 1);  // 1% per level over 1
    }
    return Math.round(Math.max(0, (L || 1) - 1) * 2);    // 2% per level over 1
  };
  const magicPow  = () => Math.min(6, Math.max(0, Math.floor((L - 1) / 2)));
  const survRanks = () => Math.floor(L / 5);
  const survPct   = () => survRanks() * 5;

  // Show current hit chance (base + skill), clamped to 5‚Äì99%
  const accuracyLines = (t)=>{
    // Magic: mirror rollHitFor('magic')
    if (t === 'magic'){
      const tiers   = magicPowerBonus();      // same tiers used for damage
      const base    = 0.75;
      const bonus   = tiers * 0.02;          // +2% per 2 Magic levels
      const total   = Math.max(0.05, Math.min(0.99, base + bonus));
      const pct     = Math.round(total * 100);
      const basePct = Math.round(base * 100);
      const skillPct = Math.max(0, pct - basePct);
      return [
        `Hit Chance: ${pct}%`,
        `Base ${basePct}% + Skill ${skillPct}%`
      ];
    }

    // Weapons & bow: mirror rollHitFor(type) using baseAccuracy + accuracyBonusFromSkill
    const base  = baseAccuracy(t);
    const bonus = accuracyBonusFromSkill(t);
    const total = Math.max(0.05, Math.min(0.99, base + bonus));
    const pct   = Math.round(total * 100);
    const basePct  = Math.round(base * 100);
    const skillPct = Math.max(0, pct - basePct);
    return [
      `Hit Chance: ${pct}%`,
      `Base ${basePct}% + Skill ${skillPct}%`
    ];
  };

  // weapon quirk text builders (match your earlier weapon effects)
  const weaponLines = {
    two: () => [
      ...accuracyLines('two'),
      `Critical Hit Chance: ${accBonusPct('two')}%`,
      `Criticals deal 2√ó the rolled damage.`
    ],
    one: () => [
      ...accuracyLines('one'),
      `Follow-Up Chance: ${accBonusPct('one')}%`,
      `On proc, make an extra strike for normal damage.`
    ],
    spear: () => [
      ...accuracyLines('spear'),
      `Bleed Chance: ${accBonusPct('spear')}%`,
      `On proc, target suffers 1 damage for 5 ticks.`
    ],
    axe: () => [
      ...accuracyLines('axe'),
      `Cripple Chance: ${accBonusPct('axe')}%`,
      `On proc, target is slowed for 3 ticks.`
    ],
    hand: () => [
      ...accuracyLines('hand'),
      `Knockout Chance: ${accBonusPct('hand')}%`,
      `On proc, target can‚Äôt move or act for 3 ticks.`
    ],
    bow: () => [
      ...accuracyLines('bow'),
      `Also benefits from your Archery damage/range scaling.`
    ]
  };

  // non-weapon skills
  const nonWeaponLines = {
    magic: () => [
      ...accuracyLines('magic'),
      `Every 2 Magic levels increases spell damage and accuracy (up to ${magicPow()} bonus power).`
    ],
    lockpicking: () => {
      const bonusPct = Math.round(lockpickBonusFromSkill() * 100);
      return [
        `Success Bonus: +${bonusPct}% from skill (added to the lock‚Äôs base chance).`,
        `Each level after 1 grants +5% success.`
      ];
    },
    survivability: () => [
      `Damage Reduction: ${survPct()}% (gains 5% at lv 5,10,15,...)`,
      `Applied before rounding; damage is reduced and rounded up, never below 1.`
    ]
  };

  let lines;
  if (nonWeaponLines[type]) {
    lines = nonWeaponLines[type]();
  } else if (weaponLines[type]) {
    lines = weaponLines[type]();
  } else {
    lines = [`No details defined for "${type}".`];
  }

  title.textContent = (typeof typeNice === 'function' ? typeNice(type) : type);
  msg.innerHTML = `
    <div style="margin:6px 0 2px; opacity:.9">Level: <b>${L}</b></div>
    <ul style="margin:6px 0 0 16px; padding:0;">
      ${lines.map(t => `<li style="margin:4px 0">${t}</li>`).join('')}
    </ul>
  `;

  modal.style.display = 'flex';
}




// ====== Enemy Step (chase) ======
function neighbors4(x,y){ return [[1,0],[-1,0],[0,1],[0,-1]].map(([dx,dy])=>({x:x+dx,y:y+dy})) }
function clearStraightLine(a,b,c,d){
  // Only supports same row or same column LOS
  if (a!==c && b!==d) return false;
  const sx = Math.sign(c-a), sy = Math.sign(d-b);
  let x = a, y = b;
  // step UNTIL destination, checking blockers on the path
  while (x !== c || y !== d){
    x += sx; y += sy;
    if (!inBounds(x,y)) return false;
    const t = state.tiles[y][x];
    // walls (0) and CLOSED doors (2) block line of sight
    if (t === 0 || t === 2) return false;
  }
  return true;
}

// --- Footprint-aware helpers for big enemies (boss = 2x2) ---
function enemyFootprintMinDist(x, y, size){
  // min Manhattan distance from any tile in its footprint to the player
  let best = Infinity;
  for (let yy=0; yy<size; yy++){
    for (let xx=0; xx<size; xx++){
      best = Math.min(best, Math.abs((x+xx)-state.player.x) + Math.abs((y+yy)-state.player.y));
    }
  }
  return best;
}

// --- replace your whole enemyCanEnterSize with this ---
function enemyCanEnterSize(x, y, size, ignoreEnemy = null){
  for (let yy = 0; yy < size; yy++){
    for (let xx = 0; xx < size; xx++){
      const gx = x + xx, gy = y + yy;
      if (!inBounds(gx, gy)) return false;
      if (gx === state.player.x && gy === state.player.y) return false;

      const occ = enemyAt(gx, gy);           // may be self
      if (occ && occ !== ignoreEnemy) return false;

      const t = state.tiles[gy][gx];
      if (!(t === 1 || t === 4)) return false;
    }
  }
  return true;
}


// Greedy chase step (try axis that closes distance; then fallbacks)
function greedyStepToward(e){
  const size = e.size || 1;
  const canEnter = size>1 ? (x,y)=>enemyCanEnterSize(x,y,size,e) : (x,y)=>enemyCanEnter(x,y);

  const dx = Math.sign(state.player.x - e.x);
  const dy = Math.sign(state.player.y - e.y);

  const primaryFirst = (Math.abs(state.player.x - e.x) >= Math.abs(state.player.y - e.y))
    ? [[dx,0],[0,dy],[dx,dy],[dx,-dy],[-dx,dy]]
    : [[0,dy],[dx,0],[dx,dy],[dx,-dy],[-dx,dy]];

  const curD = size>1 ? enemyFootprintMinDist(e.x,e.y,size)
                      : Math.abs(e.x-state.player.x)+Math.abs(e.y-state.player.y);

  let equal = null;
  for (const [sx,sy] of primaryFirst){
    const nx = e.x+sx, ny = e.y+sy;
    if (!canEnter(nx,ny)) continue;
    const nd = size>1 ? enemyFootprintMinDist(nx,ny,size)
                      : Math.abs(nx-state.player.x)+Math.abs(ny-state.player.y);
    if (nd < curD) return {x:nx,y:ny, better:true};
    if (nd === curD) equal = {x:nx,y:ny, better:false};
  }
  return equal || null;
}

function bfsStepToward(e, maxSteps=48){
  const size = e.size || 1;
  const canEnter = size>1 ? (x,y)=>enemyCanEnterSize(x,y,size,e) : (x,y)=>enemyCanEnter(x,y);


  const startKey = e.x+','+e.y;
  const q = [{x:e.x,y:e.y}];
  const parent = new Map([[startKey, null]]);
  let foundKey = null;

  while (q.length && parent.size < 1200){
    const cur = q.shift();
    if (cur.x === state.player.x && cur.y === state.player.y){ foundKey = cur.x+','+cur.y; break; }
    for (const n of neighbors4(cur.x,cur.y)){
      if (!canEnter(n.x,n.y)) continue;
      const k = n.x+','+n.y;
      if (parent.has(k)) continue;
      parent.set(k, cur);
      q.push({x:n.x,y:n.y});
    }
    if (--maxSteps <= 0) break;
  }

  if (!foundKey){
    // choose reached node closest to player
    let bestK = null, bestD = Infinity;
    for (const [k] of parent){
      const [x,y] = k.split(',').map(Number);
      const d = Math.abs(x - state.player.x) + Math.abs(y - state.player.y);
      if (d < bestD){ bestD = d; bestK = k; }
    }
    if (!bestK || bestK === startKey) return null;
    foundKey = bestK;
  }

  // walk back one step from foundKey to first move from start
  let curK = foundKey, prev = parent.get(curK);
  while (prev && (prev.x+','+prev.y) !== startKey){
    curK = prev.x+','+prev.y;
    prev = parent.get(curK);
  }
  const [sx, sy] = curK.split(',').map(Number);
  if (sx === e.x && sy === e.y) return null;
  return { x:sx, y:sy };
}

// Small BFS to route around obstacles when greedy can't progress
function bfsStepToward(e, maxSteps=48){
  const size = e.size || 1;
  const canEnter = size>1 ? (x,y)=>enemyCanEnterSize(x,y,size,e) : (x,y)=>enemyCanEnter(x,y);

  const start = e.x+','+e.y;
  const q = [{x:e.x,y:e.y}];
  const parent = new Map([[start, null]]);
  let foundKey = null;

  while (q.length && parent.size < 1200){
    const cur = q.shift();
    const k = cur.x+','+cur.y;

    // stop early if we reached any tile adjacent (or best) to the player
    const d = size>1 ? enemyFootprintMinDist(cur.x,cur.y,size)
                     : Math.abs(cur.x - state.player.x) + Math.abs(cur.y - state.player.y);
    if (d <= 1){ foundKey = k; break; }

    for (const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
      const nx = cur.x+dx, ny = cur.y+dy;
      const nk = nx+','+ny;
      if (parent.has(nk)) continue;
      if (!canEnter(nx,ny)) continue;
      parent.set(nk, k);
      q.push({x:nx,y:ny});
      if (--maxSteps <= 0) break;
    }
    if (maxSteps <= 0) break;
  }

  if (!foundKey){
    // pick the explored node that minimized distance if none hit d<=1
    let bestKey = null, bestD = Infinity;
    for (const nk of parent.keys()){
      const [xx,yy] = nk.split(',').map(Number);
      const dd = size>1 ? enemyFootprintMinDist(xx,yy,size)
                        : Math.abs(xx - state.player.x) + Math.abs(yy - state.player.y);
      if (dd < bestD){ bestD = dd; bestKey = nk; }
    }
    foundKey = bestKey;
  }
  if (!foundKey) return null;

  // backtrack one step from foundKey toward start
  let stepKey = foundKey;
  while (stepKey && parent.get(stepKey) !== start){
    stepKey = parent.get(stepKey);
  }
  if (!stepKey || stepKey === start) return null;
  const [sx,sy] = stepKey.split(',').map(Number);
  return {x:sx,y:sy, better:true};
}


// remove one thing from player and return a descriptor (or null)
function goblinStealOne(){
  // priority: potion > tonic > lockpicks > one weapon stack
  if (state.inventory.potions>0){ state.inventory.potions--; return {kind:'potion', payload:1}; }
  if (state.inventory.tonics>0){ state.inventory.tonics--; return {kind:'tonic', payload:1}; }
  if (state.inventory.lockpicks>0){ state.inventory.lockpicks--; return {kind:'lockpicks', payload:1}; }
  const entries = Object.entries(state.inventory.weapons);
  if (entries.length){
    const [name,count] = entries[0];
    state.inventory.weapons[name] = Math.max(0, count-1);
    if (state.inventory.weapons[name]===0) delete state.inventory.weapons[name];
    return {kind:'weapon', payload:{name}};
  }
  return null;
}


// drop a stolen thing near (x,y) without overwriting stairs
function dropStolenNear(x, y, stolen){
  // If the tile is not stairs, prefer here; else try adjacent.
  const isStairs = inBounds(x,y) && state.tiles[y][x] === 4;

  const tryPlace = (tx, ty) => {
    if (!inBounds(tx,ty)) return false;
    // don‚Äôt place on stairs; only on floor with no enemy or pickup
    if (state.tiles[ty][tx] !== 1) return false;
    const k = key(tx,ty);
    if (state.pickups[k]) return false;
    if (enemyAt(tx,ty)) return false;
    state.pickups[k] = (stolen.kind === 'weapon')
      ? {kind:'weapon', payload: stolen.payload}
      : {kind: stolen.kind, payload: (stolen.payload||1)};
    state.tiles[ty][tx] = 5;
    return true;
  };

  if (!isStairs) {
    if (tryPlace(x,y)) return;
  }

  // try the four cardinals
  const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
  for (const [dx,dy] of dirs) {
    if (tryPlace(x+dx, y+dy)) return;
  }

  // last resort: find any free floor a few tiles away
  const spot = (typeof findFreeFloorTile === 'function') ? findFreeFloorTile(3) : null;
  if (spot) {
    tryPlace(spot.x, spot.y);
  }
}


let _hurtTO;
function flashDamage(){
  const f = document.getElementById('hurtFlash');
  if(!f) return;

  // cancel any in-progress fade so consecutive hits feel responsive
  if (_hurtTO) clearTimeout(_hurtTO);

  // pop to darker red and hold very briefly
  f.style.background = 'rgba(255,0,0,0.38)'; // slightly darker
  _hurtTO = setTimeout(()=>{
    f.style.background = 'rgba(255,0,0,0.0)'; // then fade via CSS
    _hurtTO = null;
  }, 90); // hold ~90ms before fading over 480ms
}
function flashEnemy(e, color='red', ms=100){
  e._flashColor = color;
  e._flashTime = Date.now() + ms;
  
  // Force the game to redraw after the flash time is up
  // This ensures the red/green tint disappears even if you don't move
  setTimeout(() => {
    if (typeof draw === 'function') draw();
  }, ms + 20);
}
// ===== Per-floor enemy templates =====
function floorEnemyKinds(){
  const f = state.floor | 0;
  const scale = 1 + Math.max(0, f - 1) * 0.12; // +12% per floor

  // base (floor 1) stats, then scale every floor
  const base = {
    Rat:      { hp: 4, atk:[1,2], xp: 3 },
    Bat:      { hp: 3, atk:[1,2], xp: 3 }, // Weak but heals
    Spider:   { hp: 5, atk:[2,3], xp: 4 }, // Slows you
    Slime:    { hp: 5, atk:[1,3], xp: 4 },
    Goblin:   { hp: 6, atk:[2,4], xp: 5 },
    Skeleton: { hp: 7, atk:[2,5], xp: 6 },
    Mage:     { hp: 8, atk:[3,6], xp: 7 }
  };

  // progressive availability
  const pool = [];
  if (f >= 1) pool.push('Rat');
  if (f >= 2) pool.push('Bat');    // Early unlock
  if (f >= 3) pool.push('Slime');
  if (f >= 4) pool.push('Spider'); // Mid-early unlock
  if (f >= 5) pool.push('Goblin');
  if (f >= 7) pool.push('Skeleton');
  if (f >= 8) pool.push('Mage');

  // build scaled kinds
  const kinds = pool.map(name=>{
    const b = base[name];
    return {
      type: name,
      hp: Math.max(1, Math.round(b.hp * scale)),
      atk: [
        Math.max(0, Math.floor(b.atk[0] * scale)),
        Math.max(1, Math.floor(b.atk[1] * scale))
      ],
      xp: Math.max(1, Math.round(b.xp * (1 + Math.max(0, f - 1) * 0.10)))

    };
  });

  return kinds;
}



// ===== Respawn helper =====
function tryRespawnOneEnemy(){
  if (!Array.isArray(state.rooms) || !state.rooms.length) return;
  if (!Array.isArray(state.enemies)) state.enemies = [];
  const cap = (typeof state.enemyCap === 'number') ? state.enemyCap : Infinity;
if (state.enemies.length >= cap) return;

  // pick a random non-start room
  let guard = 0;
  while (guard++ < 400) {
    const r = state.rooms[rand(1, state.rooms.length - 1)];
    if (!r) continue;
    const x = rand(r.x + 1, r.x + r.w - 2);
    const y = rand(r.y + 1, r.y + r.h - 2);

    // safe tile, not near player, no enemy sitting there
    if (state.tiles?.[y]?.[x] !== 1) continue;
    if (dist(x, y, state.player.x, state.player.y) <= 6) continue;
    if (enemyAt(x, y)) continue;

    // SAFE ROOM: block respawns
if (state.safeRect){
  const r = state.safeRect;
  if (x >= r.x && x < r.x+r.w && y >= r.y && y < r.y+r.h) continue;
}


    // pick a kind similar to your floor generation
    const kinds = floorEnemyKinds();
    const k = kinds[Math.floor(Math.random() * kinds.length)];

    const e = { x, y, type: k.type, hp: k.hp, atk: [...k.atk], xp: k.xp };
    if (k.type === 'Rat')      e.poisonChance = 0.20;
    if (k.type === 'Goblin') { e.fast = true; e.stealChance = 0.20; }
    if (k.type === 'Slime')  { e.slow = true; e._skipMove = false; }
    if (k.type === 'Skeleton'){ e._revived = false; }
    if (k.type === 'Mage')   { e.ranged = true; e.range = 3; }

    state.enemies.push(e);
    break;
  }
}

function triggerGameOver(){
  if (state.gameOver) return;
  state.gameOver = true;
  
  const m = document.getElementById('gameOverModal');
  if (m) {
    m.style.display = 'flex';
    
    // KH REFERENCE: Rare death message
    const title = m.querySelector('.title');
    if (title) {
        if (Math.random() < 0.10) { 
            title.textContent = "Your heart has been lost...";
            title.style.color = "#ff0000"; // Optional: make it red
        } else {
            title.textContent = "Game Over";
            title.style.color = ""; // Reset color
        }
    }
  }
  
  state.run.ended = true;
  stopRunTimerFreeze(); 
  if (typeof openScoreEntry === 'function') openScoreEntry();
}


function enemyStep(){
  // --- NEW: Stamina Regen ---
  // If we just sprinted, skip the regen for this turn
  if (state._skipStaminaRegen) {
    state._skipStaminaRegen = false; // Reset flag, do not recover
} 
  else if (state.player.stamina < state.player.staminaMax) {
    state.player.stamina++;
    updateBars();
  }

  // (Passive MP Regen REMOVED)

  // --- NEW: Cursed Weapon Tick ---
  const cw = state.player.weapon;
  if (cw && cw.cursed) {
    if (cw.curseType === 'blood') {
      // 15% chance per turn to lose 1 HP
      if (Math.random() < 0.15) {
        state.player.hp = Math.max(1, state.player.hp - 1);
        spawnFloatText("-1 HP", state.player.x, state.player.y, '#ef4444');
        log("The cursed blade drinks your blood.");
        updateBars();
      }
    } else if (cw.curseType === 'greed') {
      // 20% chance per turn to lose 1-2 Gold
      if (Math.random() < 0.20 && state.inventory.gold > 0) {
        const loss = rand(1,2);
        state.inventory.gold = Math.max(0, state.inventory.gold - loss);
        spawnFloatText("-" + loss + "g", state.player.x, state.player.y, '#facc15');
        log("The cursed blade consumes your wealth.");
      }
    }
  }
  // ------------------------------

  // --- NEW: Cooldown Tick ---
  if (state.player.artCooldown > 0) {
    state.player.artCooldown--;
    
    // FIX: Update UI every turn so the number visibly counts down (9..8..7..)
    updateEquipUI();

    if (state.player.artCooldown === 0) {
      log("Weapon Art ready!");
      SFX.pickup(); // Chime sound
    }
  }
  // -------------------------

// === player status that ticks once per enemy phase ===
  // --- NEW: Cleric Blessing Tick ---
  if (state.player.blessTicks > 0) {
    state.player.blessTicks--;
    if (state.player.blessTicks === 0) log("The holy blessing fades.");
  }
  // --------------------------------

  if (state.player.poisoned && state.player.poisonTicks > 0){
    state.player.poisonTicks--;
    const t = state.player.poisonTicks;
    if (t > 0 && (t % 2 === 0)){
      // Scale: 1 dmg base + 1 per 15 floors (F1=1, F15=2, F30=3)
      const p = damageAfterDR(1 + Math.floor(state.floor/15));
      if (p > 0){
        state.player.hp = clamp(state.player.hp - p, 0, state.player.hpMax);
        flashDamage();
        SFX.poisonTick?.();
        log(`Poison burns you for ${p}.`);
        updateBars();
        if (state.player.hp <= 0){ triggerGameOver(); return; }
      } else {
        log('Your Survivability shrugs off the poison.');
      }
    }
    if (t === 0){ state.player.poisoned = false; log('The poison fades.'); }
  }

if ((state.player.bow?.loaded|0) === 0 && (state.inventory.arrows|0) > 0){
    state.inventory.arrows--;
    state.player.bow.loaded = 1;
    log('You notch a new arrow.');
    updateEquipUI?.();
  }

  // --- NEW: Volatile Aether Ticks ---
  if (state.explosions && state.explosions.length) {
    // Iterate backwards to safely remove
    for (let i = state.explosions.length - 1; i >= 0; i--) {
      const bomb = state.explosions[i];
      bomb.timer--;
      
      if (bomb.timer > 0) {
        spawnFloatText(bomb.timer + "...", bomb.x, bomb.y, '#f97316');
      } else {
        // EXPLODE
        state.explosions.splice(i, 1);
        spawnParticles(bomb.x, bomb.y, '#f97316', 8);
        SFX.weaponBreak(); // Explosion sound
        
        // 3x3 AoE
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            const tx = bomb.x + dx, ty = bomb.y + dy;
            
            // Hit Player
            if (tx === state.player.x && ty === state.player.y) {
              const dmg = damageAfterDR(10);
              state.player.hp -= dmg;
              flashDamage();
              log(`Aether explosion hits you for ${dmg}!`);
            }
            
            // Hit Enemy
            const e = enemyAt(tx, ty);
            if (e) {
              e.hp -= 10;
              spawnFloatText(10, e.x, e.y, '#f97316');
              if (e.hp <= 0) {
                 // Chain reaction: Spawn new bomb on death
                 state.explosions.push({ x: e.x, y: e.y, timer: 2 }); // 2-turn fuse for chains
                 spawnFloatText("2...", e.x, e.y, '#f97316');

                 state.enemies = state.enemies.filter(x => x !== e);
                 state.run.kills++;
              }
            }
          }
        }
      }
    }
  }
  // ----------------------------------

// === each enemy acts ===
  for (const e of state.enemies){

    // 1. FIXED: Calculate distance inline (Math.abs) and use unique name (d2p) to avoid errors
    const d2p = Math.abs(e.x - state.player.x) + Math.abs(e.y - state.player.y);

    // --- NEW: Shadow / Clone Logic ---
    if (e.type === 'Clone' || e.type === 'Shadow') {
       
       // A. WEAPON MIRRORING (Passive Melee Only)
       const pWep = state.player.weapon;
       
       // If player changed melee weapon, copy it (reset range to 1)
       if (e._lastWep !== pWep.name) {
          e._lastWep = pWep.name;
          e.range = 1;
          e.ranged = false; 
          // Only log if it's a significant shift (not just init)
          if(e._lastWep) spawnFloatText("SHIFT", e.x, e.y, '#a78bfa');
       }

       // B. ACTION MIMICRY (Active)
       if (state.lastPlayerAction) {
          const act = state.lastPlayerAction;
          let didMimic = false; // <--- Track if we actually did something

          // 1. BOW SHOT MIMICRY
          if (act.type === 'bow') {
             e.range = 5;
             e.ranged = true;
             spawnFloatText("DRAW!", e.x, e.y, '#a78bfa');
             log(`The Shadow pulls a bow from the void!`);
             
             spawnProjectileEffect({
                kind: 'arrow', color: '#a78bfa',
                fromX: e.x, fromY: e.y, toX: state.player.x, toY: state.player.y,
                onDone: () => {
                   const dmg = rand(2, 5); 
                   state.player.hp = clamp(state.player.hp - dmg, 0, state.player.hpMax);
                   flashDamage();
                   spawnFloatText(dmg, state.player.x, state.player.y, '#a78bfa');
                   updateBars();
                }
             });
             didMimic = true;
          }
          
          // 2. HEAL MIMICRY
          else if (act.type === 'heal') {
             const healAmt = Math.max(1, Math.ceil(act.amount * 0.25));
             e.hp = Math.min(e.hp + healAmt, e.hpMax);
             spawnFloatText("+" + healAmt, e.x, e.y, '#0f0');
             log("The Shadow mocks your weakness and heals!");
             flashEnemy(e, 'green');
             didMimic = true;
          }
          
          // 3. SPELL ECHO
          else if (act.type === 'spell') {
             spawnFloatText(act.name.toUpperCase(), e.x, e.y, '#a78bfa');
             log(`The Shadow echoes your ${act.name}!`);
             
             spawnProjectileEffect({
                kind: 'magic', element: 'Shadow', color: '#a78bfa',
                fromX: e.x, fromY: e.y, toX: state.player.x, toY: state.player.y,
                onDone: () => {
                   const dmg = rand(3, 6);
                   state.player.hp = clamp(state.player.hp - dmg, 0, state.player.hpMax);
                   flashDamage();
                   spawnFloatText(dmg, state.player.x, state.player.y, '#a78bfa');
                   updateBars();
                }
             });
             didMimic = true;
          }
          
          // 4. WEAPON ART ECHO
          else if (act.type === 'art') {
             spawnFloatText(act.name.toUpperCase() + "!", e.x, e.y, '#ff0000');
             log(`The Shadow mimics your ${act.name}!`);
             const dmg = rand(5, 8);
             state.player.hp = clamp(state.player.hp - dmg, 0, state.player.hpMax);
             flashDamage();
             updateBars();
             didMimic = true;
          }

          // <--- CRITICAL FIX: STOP TURN IF MIMIC HAPPENED ---
          if (didMimic) {
             state.lastPlayerAction = null; 
             continue; // Forces the game to skip the "Zap" or "Attack" logic below
          }
       }
    }
    // ---------------------------------
    
    // 1. RECOVERY PHASE (The "Rest")
    if (e.recovering) {
      e.recovering = false; // Clear flag, act next turn
      spawnFloatText("Vulnerable!", e.x, e.y, '#9ca3af');
      continue; // Skip turn entirely
    }

    // 2. CHARGE EXECUTION (The "Crush")
    if (e.charging) {
      e.charging = false; 
      e.recovering = true; // <--- Restore: Boss must rest next turn
      
      // Check adjacency
      let adj = false;
      const s = e.size || 1;
      for (let yy=0; yy<s; yy++){
        for (let xx=0; xx<s; xx++){
          if (Math.abs((e.x+xx) - state.player.x) + Math.abs((e.y+yy) - state.player.y) === 1) adj = true;
        }
      }
      
      if (adj) {
        const dmg = rand(e.atk[1] * 2, e.atk[1] * 3); // Massive Dmg
        state.player.hp = clamp(state.player.hp - dmg, 0, state.player.hpMax);
        flashDamage();
        spawnFloatText("CRUSH: " + dmg, state.player.x, state.player.y, '#ff0000');
        log(`The ${e.type} CRUSHES you for ${dmg}!`);
        updateBars();
        if (state.player.hp <= 0){ triggerGameOver(); return; }
      } else {
        log(`The ${e.type} swings wildly and misses!`);
        spawnFloatText("Miss!", e.x, e.y, '#9ca3af');
      }
      continue; 
    }

   // --- NEW: Mad King Summon Ability ---
    // If it's the Mad King, not charging, and player is far away (range > 4)
    if (e.type === 'Mad King' && !e.charging && d2p > 4 && Math.random() < 0.20) {
       // Try to spawn a Skeleton nearby
       const spot = neighbors4(e.x, e.y).find(n => state.tiles[n.y]?.[n.x] === 1 && !enemyAt(n.x, n.y));
       if (spot) {
         spawnFloatText("ARISE!", e.x, e.y, '#a78bfa');
         // Spawn a weak "Royal Guard" (Skeleton)
         state.enemies.push({
           type: 'Skeleton', x: spot.x, y: spot.y, 
           hp: 4, atk: [2,3], xp: 0, // Low HP/XP minions
           _revived: true // Don't let them revive, keep clutter down
         });
         spawnParticles(spot.x, spot.y, '#a78bfa', 8);
         log('The Mad King summons a Royal Guard!');
         continue; // Use turn
       }
    }
    // ------------------------------------

// 3. START CHARGE (15% Chance if Player is close)
    // "Sprinkled in" - mostly they will skip this and do normal attacks below
    if ((e.boss || e.elite) && !e.charging && !e.recovering && d2p <= 2 && Math.random() < 0.15) {
       e.charging = true;
       log(`The ${e.type} begins to charge a massive attack!`);
       spawnFloatText("‚ö†Ô∏è CHARGING", e.x, e.y, '#ffae00');
       continue; // Skip normal movement
    }
    // -------------------------------------

    const s = e.size || 1;

    // status effects on the enemy
    if (e.bleedTicks > 0){
      e.bleedTicks--;
      e.hp -= (e.bleedDmg|0) || 1;
      if (e.hp <= 0){
        // standard kill path
        state.enemies = state.enemies.filter(x=>x!==e);
        state.run.kills = (state.run.kills|0) + 1;
        SFX.kill?.();
        continue;
      }
    }
    if (e.stunTicks > 0){ e.stunTicks--; continue; }

    // ‚Äúslow‚Äù = act every other enemy phase
    if (e.slowTicks > 0){
      e._skipMove = !e._skipMove;
      if (e._skipMove){ e.slowTicks--; continue; }
      e.slowTicks--;
    }

// how many steps can this enemy attempt this phase
let moves = 1;
if (e.fast) moves = 2;
if (e.slow){ e._skipMove = !e._skipMove; if (e._skipMove) moves = 0; }

const eRange = e.range || 1; 
const distToPlayer = dist(e.x, e.y, state.player.x, state.player.y);

// Bloodhunt (Endless only): if the enemy is outside your vision radius, it gets +1 move.
if (state.gameMode !== 'classic' && state.floorEffect === 'Bloodhunt') {
  const rad = state.player.tempVisionRange || state.fovRadius;
  if (distToPlayer > rad) moves += 1;
}


// If enemy is ranged (range > 1) AND is currently within attack range 
// AND is NOT adjacent to the player (dist > 1) 
if (eRange > 1 && distToPlayer <= eRange && distToPlayer > 1) {
    // Halt movement to maintain the optimal firing distance.
    moves = 0; 
    // We still allow 'fast' enemies (like Goblins) to keep moving to prevent
    // them from stacking up right outside their attack range.
    if (e.fast) moves = 1; 
}


    // helper that respects 2√ó2 bodies AND ignores the mover itself
const canEnterPoint = (x, y) => {
  return (s > 1)
    ? enemyCanEnterSize(x, y, s, e)   // ‚Üê pass e so 2√ó2 doesn‚Äôt collide with itself
    : enemyCanEnter(x, y);
};

    // Mage: if straight LOS and in range, cast instead of moving
const manhattan = Math.abs(e.x - state.player.x) + Math.abs(e.y - state.player.y);
if (e.ranged && s === 1 && manhattan > 1 && manhattan <= (e.range||3) &&
(e.x === state.player.x || e.y === state.player.y) &&
clearStraightLine(e.x, e.y, state.player.x, state.player.y)) {

  let dmgRoll = rand(e.atk[0], e.atk[1]);
  if (state.gameMode !== 'classic' && state.floorEffect === 'Bloodhunt'){
    dmgRoll = Math.max(1, Math.round(dmgRoll * 1.20));
  }

  const dmg = damageAfterDR(dmgRoll);
  SFX.rangedZap?.();
  state.player.hp = clamp(state.player.hp - dmg, 0, state.player.hpMax);
  flashDamage();
  log(`${e.type} zaps you from afar for ${dmg}.`);
  updateBars();
  if (state.player.hp <= 0){ triggerGameOver(); return; }
  continue; // mage ends turn with the cast
}

    // If adjacent to ANY tile of a multi-tile enemy, do a melee hit
let adjacent = false;
for (let yy=0; yy<s && !adjacent; yy++){
  for (let xx=0; xx<s && !adjacent; xx++){
    if (Math.abs((e.x+xx) - state.player.x) + Math.abs((e.y+yy) - state.player.y) === 1){
      adjacent = true;
    }
  }
}

if (adjacent){
  
  // --- NEW: Enemy Accuracy Check ---
  // Base 85% accuracy. Bosses/Elites get 95%.
  const accuracy = (e.boss || e.elite) ? 0.95 : 0.85;
  
  if (Math.random() > accuracy) {
     spawnFloatText("Miss", state.player.x, state.player.y, '#9ca3af');
     log(`The ${e.type} attacks but misses you.`);
     continue; // Skip the rest of the attack logic
  }
  // ---------------------------------

  let dmgRoll = rand(e.atk[0], e.atk[1]);
  if (state.gameMode !== 'classic' && state.floorEffect === 'Bloodhunt'){
    dmgRoll = Math.max(1, Math.round(dmgRoll * 1.20));
  }

  const dmg = damageAfterDR(dmgRoll);
  state.player.hp = clamp(state.player.hp - dmg, 0, state.player.hpMax);
  flashDamage();
  SFX.enemyHit?.();
  log(`${e.type} hits you for ${dmg}.`);
  updateBars();
  if (state.player.hp <= 0){ triggerGameOver(); return; }


      // on-hit poison (rats, etc.)
      if (e.poisonChance && Math.random() < e.poisonChance){
        if (!state.player.poisoned) log('You are poisoned!');
        state.player.poisoned = true;
        state.player.poisonTicks = Math.max(state.player.poisonTicks|0, 15);
      }

      // BAT: Vampiric (heals dmg dealt)
      if (e.type === 'Bat' && dmg > 0) {
        // Nerf: Bosses only heal 33% of damage dealt, regular bats 100%
        const ratio = (e.boss || e.elite) ? 0.33 : 1.0; 
        const healAmt = Math.max(1, Math.floor(dmg * ratio));

        const oldHp = e.hp;
        e.hp = Math.min(e.hp + healAmt, (e.hpMax || 999));
        if (e.hp > oldHp) {
            flashEnemy(e, 'green');
            if (e.boss) spawnFloatText("+" + healAmt, e.x, e.y, '#0f0'); // Visual feedback
        }
      }

      // SPIDER: Web/Slow (100% chance or adjust as needed)
      if (e.type === 'Spider') {
         // Apply slow logic. We can reuse the player.poisonTicks mechanism or add a new one.
         // Let's add a simple temporary slow to the player state if not present.
         if (!state.player.slowed) {
             state.player.slowed = true;
             state.player.slowTicks = 5; // 5 steps
             log('The Spider webs you! (Slowed)');
         } else {
             state.player.slowTicks = Math.max(state.player.slowTicks, 5);
         }
      }

      // Goblins: chance to steal on hit
      if (e.type === 'Goblin' &&
          e.stealChance &&
          typeof goblinStealOne === 'function' &&
          Math.random() < e.stealChance) {

        const stolen = goblinStealOne();
        if (stolen){
          // Support both single and multi-steal for compatibility
          if (!e.stolenItems) e.stolenItems = [];
          e.stolenItems.push(stolen);

          // Keep the older single-slot field around too
          if (!e.stolen) e.stolen = stolen;

          log('The Goblin steals something from you!');
          if (typeof updateInvBody === 'function') updateInvBody();
        }
      }

      // melee ends their action; no follow-up move this tick
      continue;
    }


// Not adjacent ‚Üí try to move up to `moves` steps using greedy‚ÜíBFS (size-aware)
for (let step = 0; step < moves; step++){
  // 1) quick greedy step
  const g = greedyStepToward?.(e);
  if (g && canEnterPoint(g.x, g.y)) { e.x = g.x; e.y = g.y; continue; }

  // 2) short BFS (bigger budget for bosses / bigger maps)
  const b = bfsStepToward?.(e, e.boss ? 160 : 96);
  if (b && canEnterPoint(b.x, b.y)) { e.x = b.x; e.y = b.y; continue; }

    // 3) Fallback: take any passable neighbor that most reduces Manhattan distance
  let best = null, bestD = Infinity;
  for (const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
    const nx = e.x + dx, ny = e.y + dy;
    if (!canEnterPoint(nx, ny)) continue;
    const d = Math.abs(nx - state.player.x) + Math.abs(ny - state.player.y);
    if (d < bestD){ bestD = d; best = {x:nx,y:ny}; }
  }
  if (best){ e.x = best.x; e.y = best.y; continue; }

  // truly boxed in
  break;
}



  }

  // FORCE CLEAR ACTION: Prevents Shadow from mimicking the same arrow on the next turn (e.g. during a Sprint)
  state.lastPlayerAction = null; 

  // === lightweight enemy respawn pacing ===
  // Only respawn on non-boss floors so boss fights stay clean
  if (!state.gameOver && (state.floor % 10 !== 0)) {
    state.respawnTick = (state.respawnTick | 0) + 1;
    if (state.respawnTick >= (state.respawnEvery | 0)) {
      state.respawnTick = 0;
      tryRespawnOneEnemy();
    }
  }
}



// ===== Depth 50 Two-Phase Boss: Cutscene + Helpers =====

// Ensure flags container exists
state.flags = state.flags || {};

// tiny async helpers
const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

// simple black fade overlay (separate from descend's)
function ensureCutFade(){
  let fx = document.getElementById('cutFade');
  if (!fx){
    const wrap = document.getElementById('cw') || document.body;
    fx = document.createElement('div');
    fx.id = 'cutFade';
    Object.assign(fx.style, {
      position:'absolute', left:0, top:0, right:0, bottom:0,
      background:'#000', opacity:'0', pointerEvents:'none',
      zIndex:'20', transition:'opacity 320ms ease-in-out'
    });
    wrap.appendChild(fx);
  }
  return fx;
}

async function fadeToBlack(durMs=320){ const fx = ensureCutFade(); fx.style.opacity='1'; await sleep(durMs); }
async function fadeFromBlack(durMs=320){ const fx = ensureCutFade(); fx.style.opacity='0'; await sleep(durMs); }

// quick white flash overlay (for the triple flash)
function ensureWhiteFlash(){
  let f = document.getElementById('whiteFlash');
  if (!f){
    const wrap = document.getElementById('cw') || document.body;
    f = document.createElement('div');
    f.id = 'whiteFlash';
    Object.assign(f.style, {
      position:'absolute', left:0, top:0, right:0, bottom:0,
      background:'#fff', opacity:'0', pointerEvents:'none',
      zIndex:'19', transition:'opacity 120ms ease-in-out'
    });
    wrap.appendChild(f);
  }
  return f;
}
async function flashWhite(times=1, gapMs=220){
  const f = ensureWhiteFlash();
  for (let i=0;i<times;i++){
    f.style.opacity='1'; await sleep(90);
    f.style.opacity='0'; await sleep(gapMs);
  }
}

// move player one step even while inputs are locked (no enemy turn)
function forceStep(dx,dy){
  const nx = state.player.x + dx, ny = state.player.y + dy;
  if (!inBounds(nx,ny)) return false;
  if (state.tiles[ny][nx] === 0) return false; // walls

  // NEW: block NPC tiles here too
  if (isMerchantTile(nx, ny)) return false;
  if (isBlacksmithTile(nx, ny)) return false;
  if (isJesterTile(nx, ny)) return false;
  if (isCartographerTile(nx, ny)) return false;

  state.player.x = nx; state.player.y = ny;
  if (SFX?.step) SFX.step();
  draw();
  return true;
}


// Find a floor cell ~5 tiles to the right (fallback left) on same row
function findFiveAway(px, py){
  const tryOffsets = [5, -5, 4, -4, 3, -3];
  for (const off of tryOffsets){
    const tx = clamp(px + off, 0, state.size.w - 1);
    if (inBounds(tx,py) && state.tiles[py][tx] === 1) return {x:tx, y:py};
  }
  return {x:clamp(px+3,0,state.size.w-1), y:py};
}

// Build the phase-1 boss (Clone) at x,y; size 1 (same as player)
function makeCloneBoss(x, y){
  const f = state.floor | 0;

  // --- same scaling as other bosses/enemies ---
  const scale    = 1 + Math.max(0, f - 1) * 0.12;        // +12% per floor
  const bossBump = (f % 10 === 0) ? 0.25 : 0;             // +25% on boss floors
  const hpBase   = Math.round((24 + 4 * f) * (scale + bossBump));

  // Use strongest floor mob as ATK baseline, like your other bosses do
  const kinds = floorEnemyKinds();
  const base  = kinds[kinds.length - 1] || { atk:[3,6] };
  const atkMin = base.atk[0] + Math.floor(f / 3);
  const atkMax = base.atk[1] + Math.floor(f / 2);

  return {
    type: 'Clone',
    displayName: 'Your Shadow',
    x, y,
    hp: hpBase, hpMax: hpBase,            // ‚Üê identical HP scaling to other bosses
    atk: [atkMin, atkMax],
    xp: Math.round(60 * (1 + Math.max(0, f - 1) * 0.10)),
    boss: true,
    size: 1,
    tint: 'grayscale(1) brightness(0.9) contrast(1.2)'
  };
}

// Build the phase-2 boss (Mad King) at x,y; slightly tougher than the Clone
function makeMadKing(x, y){
  const f = state.floor | 0;

  // --- same scaling as other bosses/enemies ---
  const scale    = 1 + Math.max(0, f - 1) * 0.12;
  const bossBump = (f % 10 === 0) ? 0.25 : 0;
  const hpBase   = Math.round((24 + 4 * f) * (scale + bossBump));

  const kinds = floorEnemyKinds();
  const base  = kinds[kinds.length - 1] || { atk:[3,6] };
  const atkMin = base.atk[0] + Math.floor(f / 2);   // a touch meaner than Clone
  const atkMax = base.atk[1] + Math.floor((2 * f) / 3);

  const kingHp = Math.round(hpBase * 1.25);         // phase 2 gets +25% HP

  return {
    type: 'Mad King',
    displayName: 'The Mad King',
    x, y,
    hp: kingHp, hpMax: kingHp,
    atk: [atkMin, atkMax],
    xp: Math.round(100 * (1 + Math.max(0, f - 1) * 0.10)),
    boss: true,
    size: 1,
    tint: 'sepia(0.2) saturate(1.15) brightness(1.05)'
  };
}



// Depth 50 ‚Äî Intro sequence
async function runDepth50Intro(){
  state.flags ||= {};
  if (state.flags.depth50IntroRunning || state.flags.depth50IntroDone) return; // re-entry guard
  state.flags.depth50IntroRunning = true;

  state._suppressBossHud = true;
  state._inputLocked = true;
  if (typeof stopBgm === 'function') stopBgm();

  try {
    // Walk player 5 tiles to the right (slower)
    for (let i=0;i<5;i++){ if (!forceStep(1,0)) break; await sleep(160); }

    // Shadow appears underfoot, then glides 5 to the right
    const sh = { type:'Shadow', x:state.player.x, y:state.player.y, hp:1, boss:false, size:1, tint:'brightness(0.15) saturate(0.8)', _scene:true, static:true };
    state.enemies.push(sh); draw();
    const to = findFiveAway(sh.x, sh.y);
    while (sh.x < to.x){ sh.x++; draw(); await sleep(160); }

    // Triple white flash, then the clone pops in (size 1 ‚Äî same as player)
    await flashWhite(3, 260);
    const clone = makeCloneBoss(sh.x, sh.y);
    state.enemies.push(clone); draw();

    // Player advances this line
    playNpcDialogue(NPC_DIALOGUE_URLS.shadow.intro); // <--- VOICE ADDED
    await say('So you‚Äôve finally made it. This is where your journey ends.');
    await say('Submit to the darkness!');  // click to dismiss

    // Cut to black, remove shadow, start boss music, fade back
    await fadeToBlack(360);
    state.enemies = state.enemies.filter(e => e !== sh);
    if (typeof setBgmUrl === 'function') setBgmUrl(BOSS1_BGM_URL);
    await fadeFromBlack(360);

    forceBossHud();                      // show bar now
  } finally {
    state.flags.depth50IntroDone = true;
    state.flags.depth50IntroRunning = false;
    unlockControls('intro');
  }
}


// Depth 50 ‚Äî Phase 2 transition (called when Clone hits 0 HP)
async function runDepth50Phase2(deadClone){
  state.flags ||= {};
  if (state.flags.depth50Phase2Running || state.flags.depth50Done) return;
  state.flags.depth50Phase2Running = true;

  state._inputLocked = true;
  state._suppressBossHud = true;

  try {
    updateBossHud?.();                   // hide HUD under black
    await fadeToBlack(900);
    state.enemies = state.enemies.filter(e => e !== deadClone);

    // Place 1√ó1 clone 5 tiles away for the line (while still black)
const far = findFiveAway(state.player.x, state.player.y);
const remnant = makeCloneBoss(far.x, far.y);
remnant.size = 1; remnant.boss = false; remnant.hp = remnant.hpMax = 1;
state.enemies.push(remnant);

// draw while black so the ‚Äúmove‚Äù happens during the fade
    draw?.();
    await fadeFromBlack(360);

    playNpcDialogue(NPC_DIALOGUE_URLS.shadow.defeat); // <--- VOICE: Shadow dying
    await say('No! This cannot be!');

    // Remove remnant ‚Üí triple flash ‚Üí hooded appears
    state.enemies = state.enemies.filter(e => e !== remnant); draw();
    await flashWhite(3, 260);
    const hood = { type:'Hooded', x:far.x, y:far.y, hp:1, size:1, _scene:true, static:true };
    state.enemies.push(hood); draw();

    playNpcDialogue(NPC_DIALOGUE_URLS.madking.intro); // <--- VOICE: King appears
    await say("You‚Äôve come this far, and yet you understand nothing.");
    await say('Fine, I will be your opponent.');  // click to dismiss

    // Immediately swap to crowned king
    await fadeToBlack(360);               // cut to black
state.enemies = state.enemies.filter(e => e !== hood);
const king = makeMadKing(far.x, far.y);   // ‚Üê fix bad arg
state.enemies.push(king);

// heal + music while still black
state.player.hp = state.player.hpMax;
state.player.mp = state.player.mpMax;
updateBars?.();
if (typeof setBgmUrl === 'function') setBgmUrl(BOSS2_BGM_URL);

// draw the King frame while black so he‚Äôs ready on reveal
draw?.();

await fadeFromBlack(360);

// now reveal the bar with the correct sprite on screen
state._suppressBossHud = false;
updateBossHud?.();
draw?.();
                      // show bar now
  } finally {
    state.flags.depth50Phase2 = true;
    state.flags.depth50Phase2Running = false;
    unlockControls('phase2');
  }
}



// Depth 50 ‚Äî Outro on Mad King death
async function runDepth50Outro(deadKing){
  state.flags ||= {};
  if (state.flags.depth50OutroRunning || state.flags.depth50Done) return;
  state.flags.depth50OutroRunning = true;

  state._inputLocked = true;
  state._suppressBossHud = true;

    updateBossHud?.();                  // ‚Üê ADD THIS: hide the bar immediately


  try {
    await fadeToBlack(260);
    const far = findFiveAway(state.player.x, state.player.y);
    deadKing.x = far.x; deadKing.y = far.y;
    if (!state.enemies.includes(deadKing)) state.enemies.push(deadKing);

    await fadeFromBlack(260);
    
    playNpcDialogue(NPC_DIALOGUE_URLS.madking.defeat); // <--- VOICE ADDED
    await say('Very well, you may have bested me. But be warned there are even worse things deeper down in the dungeon.');

    await fadeToBlack(260);
    state.enemies = state.enemies.filter(e => e !== deadKing);

if (state.gameMode === 'classic') {
  // No stairs ‚Äî unlock Endless
  localStorage.setItem('endlessUnlocked', '1');
  
  // --- FIX: Finalize Run Stats ---
  state.gameOver = true;       // Stop game loop/inputs
  state.run.ended = true;      // Flag run as complete
  stopRunTimerFreeze();        // Lock the timer
  // -----------------------------

  if (typeof window.openModal === 'function') {
    window.openModal('#classicClearModal');
  } else {
    const m = document.getElementById('classicClearModal');
    if (m){ m.style.display = 'flex'; document.body.classList.add('noscroll'); }
  }
} else {
  // Endless or anything else: drop stairs as usual
  state.tiles[far.y][far.x] = 4;
  SFX?.bossDown?.();
}

await fadeFromBlack(260);

  } finally {
    state.flags.depth50Done = true;
    state.flags.depth50OutroRunning = false;
    unlockControls('outro');
  }
}



// ====== Gameplay ======
function collectIfPickup(){
  const kxy=key(state.player.x,state.player.y);
  if(state.tiles[state.player.y][state.player.x]===5 && state.pickups[kxy]){
    const it=state.pickups[kxy];
        if(it.kind==='weapon'){
          
      // --- NEW: Check Category Limit ---
      const wType = getWeaponType(it.payload.name);
      const curCount = countWeaponsInCategory(wType);
      
      if (curCount >= MAX_WEAPON_CAT) {
         // Trigger Swap UI
         openWeaponSwapModal(it.payload, kxy, state.player.x, state.player.y);
         return; // STOP pickup
      }
      // ---------------------------------

        SFX.pickup();
      state.inventory.weapons[it.payload.name]=(state.inventory.weapons[it.payload.name]||0)+1;
      log(`Picked up ${it.payload.name} (now x${state.inventory.weapons[it.payload.name]}).`);

      // --- TUTORIAL Step 4 (Pickup -> Equip) ---
      if (state.gameMode === 'tutorial' && state.tutorialStep === 4 && it.payload.name === 'Axe'){
        hideBanner();
        showBanner("Axe acquired! Press I and go to weapons to equip it.", 999999);
      }
      // -----------------------------------------

    }else if(it.kind==='potion'){
        SFX.pickup();    
      state.inventory.potions++; log('Picked up a potion.');
    }else if(it.kind==='tonic'){
        SFX.pickup();    
      state.inventory.tonics++; log('Picked up a tonic.');
}else if(it.kind==='antidote'){
        SFX.pickup();    
      state.inventory.antidotes++; log('Picked up an antidote.');
    
    // --- NEW: Consumable Pickup Logic ---
    }else if(it.kind==='bomb'){
      SFX.pickup();
      state.inventory.bombs = (state.inventory.bombs|0) + (it.payload||1);
      log(`Picked up ${it.payload||1} Bomb(s).`);
    }else if(it.kind==='warp'){
      SFX.pickup();
      state.inventory.warpStones = (state.inventory.warpStones|0) + (it.payload||1);
      log(`Picked up ${it.payload||1} Warp Stone(s).`);
    // ------------------------------------

    }else if(it.kind==='lockpicks'){
        SFX.pickup();    
      state.inventory.lockpicks += it.payload; log(`Picked up ${it.payload} lockpick(s).`);
    } else if (it.kind === 'arrows'){
  SFX.pickup();
  state.inventory.arrows = (state.inventory.arrows | 0) + (it.payload | 0);
  log(`Picked up ${it.payload} arrows.`);

  






        } else if (it.kind === 'shield'){
  SFX.pickup();
  state.inventory.shields = (state.inventory.shields|0) + 1;
  log('Picked up a shield.');
  if (!state.player.shield && isShieldAllowed()) { equipShield(); }
  else { updateEquipUI?.(); }

        updateEquipUI();
}else if(it.kind === 'spell'){
  SFX.pickup();
  const sp   = it.payload;      // { name, cost, tier }
  const name = sp.name;

  const have = state.spells.find(s => s.name === name);
  if (!have){
    // First copy ‚Üí learn the spell, keep tier
    state.spells.push({
      name: name,
      cost: sp.cost,
      tier: sp.tier
    });
    // harmless even if we never use upgrades again
    if (typeof ensureSpellUpgradeSlot === 'function') ensureSpellUpgradeSlot(name);

    if (!state.equippedSpell){
      state.equippedSpell = state.spells[state.spells.length - 1];
    }
    log(`Learned spell: ${name} Lv${sp.tier}.`);

  } else if ((sp.tier|0) > (have.tier|0)) {
    // Higher-tier scroll replaces the lower-tier version
    have.tier = sp.tier;
    log(`${name} upgraded to Lv${have.tier}.`);

  } else {
          // Extra copies ‚Üí Magic skill XP instead of shards
          ensureSkill('magic');
          const mg   = state.skills.magic;
          // Base 4 + 1 XP for every 5 floors depth
          const gain = MAGIC_SCROLL_XP + Math.floor(state.floor / 5);

          mg.xp += gain;
          if (!mg.shown) mg.shown = true;

    let leveled = false;
    while (mg.xp >= mg.next){
      mg.xp   -= mg.next;
      mg.lvl  += 1;
      mg.next  = Math.floor(mg.next * SKILL_XP_GROWTH);
      leveled  = true;
    }

    if (leveled){
      log(`You deepen your understanding of ${name}. Magic advanced to ${mg.lvl}.`);
    } else {
      log(`Studied another ${name} scroll (+${gain} Magic XP).`);
    }

    if (typeof renderSkills === 'function') renderSkills();
  }

  if (typeof updateSpellBody === 'function') updateSpellBody();
  if (typeof updateInvBody === 'function')   updateInvBody?.();

  delete state.pickups[kxy];
  state.tiles[state.player.y][state.player.x] = 1;
  if (typeof draw === 'function') draw();
}


    delete state.pickups[kxy];
    state.tiles[state.player.y][state.player.x]=1;
    updateInvBody();
    updateEquipUI();
  }
}

function tryMove(dx,dy){
    if (state.gameOver) return;
    if (state._inputLocked || state._descending) return;
  const nx=state.player.x+dx, ny=state.player.y+dy;
  if(!inBounds(nx,ny)) return;
  const t=state.tiles[ny][nx];
  if(t===0) { 
    // Wall bump dust (Reduced count)
    spawnParticles(nx - (dx*0.4), ny - (dy*0.4), '#9ca3af', 3); 
    return; 
  }
  if(enemyAt(nx,ny)) { log('An enemy blocks the way.'); return; }
  if(t===2) { log('A door blocks the way. Press E to open/unlock.'); return; }
  if(t===3) { log('A chest blocks the way. Press E to open.'); return; }
  if(t===6) { log('A mystical shrine blocks the way. Press E to interact.'); return; }
  
  // 1. ADDED: Block movement into scenery
  if(t===8) { 
    const pType = state.props[key(nx,ny)]?.type || 'crate';
    log(`A ${pType} blocks the way. Press SPACE to smash it!`); 
    return; 
  }

  // --- NEW: Spike Trap Logic ---
  if(t===7) {
    // Traps are passable, but they HURT.
    // Damage: 10% of Max HP (Minimum 5)
    const baseDmg = Math.max(5, Math.floor(state.player.hpMax * 0.10));
    // Apply Survivability reduction
    const finalDmg = damageAfterDR(baseDmg);
    
    state.player.hp = clamp(state.player.hp - finalDmg, 0, state.player.hpMax);
    flashDamage();
    SFX.weaponBreak(); // Crunch sound
    log(`You step on spikes! Took ${finalDmg} damage.`);
    spawnFloatText(finalDmg, nx, ny, '#ff0000');
    
    updateBars();
    if(state.player.hp <= 0) { triggerGameOver(); return; }
    
    // Optional: Reveal the trap permanently (it stays visible)
    // Optional: Disarm it? For now, it remains armed.
  }
  // NEW: block NPC tiles BEFORE moving
  if (isMerchantTile(nx, ny)) { log('The merchant blocks the way.'); return; }
  if (isBlacksmithTile(nx, ny)) { log('The blacksmith blocks the way.'); return; }
  if (isJesterTile(nx, ny)) { log('The jester blocks the way.'); return; }
  if (isCartographerTile(nx, ny)) { log('The cartographer blocks the way.'); return; }
  if (isClericTile(nx, ny)) { log('The priestess blocks the way.'); return; }

  // --- NEW: Gold Well Interaction ---
  if (state.goldWell) {
     const w = state.goldWell;
     // Block movement into the 2x2 area (x,y to x+1,y+1)
     if (nx >= w.x && nx <= w.x+1 && ny >= w.y && ny <= w.y+1) {
        log("A Golden Well blocks the way. Press E to interact.");
        return;
     }
  }

// NEW: set facing from movement
  if (dx>0) state.player.facing='right';
  else if (dx<0) state.player.facing='left';
  else if (dy>0) state.player.facing='down';
  else if (dy<0) state.player.facing='up';

  // Handle Player Slow (Spider web)
  if (state.player.slowed && state.player.slowTicks > 0) {
      // 50% chance to fail movement? Or move every other turn? 
      // Let's do: Movement takes 2 turns of enemy time.
      // Implementation: We move, but we call enemyStep() TWICE.
      enemyStep(); // Extra enemy turn cost
      state.player.slowTicks--;
      if (state.player.slowTicks <= 0) {
          state.player.slowed = false;
          log('You break free of the webs.');
      }
  }

  state.player.x = nx; 
  state.player.y = ny;
  SFX.step();

// --- NEW: Glacial Freeze (Slide) ---
  if (state.floorEffect === 'GlacialFreeze') {
    // 1. ADDED: Stair Traction. If we just stepped onto Stairs (4), do not slide.
    if (t !== 4) {
        // --- FIX: Check for Hallway/Intersection at the FIRST step (nx, ny) ---
        // If the tile we just stepped on (nx, ny) allows movement perpendicular to our slide,
        // we should STOP there to allow the player to turn.
        const perp = (dx !== 0) ? [[0,1], [0,-1]] : [[1,0], [-1,0]];
        let isIntersection = false;
        for (const [px, py] of perp) {
           const tx = nx + px, ty = ny + py;
           // If a perpendicular neighbor is walkable, it's an intersection/hallway
           if (state.tiles[ty]?.[tx] === 1 || state.tiles[ty]?.[tx] === 4 || state.tiles[ty]?.[tx] === 5) {
              isIntersection = true;
           }
        }
        // ----------------------------------------------------------------------

        const slideX = nx + dx;
        const slideY = ny + dy;
        // Check if the NEXT tile is also walkable (Floor/Stairs/Pickup) and empty
        const tNext = state.tiles[slideY]?.[slideX];
        const validTile = (tNext === 1 || tNext === 4 || tNext === 5);
        
        // NPC/Enemy check for the slide tile
        if (!isIntersection && inBounds(slideX, slideY) && validTile && !enemyAt(slideX, slideY) &&
            !isMerchantTile(slideX,slideY) && !isBlacksmithTile(slideX,slideY) &&
            !isJesterTile(slideX,slideY) && !isCartographerTile(slideX,slideY)) {
            
            // Check the intermediate tile (nx, ny) for pickup BEFORE sliding past it
            const kIntermediate = key(nx, ny);
            if (state.pickups[kIntermediate]) {
                // Temporarily place player on intermediate to collect
                state.player.x = nx; state.player.y = ny; 
                collectIfPickup(); // Pickup item
                log('You grab an item as you slide!');
            }

            state.player.x = slideX;
            state.player.y = slideY;
            log('You slide on the ice!');
        }
    }
  }
  // ----------------------------------

  // (leave the rest of your function as-is)


// --- NEW: MIASMA ticks every other PLAYER STEP (movement only) ---
if (state.floorEffect === 'MiasmaChamber'){
  state._miasmaSteps = (state._miasmaSteps|0) + 1;
  if (state._miasmaSteps % 3 === 0){
    // Scale: 1 dmg base + 1 per 15 floors
    const damage = 1 + Math.floor(state.floor/15);

    // Player Damage
    const p = damageAfterDR(damage);
    state.player.hp = clamp(state.player.hp - p, 0, state.player.hpMax);
    flashDamage();
    log(`The miasma burns you for ${p}.`);
    updateBars();
    if (state.player.hp <= 0){ triggerGameOver(); return; }

    // Enemy Damage (REMOVED: Miasma only hurts player now)
    /*
    for (const e of state.enemies) { ... } 
    */
  }
}
// --- END: MIASMA step tick ---

collectIfPickup();
enemyStep();
draw();


}

// ====== Mobile Joystick ‚Äî continuous movement while held ======
(() => {
  const joy  = document.getElementById('joystick');
  const knob = document.getElementById('joyStick');
  if (!joy || !knob) return;

  // prevent rubber-band scrolling on iOS over the joystick
  joy.style.touchAction = 'none';

  let held = false, stepTimer = null;
  let vecX = 0, vecY = 0;   // latest pointer delta from center

  const MAX_TRAVEL = 44;    // knob travel radius (px)
  const DEADZONE   = 12;    // ignore tiny nudges (px)
  const STEP_MS    = 120;   // how often we issue a move

  function setKnob(dx, dy){
    const len = Math.hypot(dx, dy) || 1;
    const kx = Math.max(-MAX_TRAVEL, Math.min(MAX_TRAVEL, (dx/len)*MAX_TRAVEL));
    const ky = Math.max(-MAX_TRAVEL, Math.min(MAX_TRAVEL, (dy/len)*MAX_TRAVEL));
    knob.style.transform = `translate(${kx}px, ${ky}px)`;
  }
  function resetKnob(){ knob.style.transform = 'translate(0,0)'; }

  function dirToStep(dx, dy){
    const ax = Math.abs(dx), ay = Math.abs(dy);
    if (Math.max(ax, ay) < DEADZONE) return [0, 0];
    // 4-way: whichever axis has the larger magnitude wins
    if (ax > ay) return [dx > 0 ? 1 : -1, 0];
    return [0, dy > 0 ? 1 : -1];
  }

  function readPointer(ev){
    const t = ev.touches ? ev.touches[0] : ev;
    const r = joy.getBoundingClientRect();
    return { x: t.clientX - (r.left + r.width/2), y: t.clientY - (r.top + r.height/2) };
  }

  function startStepping(){
    if (stepTimer) clearInterval(stepTimer);
    stepTimer = setInterval(() => {
      const [sx, sy] = dirToStep(vecX, vecY);
      if (sx || sy) tryMove(sx, sy);
    }, STEP_MS);
  }
  function stopStepping(){
    if (stepTimer) { clearInterval(stepTimer); stepTimer = null; }
  }

  function onStart(ev){
    held = true;
    const p = readPointer(ev);
    vecX = p.x; vecY = p.y;
    setKnob(vecX, vecY);
    startStepping();
    ev.preventDefault();
  }
  function onMove(ev){
    if (!held) return;
    const p = readPointer(ev);
    vecX = p.x; vecY = p.y;
    setKnob(vecX, vecY);
    ev.preventDefault();
  }
  function onEnd(){
    held = false;
    vecX = vecY = 0;
    resetKnob();
    stopStepping();
  }

  joy.addEventListener('touchstart', onStart, { passive:false });
  joy.addEventListener('touchmove',  onMove,  { passive:false });
  joy.addEventListener('touchend',   onEnd,   { passive:false });
  joy.addEventListener('touchcancel',onEnd,   { passive:false });
})();

// helper: descend a floor with audio + short fade
function doDescend(){
if (state.gameOver || state._descending) return;
state._descending = true;

// make sure flags exists for depth-50 checks later
state.flags ||= {};

// Hide boss HUD during the whole stair transition
state._suppressBossHud = true;
if (typeof updateBossHud === 'function') updateBossHud();

// create (or reuse) a black overlay in the canvas wrap
const wrap = document.getElementById('cw') || document.body;
let fx = document.getElementById('fadeBlack');
if (!fx){
fx = document.createElement('div');
fx.id = 'fadeBlack';
Object.assign(fx.style, {
position:'absolute', left:0, top:0, right:0, bottom:0,
background:'#000', opacity:'0', pointerEvents:'none',
zIndex:'12', transition:'opacity 340ms ease-in-out'
});
wrap.appendChild(fx);
}

// start fade and play the descend sfx
fx.style.opacity = '1';
if (SFX?.descend) SFX.descend();

// after fade-in completes, do the actual floor transition while screen is black
setTimeout(() => {
// -----------------------------------------------------------
    // --- START: CLEAR PREVIOUS FLOOR EFFECTS AND SHRINE EFFECTS ---
    
    // Cleanup from the Shrine Gamble effects
    if (state.player.tempMaxHPBoost) {
        state.player.hpMax -= state.player.tempMaxHPBoost; // Revert the Max HP change
        state.player.hp = clamp(state.player.hp, 0, state.player.hpMax);
    }
    delete state.player.tempMaxHPBoost;
    delete state.player.movementSlowed;

// Cleanup Floor Effects
delete state.floorEffect;
delete state.player.tempVisionRange;

// reset ‚Äúevery other step‚Äù counter when entering a new floor
state._miasmaSteps = 0;

// --- APPLY ENDLESS MODE FLOOR EFFECT ---
const isEndless = state.gameMode !== 'classic';
const nextFloor = state.floor + 1; // Calculating for the floor we are ABOUT to enter
let newBgColor = 'rgba(0,0,0,0)'; // DEFAULT: no tint (play area only)

// Only apply effects if it's NOT a boss floor (multiples of 10)
if (isEndless && (nextFloor % 10 !== 0)) { 
    const roll = Math.random();
    
    if (roll < 0.12) { 
        state.floorEffect = 'MiasmaChamber';
        newBgColor = 'rgba(34,197,94,0.18)'; 
    } else if (roll < 0.24) { 
        state.floorEffect = 'ShadowLabyrinth';
        state.player.tempVisionRange = 2;
    } else if (roll < 0.36) { 
        state.floorEffect = 'Bloodhunt';
        newBgColor = 'rgba(190,24,93,0.14)';
    } else if (roll < 0.48) {
        state.floorEffect = 'GlacialFreeze';
        newBgColor = 'rgba(165, 243, 252, 0.15)'; // Cyan/Ice
    } else if (roll < 0.60) {
        state.floorEffect = 'VolatileAether';
        newBgColor = 'rgba(234, 88, 12, 0.15)';   // Orange/Explosive
        state.explosions = []; // Init explosion list
    } else if (roll < 0.72) {
        state.floorEffect = 'AntiMagic';
        newBgColor = 'rgba(100, 100, 100, 0.25)'; // Grey/Dull
    } else if (roll < 0.84) {
        state.floorEffect = 'ArcaneFlux';
        newBgColor = 'rgba(147, 51, 234, 0.15)';  // Purple/Magic
    }
}

// Set the tint ONLY on the play area (canvas wrap), not the whole page
const tintEl = document.getElementById('floorTint');
if (tintEl) tintEl.style.background = newBgColor;

    // --- END: FLOOR EFFECTS SETUP ---

    // -----------------------------------------------------------


log('You descend.');

// recover 25% HP
const heal = Math.ceil(state.player.hpMax * 0.25);
state.player.hp = Math.min(state.player.hp + heal, state.player.hpMax);
log(`You recover ${heal} HP.`);

// recover 20% MP (min 1)
const mpHeal = Math.max(1, Math.ceil(state.player.mpMax * 0.20));
state.player.mp = Math.min(state.player.mp + mpHeal, state.player.mpMax);
log(`You also recover ${mpHeal} MP.`);
updateBars();



// go deeper
state.floor++;
state.run.depth = Math.max(state.run.depth, state.floor);

// build the next floor while we‚Äôre still black
gen(); enemyStep(); draw?.(); updateBars();

    // sync Depth chip
    const fc = document.getElementById('floorChip');
    if (fc) fc.textContent = 'Depth ' + state.floor;

    // keep it black a touch longer so the sound ‚Äúreads‚Äù, then fade back in
    setTimeout(() => {
      fx.style.opacity = '0';
      setTimeout(() => {
        state._descending = false;

        // re-enable boss HUD now that the fade is fully finished
        state._suppressBossHud = false;
        if (typeof updateBossHud === 'function') updateBossHud();

        // --- NEW: floor-effect popup banner ---
        
        // This SINGLE line covers Miasma, Shadow, and Bloodhunt automatically:
        unlockCodex(state.floorEffect); 

        if (state.floorEffect === 'MiasmaChamber') {
          showBanner('Miasma Chamber ‚Äî the air itself poisons you.', 4000);
        } else if (state.floorEffect === 'ShadowLabyrinth') {
  showBanner('Shadow Labyrinth ‚Äî your vision is strangled by darkness.', 4000);
} else if (state.gameMode !== 'classic' && state.floorEffect === 'Bloodhunt') {
  showBanner('Bloodhunt ‚Äî in the unseen, enemies surge toward you.', 4000);
}
else if (state.floorEffect === 'GlacialFreeze') {
          showBanner('Glacial Freeze ‚Äî the floor is slick. Momentum carries you.', 4000);
        } else if (state.floorEffect === 'VolatileAether') {
          showBanner('Volatile Aether ‚Äî the air hums. Enemies explode upon death.', 4000);
        } else if (state.floorEffect === 'AntiMagic') {
          showBanner('Anti-Magic Field ‚Äî spells act strangely silent, but your blade sings.', 4000);
        } else if (state.floorEffect === 'ArcaneFlux') {
          showBanner('Arcane Flux ‚Äî raw magic surges, but your physical strength wanes.', 4000);
        }
// --- END: floor-effect popup banner ---

        // Depth 50 Classic: trigger intro cutscene (it will hide HUD again)
        if (state.gameMode === 'classic' &&
            state.floor === 50 &&
            !state.flags.depth50IntroDone) {
          setTimeout(() => runDepth50Intro(), 50);
        }
      }, 360);
    }, 2200); // hold time while the sound plays
  }, 340);    // fade-in duration
}






function interact(){
  if (state.gameOver) return;
  if (state._inputLocked || state._descending) return;

  // Blacksmith first, then Merchant
  if (isNearBlacksmith(state.player.x, state.player.y)){
    if (typeof window.openBlacksmith === 'function') window.openBlacksmith();
    else if (typeof openBlacksmith === 'function') openBlacksmith();
    return;
  }

  if (isNearMerchant(state.player.x, state.player.y)){
    if (typeof window.openMerchant === 'function') window.openMerchant();
    else if (typeof openMerchant === 'function') openMerchant();
    return;
  }

  if (isNearJester(state.player.x, state.player.y)){
    if (typeof window.openJester === 'function') window.openJester();
    else if (typeof openJester === 'function') openJester();
    return;
  }

  if (isNearCartographer(state.player.x, state.player.y)){
    if (typeof window.openCartographer === 'function') window.openCartographer();
    else if (typeof openCartographer === 'function') openCartographer();
    return;
  }

  // --- NEW: Cleric Check ---
  if (state.cleric && Math.abs(state.player.x - state.cleric.x) + Math.abs(state.player.y - state.cleric.y) <= 1) {
    if (typeof window.openCleric === 'function') window.openCleric();
    return;
  }
  
  // --- NEW: Gold Well Check ---
  if (state.goldWell) {
     const w = state.goldWell;
     // Check proximity: Player must be adjacent to the 2x2 box
     // The well covers (w.x, w.y) to (w.x+1, w.y+1).
     // We expand bounds by 1 to check adjacency.
     if (state.player.x >= w.x - 1 && state.player.x <= w.x + 2 &&
         state.player.y >= w.y - 1 && state.player.y <= w.y + 2) {
         // Ensure we aren't somehow inside it (though tryMove blocks that)
         const inside = (state.player.x >= w.x && state.player.x <= w.x+1 && state.player.y >= w.y && state.player.y <= w.y+1);
         if (!inside && typeof window.openGoldWell === 'function') { 
            window.openGoldWell(); 
            return; 
         }
     }
  }
  // -------------------------
  // -------------------------

  let did = false;
  for(const nb of neighbors4(state.player.x,state.player.y)){
    

    if(inBounds(nb.x,nb.y) && state.tiles[nb.y][nb.x]===3){
      openChest(nb.x,nb.y); did=true;
    }


    // --- SHRINE INTERACTION LOGIC ---
if(inBounds(nb.x,nb.y) && state.tiles[nb.y][nb.x]===6){
  state.tiles[nb.y][nb.x] = 1; // Change shrine to used floor tile
  SFX.spell(); 
  unlockCodex('Shrine', true);
  
  const roll = Math.random();
  
  // 1. Blood Altar (20%): Pay HP for an Item
  if (roll < 0.20) {
    const cost = Math.floor(state.player.hpMax * 0.3);
    state.player.hp = Math.max(1, state.player.hp - cost);
    updateBars();
    flashDamage();
    log(`The shrine demands blood! (-${cost} HP)`);
    // Drop a weapon or good item
    const dropType = Math.random() < 0.5 ? 'weapon' : 'scroll';
    const k = key(nb.x, nb.y);
    state.tiles[nb.y][nb.x] = 5; // Pickup tile
    
    if(dropType === 'weapon'){
        state.pickups[k] = { kind:'weapon', payload: randomWeapon() };
        log("A weapon materializes from the blood.");
    } else {
        state.pickups[k] = { kind:'spell', payload: randomSpell() };
        log("A scroll materializes from the blood.");
    }
    spawnParticles(nb.x, nb.y, '#ef4444', 8); 
    unlockCodex('Shrine_Blood', true);

  // 2. Midas Touch (20%): Pay HP for Gold
  } else if (roll < 0.40) {
    const dmg = Math.floor(state.player.hpMax * 0.15);
    state.player.hp = Math.max(1, state.player.hp - dmg);
    const gold = rand(50, 150) + (state.floor * 5);
    state.inventory.gold += gold;
    updateBars();
    flashDamage();
    log(`The shrine turns your flesh to gold! (-${dmg} HP, +${gold}g)`);
    spawnParticles(state.player.x, state.player.y, '#fbbf24', 8); 
    unlockCodex('Shrine_Midas', true);

  // 3. Summon Mimic (Trap) (20%)
  } else if (roll < 0.60) {
    log('The shrine hums... and traps you!');
    if (typeof spawnMimic === 'function') spawnMimic(nb.x, nb.y); 
    unlockCodex('Shrine_Mimic', true);

  // 4. Full Heal (20%)
  } else if (roll < 0.80) {
    state.player.hp = state.player.hpMax;
    state.player.mp = state.player.mpMax;
    state.player.stamina = state.player.staminaMax; // <--- ADDED
    log('Divine light restores your vitality and endurance!');
    updateBars();
    unlockCodex('Shrine_Heal', true);
    spawnParticles(state.player.x, state.player.y, '#fff', 8);

  // 5. XP Boost (20%)
  } else {
    const xp = 50 + (state.floor * 5);
    log(`Ancient knowledge flows into you. (+${xp} XP)`);
    // Manual XP add to bypass skill requirements
    state.player.xp += xp; 
    while(state.player.xp >= state.player.next){
       state.player.xp -= state.player.next;
       state.player.level++;
       state.player.next = Math.floor(state.player.next * 1.30);
       openLevelUpModal();
    }
    unlockCodex('Shrine_XP', true);
    updateBars();
    spawnParticles(state.player.x, state.player.y, '#60a5fa', 8);
  }
  
  did = true;
  // Only turn if something happened (which it did)
  enemyStep(); 
  draw();


  // üëá ADD THESE TWO LINES HERE üëá
  // This advances the turn, which is necessary for effects like enemy spawning (Mimic) 
  // or immediate redraws (Teleport/HP update) to properly resolve without a player move.
  if (typeof enemyStep === 'function') enemyStep(); 
  if (typeof draw === 'function') draw();
  
  did = true;
}
        if(inBounds(nb.x,nb.y) && state.tiles[nb.y][nb.x]===2){
      // Check for Key of Destiny
      const hasKey = state.player.weapon?.name?.includes('Key of Destiny');
      
      if(hasKey || state.inventory.lockpicks>0){
        if (!hasKey) state.inventory.lockpicks--; // Only consume pick if no key
        
        ensureSkill('lockpicking');

        // Tutorial OR Key = Instant Success
        let success;
        if (state.gameMode === 'tutorial' || hasKey) {
          success = true;
        } else {
          const L = state.skills['lockpicking'].lvl || 1;
          const chance = Math.max(0.10, Math.min(0.95, 0.35 + 0.10*(L-1)));
          success = (Math.random() < chance);
        }

      if (success){
          incrementMetaStat('locks'); // <--- NEW: Track lockpick success
          state.tiles[nb.y][nb.x] = 1;
          
          // Only grant XP if we actually used a lockpick (no Key)
          if (!hasKey) {
            state.skills['lockpicking'].shown = true;
            state.skills['lockpicking'].xp += 6;
            while (state.skills['lockpicking'].xp >= state.skills['lockpicking'].next){
              state.skills['lockpicking'].xp -= state.skills['lockpicking'].next;
              state.skills['lockpicking'].lvl++;
              state.skills['lockpicking'].next = Math.floor(state.skills['lockpicking'].next * 1.5);
              log('Lockpicking advanced to ' + state.skills['lockpicking'].lvl + '.');
            }
          }

          renderSkills();
          SFX.lockSuccess();

          if (hasKey) log('The Key of Destiny unlocks the path.');
          else        log('You pick the lock and open the door.');

          if (state.gameMode === 'tutorial') {
            // --- TUTORIAL Step 12 (Door) ---
            if (state.tutorialStep === 12) {
              state.tutorialStep = 13;
              hideBanner();
              showBanner("Step 13: Open the Chest with E to finish!", 999999);
            }
          }
        } else {
          SFX.lockFail();
          log('Lockpick attempt failed.');
        }

        draw(); did = true;
      } else {
        log('It is locked. Need a lockpick.');
        did = true;
      }
    }

  }

  // --- Tutorial: once door + chest are cleared, reveal the stairs ---
  if (state.gameMode === 'tutorial' && state.tutorialStep === 5 &&
      state.tiles[27][15] === 1 && state.tiles[24][15] === 1) {
    // stairs in the lower room (29,17)
    state.tiles[29][17] = 4;
    if (SFX.bossDown) SFX.bossDown();
    draw();
    state.tutorialStep = 6;
    say("The stairs appear! Step onto them to finish the tutorial.");
  }

  if (state.tiles[state.player.y][state.player.x] === 4){
    // In the tutorial, stepping on the stairs sends you back to the main menu.
    if (state.gameMode === 'tutorial') {
      // optional: mark run over / stop timer if you use one
      state.gameOver = true;
      if (typeof stopRunTimer === 'function') stopRunTimer();

      // Go back to the main menu overlay
      if (typeof goMenu === 'function') goMenu();
    } else {
      // Normal behavior for Classic / Endless
      doDescend();
    }
    return;
  }

  if(!did) log('Nothing to interact with.');
}



// --- NEW: Prop Smashing Logic ---
function handlePropSmash(x, y) {
  const k = key(x, y); // <--- MOVED UP: Define 'k' at the very top so it is available everywhere

  // --- TUTORIAL OVERRIDE (Step 3 -> 4) ---
  // Allow smash to advance tutorial even if previous steps (like Sprint) were missed
  if (state.gameMode === 'tutorial') {
    delete state.props[k]; // Use 'k' here
    state.tiles[y][x] = 1; 
    SFX.weaponBreak();
    spawnParticles(x, y, '#8b5a2b', 5);

    // 1. Spawn Axe on floor (where crate was)
    state.pickups[k] = {
      kind: 'weapon',
      payload: {name:'Axe', type:'axe', min:3, max:5, base:{min:3,max:5}, durMax:15, dur:15}
    };
    state.tiles[y][x] = 5; // Pickup tile

    // 2. Force Step 4 (Pickup phase)
    state.tutorialStep = 4;
    hideBanner();
    showBanner("Step 4: Walk over the Axe to pick it up.", 999999);
    
    draw();
    return;
  }
  const prop = state.props[k];
  const name = prop ? prop.type : 'crate';
  
  // Remove prop visual and physical block
  if (state.props[k]) delete state.props[k];
  state.tiles[y][x] = 1; // Turn into floor
  
  SFX.weaponBreak(); // Crunch sound
  spawnParticles(x, y, '#8b5a2b', 5); // Wood chips

  const roll = Math.random();

  // 1. Bad Outcome (10%): Enemy or Poison
  if (roll < 0.10) {
    if (Math.random() < 0.5) {
      // Spawn Rat or Slime
      const type = (Math.random() < 0.5) ? 'Rat' : 'Slime';
      const hp = (type === 'Rat') ? 4 : 5;
      state.enemies.push({ x, y, type, hp, atk:[1,2], xp:3, size:1 });
      log(`A ${type} bursts out of the ${name}!`);
      spawnFloatText("!", x, y, '#ef4444');
    } else {
      // Poison Cloud (Damage Player)
      const dmg = damageAfterDR(3);
      state.player.hp = clamp(state.player.hp - dmg, 0, state.player.hpMax);
      state.player.poisoned = true; 
      state.player.poisonTicks = 8;
      flashDamage();
      log(`Noxious gas leaks from the ${name}! Took ${dmg} dmg.`);
      spawnFloatText("POISON", x, y, '#22c55e');
      updateBars();
    }
  }
  // 2. Good Outcome (20%): Loot
  else if (roll < 0.30) {
    const lootR = Math.random();
    if (lootR < 0.4) {
      const g = rand(5, 15);
      state.inventory.gold += g;
      log(`Found ${g} gold inside.`);
      spawnFloatText(`+${g}g`, x, y, '#facc15');
    } else if (lootR < 0.7) {
      state.inventory.arrows += 3;
      log('Found a bundle of arrows.');
      spawnFloatText("+3 Arrows", x, y, '#9ca3af');
    } else if (lootR < 0.9) {
      state.inventory.potions++;
      log('Found a potion.');
      spawnFloatText("+1 Potion", x, y, '#ef4444');
    } else {
      state.inventory.bombs++;
      log('Found a bomb!');
      spawnFloatText("+1 Bomb", x, y, '#f97316');
    }
    updateInvBody();
  } 
  // 3. Empty (70%)
  else {
    log(`You smash the ${name}. It was empty.`);
  }
  
  enemyStep(); // Consumes a turn
  draw();
}

// Chest weapon chance scales with depth (floor 1 ‚âà 45%, +1%/floor, capped 65%)
const CHEST_WEAPON_BASE        = 0.40;
const CHEST_WEAPON_FLOOR_BONUS = 0.01;
const CHEST_WEAPON_MAX         = 0.50;

// Weighted picker for non-weapon chest loot
function pickWeighted(weights){
  let total = 0;
  for (const k in weights) total += Math.max(0, weights[k]|0);
  if (total <= 0) return Object.keys(weights)[0] || 'potion';
  let r = Math.random() * total;
  for (const k in weights){
    r -= Math.max(0, weights[k]|0);
    if (r <= 0) return k;
  }
  return Object.keys(weights)[0] || 'potion';
}

// Base weights for non-weapon chest items (relative, not %)
const NON_WEAPON_BASE = {
  potion: 34,
  tonic: 24,
  antidote: 18,
  arrows: 16,
  lockpicks: 8,
  shield: 12,
  bomb: 6,       // NEW: Rare offensive drop
  warp: 4        // NEW: Very rare utility drop
};

// Depth scaling: fewer basic heals deeper; more MP/spells deeper
function scaleNonWeaponWeights(base){
  const f = state.floor | 0;
  const w = { ...base };
  w.potion = Math.max(10, w.potion - Math.floor(f * 2));
  w.tonic  = w.tonic  + Math.floor(f * 2);
  w.spell  = w.spell  + Math.floor(f * 2);
  return w;
}


function openChest(x,y){
  const k = `${x},${y}`;

  // --- Mimic trap remains the same ---
  if (state.mimicChests && state.mimicChests.has(k)) {
    state.mimicChests.delete(k);
    state.tiles[y][x] = 1;     // chest disappears
    SFX.openChest();
    SFX.attack?.();            // bite sound
    const m = {
      type: 'Mimic',
      x, y,
      hp: 12,
      atk: [2,4],
      xp: 8,
      awake: true,
      fast: false
    };
    state.enemies.push(m);
    log('The chest snaps open‚Äîit\'s a Mimic!');
    enemyStep(); draw(); updateBars?.();
    return;
  }

  // Normal chest
  state.tiles[y][x] = 1;
  SFX.openChest();
  
// --- TUTORIAL OVERRIDE (Step 13 -> Finish) ---
  if (state.gameMode === 'tutorial') {
    if (state.tutorialStep === 13) {
       // Show the custom modal instead of alert()
       const m = document.getElementById('tutorialCompleteModal');
       if (m) {
         m.style.display = 'flex';
         // Ensure button works
         const btn = document.getElementById('btnTutReturn');
         if(btn) btn.onclick = () => {
            m.style.display = 'none';
            goMenu();
         };
       } else {
         // Fallback just in case
         goMenu();
       }
    }
    return; 
  }

  const lootMsg = [];

  const kxy = x + ',' + y;
  const isStarterChest = (state._starterChest === kxy);

  // --- Weapon roll (starter always, others scaled by depth) ---
  const f = state.floor | 0;
  const weaponChance = Math.min(
    CHEST_WEAPON_MAX,
    CHEST_WEAPON_BASE + CHEST_WEAPON_FLOOR_BONUS * Math.max(0, f - 1)
  );
  if (isStarterChest || Math.random() < weaponChance){
    const w = randomWeapon();
    
    // --- NEW: Check Inventory Limit ---
    // Ensure helper functions exist (defined at bottom of script)
    const wType = (typeof getWeaponType === 'function') ? getWeaponType(w.name) : 'hand';
    const curCount = (typeof countWeaponsInCategory === 'function') ? countWeaponsInCategory(wType) : 0;
    const limit = (typeof MAX_WEAPON_CAT !== 'undefined') ? MAX_WEAPON_CAT : 5;

    if (curCount >= limit) {
       // Bag Full: Drop weapon on floor & trigger Swap
       const k = key(x,y);
       state.pickups[k] = { kind:'weapon', payload:w };
       state.tiles[y][x] = 5; // Change tile from Floor(1) to Pickup(5)
       
       lootMsg.push(`${w.name} (Dropped - Bag Full)`);
       
       // Trigger the UI after a brief delay so the chest log usually finishes processing
       setTimeout(() => {
          if(typeof openWeaponSwapModal === 'function') openWeaponSwapModal(w, k, x, y);
       }, 50);
    } else {
       // Normal Add
       state.inventory.weapons[w.name] = (state.inventory.weapons[w.name] || 0) + 1;
       lootMsg.push(`${w.name} (now x${state.inventory.weapons[w.name]})`);
    }
    // ----------------------------------
  }

  // --- Starter chest keeps your guaranteed pack ---
  if (isStarterChest){
    state.inventory.potions   += 5;
    state.inventory.tonics    += 5;
    state.inventory.antidotes += 5;
    state.inventory.lockpicks += 5;
    lootMsg.push(`+5 potions`, `+5 tonics`, `+5 antidotes`, `+5 lockpicks`);
  } else {
    // --- Non-starter chest: lockpicks + one weighted non-weapon pick ---
    const lp = rand(1,3);
    state.inventory.lockpicks += lp;
    lootMsg.push(`+${lp} lockpicks`);

    // Build weights with depth & context
    let w = scaleNonWeaponWeights(NON_WEAPON_BASE);

    // Pity boosts if you're in trouble and have none
    const hpLow = (state.player.hp / state.player.hpMax) <= 0.35;
    const mpLow = (state.player.mp / state.player.mpMax) <= 0.35;
    if ((state.inventory.potions|0) === 0 && hpLow)  w.potion += 40;
    if ((state.inventory.tonics|0)  === 0 && mpLow)  w.tonic  += 40;

    // Early game: don't flood arrows if player isn't really using bow yet
    if (!state.skills || !state.skills.bow) w.arrows = Math.floor(w.arrows * 0.3);

    // Make a single, clean pick
    const pick = pickWeighted(w);
    switch (pick){
      case 'potion':
        state.inventory.potions++;
        lootMsg.push('+1 potion');
        break;

      case 'tonic':
        state.inventory.tonics++;
        lootMsg.push('+1 tonic');
        break;

      case 'antidote':
        state.inventory.antidotes++;
        lootMsg.push('+1 antidote');
        break;

      case 'bomb':
        state.inventory.bombs = (state.inventory.bombs||0) + 1;
        lootMsg.push('+1 Bomb');
        break;
      case 'warp':
        state.inventory.warpStones = (state.inventory.warpStones||0) + 1;
        lootMsg.push('+1 Warp Stone');
        break;

      case 'arrows': {
        const n = rand(3,8);
        state.inventory.arrows = (state.inventory.arrows || 0) + n;
        lootMsg.push(`+${n} arrows`);
        break;
      }
      
      case 'shield': {
        state.inventory.shields = (state.inventory.shields|0) + 1;
        lootMsg.push('+1 shield');
        if (!state.player.shield && isShieldAllowed()) {
          equipShield();              
        } else {
          updateEquipUI?.();          
        }
        break;
      }

      case 'spell': {
        const sp   = randomSpell();
        const name = sp.name;

        const have = state.spells.find(s => s.name === name);
        if (!have){
          state.spells.push(sp);
          if (typeof ensureSpellUpgradeSlot === 'function') ensureSpellUpgradeSlot(name);
          if (!state.equippedSpell) state.equippedSpell = sp;
          lootMsg.push(`spell: ${name} Lv${sp.tier}`);
        } else if (sp.tier > (have.tier || 1)) {
          have.tier = sp.tier;
          lootMsg.push(`${name} upgraded to Lv${have.tier} (replaces previous)`);
        } else {
          ensureSkill('magic');
          const mg   = state.skills.magic;
          const gain = MAGIC_SCROLL_XP;

          mg.xp += gain;
          if (!mg.shown) mg.shown = true;

          let leveled = false;
          while (mg.xp >= mg.next){
            mg.xp   -= mg.next;
            mg.lvl  += 1;
            mg.next  = Math.floor(mg.next * SKILL_XP_GROWTH);
            leveled  = true;
          }

          if (leveled){
            lootMsg.push(`extra ${name} scroll (+${gain} Magic XP, Magic ${mg.lvl})`);
          } else {
            lootMsg.push(`extra ${name} scroll (+${gain} Magic XP)`);
          }

          if (typeof renderSkills === 'function') renderSkills();
        }
        break;
      }

      default:
        state.inventory.potions++;
        lootMsg.push('+1 potion');
        break;
    }
  }

  if (isStarterChest) delete state._starterChest;

  log('Opened chest: ' + lootMsg.join(', ') + '.');
  updateInvBody();
  enemyStep();   // advance time on open
  draw();
}





function equipWeaponByName(name){
  // --- NEW: Redirect Shields to off-hand ---
  const st = weaponStatsFor(name);
  if (st && st.type === 'shield') {
      equipShield(name);
      return;
  }
  // ----------------------------------------

  // No-op if already equipped
  if (state.player.weapon?.name === name) return;
  // --- FIX: Prevent swapping IF current weapon is Cursed ---
  if (state.player.weapon?.cursed) {
    log("The cursed weapon binds to your hand. You cannot switch.");
    return; 
  }

  // Ensure stash exists
  if (!state.inventory.stashed) state.inventory.stashed = {};

  // 1) Preserve the CURRENTLY EQUIPPED weapon (if it has durability and isn't Fists)
  const cur = state.player.weapon;
  if (cur && cur.name !== 'Fists' && Number.isFinite(cur.durMax) && cur.dur > 0){
    (state.inventory.stashed[cur.name] ||= []).push({ ...cur, base: { ...cur.base } });
  }

  // 2) Equip requested weapon ‚Äî prefer a stashed copy to keep its durability
  const spareCount = state.inventory.weapons[name] || 0;
  const stashArr   = state.inventory.stashed[name] || [];
  const stashedCnt = stashArr.length;

  // Block if you truly have none
  if (name !== 'Fists' && spareCount <= 0 && stashedCnt <= 0){
    log(`You don't have any ${name}s left.`);
    return;
  }

  if (name !== 'Fists' && stashedCnt > 0){
  const w = stashArr.pop();

  // NEW: if this weapon can't use a shield, auto-unequip it
  if (state.player.shield && !isShieldAllowedFor(w.type)){
    unequipShield();
    log('You put away your shield to wield the ' + name + '.');
    updateEquipUI?.();
  }

  state.player.weapon = { ...w, base: { ...w.base } };
  ensureSkill(state.player.weapon.type);
  recomputeWeapon();
  updateEquipUI();
  return;
}

// --- TUTORIAL Step 4 -> 5 (Equip Axe) ---
    if (state.gameMode === 'tutorial' && state.tutorialStep === 4 && name === 'Axe') {
      state.tutorialStep = 5;
      state.player.stamina = 10; // refill stamina for Art
      hideBanner();
      showBanner("Step 5: Weapon Arts. Walk to the 3 rats and press R (Cleave).", 999999);
    }


  // 3) Otherwise build a fresh copy (full durability)
  // --- FIX: Parse Affixes so we can look up base stats ---
  let baseName = name;
  let bonMin=0, bonMax=0, isVamp=false;
  
  if (name.includes('Sharp '))       { baseName = baseName.replace('Sharp ', '');   bonMin+=1; bonMax+=1; }
  else if (name.includes('Heavy '))  { baseName = baseName.replace('Heavy ', '');   bonMax+=3; }
  else if (name.includes('Vampiric ')){ baseName = baseName.replace('Vampiric ', ''); isVamp=true; }
  else if (name.includes('Ancient ')) { baseName = baseName.replace('Ancient ', '');  bonMin+=2; bonMax+=2; }
  
  // Strip Curse info to find base stats
  if (name.includes('Cursed ')) {
     baseName = baseName.replace('Cursed ', '');
     baseName = baseName.replace('Blood ', '').replace('Greed ', '').replace('Rust ', '').replace('Frailty ', '');
  }

// --- FIX: Use global stats lookup instead of hardcoded list ---
  const template = weaponStatsFor(baseName); 
  
  // Format it as [min, max, type] to match old logic, or null
  const stats = template ? [template.min, template.max, template.type] : null;

  if(!stats) {
      console.warn("Could not find stats for:", baseName); 
      return; 
  }

  // NEW: if this weapon can't use a shield, auto-unequip it
if (state.player.shield && !isShieldAllowedFor(stats[2])){
  unequipShield();
  log('You put away your shield to wield the ' + name + '.');
  updateEquipUI?.();
}
  // Lookup durability using the BASE name (e.g. "Shortsword")
  const durMax = defaultDurabilityFor(baseName);
  
  // --- NEW: Preserve Cursed properties when rebuilding fresh weapon ---
  const isCursed = name.includes('Cursed ');
  const cType = isCursed ? (name.includes('blood') ? 'blood' : (name.includes('greed') ? 'greed' : (name.includes('frailty') ? 'frailty' : 'rust'))) : null; 

  state.player.weapon = {
    name, // Keep full name "Cursed Shortsword"
    min: stats[0] + bonMin, 
    max: stats[1] + bonMax, 
    type: stats[2],
    base: { min: stats[0] + bonMin, max: stats[1] + bonMax },
    dur: durMax, 
    durMax,
    vampiric: isVamp,
    cursed: isCursed, // <--- CRITICAL FIX
    curseType: cType,  // <--- CRITICAL FIX
  };
  ensureSkill(stats[2]);
  recomputeWeapon();
  updateEquipUI();

  // New: Cursed Banner Notification
  if (state.player.weapon.cursed) {
    let msg = "You are Cursed.";
    if (state.player.weapon.curseType === 'blood') msg = "Blood Curse: The weapon drains your HP.";
    else if (state.player.weapon.curseType === 'greed') msg = "Greed Curse: The weapon consumes Gold.";
    else if (state.player.weapon.curseType === 'frailty') msg = "Frailty Curse: You take extra damage.";
    else if (state.player.weapon.curseType === 'rust') msg = "Rust Curse: Durability degrades rapidly.";
    
    showBanner(msg, 4000);
    SFX.descend(); // Ominous sound
  }
}

  // Tutorial: after equipping the Shortsword
  if (state.gameMode === 'tutorial' &&
      state.tutorialStep === 2 &&
      name === 'Shortsword') {
    state.tutorialStep = 3;
    say("Weapon equipped. Now move next to a rat and press SPACE to attack it. Be careful this consumes stamina");
  }


function isShieldAllowedFor(t){
  // allow shield with one-handed weapons or bare hands
  return t === 'one' || t === 'hand' || !t;
}
function isShieldAllowed(){
  const t = state.player?.weapon?.type;
  return isShieldAllowedFor(t);
}




function equipShield(){
  if (!isShieldAllowed()){ log('A shield can only be used with one-handed swords.'); return; }
  if (state.player.shield){ log('Already have a shield equipped.'); return; }
  const have = state.inventory.shields|0;
  if (have <= 0){ log('You have no spare shields.'); return; }
  state.inventory.shields = have - 1;
  state.player.shield = { name: SHIELD_NAME, dur: SHIELD_DUR };
  log('Equipped a shield.');
  updateInvBody?.(); updateEquipUI?.(); draw?.();
}
function unequipShield(){
  const sh = state.player.shield; 
  if (!sh) return;

  const name = state.player.shieldName || 'Standard';

  // If it's a specific named shield, put it back in specific inventory
  if (name !== 'Standard') {
    state.inventory.weapons[name] = (state.inventory.weapons[name] || 0) + 1;
  } else {
    // Otherwise, add to generic pile
    state.inventory.shields = (state.inventory.shields|0) + 1;
  }

  state.player.shield = null;
  state.player.shieldName = null; // Clear the name tracking
  
  log('Unequipped ' + name + '.');
  updateInvBody?.(); updateEquipUI?.(); draw?.();
}




function breakEquippedWeaponIfNeeded(){
  const w = state.player.weapon;
  if(!Number.isFinite(w?.durMax)) return;
  if(w.dur>0) return;

  if(state.inventory.weapons[w.name] > 0){
    state.inventory.weapons[w.name] -= 1;
    // NEW: purge zero-count entry so it won‚Äôt show x0 or be equippable
    if (state.inventory.weapons[w.name] <= 0){
      delete state.inventory.weapons[w.name];
    }
  }
    SFX.weaponBreak();
  log(`${w.name} breaks!`);
  state.player.weapon = {name:'Fists',min:1,max:2,type:'hand',base:{min:1,max:2},dur:null,durMax:null};
  recomputeWeapon();
  updateEquipUI();
  updateInvBody();
}


function handleSuccessfulHitDurabilityTick(){
  const w = state.player.weapon;
  state._hitParity = (state._hitParity + 1);
  
  // Rust Curse: degrades every hit. Normal: degrades every 2nd hit.
  const degrade = (w.curseType === 'rust') || (state._hitParity % 2 === 0);

  if(Number.isFinite(w?.durMax) && degrade){
    w.dur = Math.max(0, (w.dur ?? w.durMax) - 1);
    updateEquipUI();
    if(w.dur===0) breakEquippedWeaponIfNeeded();
  }
}

function shootBow(){
  if (state.gameOver) return;
  if (state._inputLocked || state._descending) return;
  
  // New: Stamina Cost
  if (state.player.stamina < 1) { spawnFloatText("No Stamina", state.player.x, state.player.y, '#9ca3af'); return; }

  // need a loaded arrow
  if (!state.player?.bow?.loaded){ log('No arrow loaded.'); return; }

  // Deduct Stamina
  state.player.stamina--; 
  state._skipStaminaRegen = true; // <--- ADD THIS
  updateBars();

  // fire straight along current facing up to range
  const bowLvl = (state.skills?.bow?.lvl || 1);
const baseRange = state.player.bow?.range ?? 5;
const range = baseRange + Math.floor(Math.max(0, bowLvl - 1) / 3); // +1 range every 3 Bow levels
  const dirs = {up:[0,-1],down:[0,1],left:[-1,0],right:[1,0]};
  const [dx,dy] = dirs[state.player.facing] || [0,0];
  if (!dx && !dy){ log('You fumble with the bow.'); return; }

  // spend the loaded arrow immediately
  state.player.bow.loaded = 0;
  updateEquipUI();
  SFX.bowShot();

  // --- NEW: Signal Shadow to copy ---
  state.lastPlayerAction = { type: 'bow' };
  // ---------------------------------

  // walk cells out to max range, blocked by walls/closed doors
  for (let r=1; r<=range; r++){
    const x = state.player.x + dx*r;
    const y = state.player.y + dy*r;
    if (!inBounds(x,y)) break;
    const t = state.tiles[y][x];
    if (t===0 || t===2) break;                 // walls or shut doors stop the shot

    const e = enemyAt(x,y);
    if (e){
      ensureSkill('bow');
      if (!rollHitFor('bow')){
        spawnFloatText("Miss", e.x, e.y, '#9ca3af'); // <--- ADDED
        SFX.miss();
        log('Your arrow misses.');
        enemyStep(); draw(); return;
      }
      const bonus = skillDamageBonus('bow');
      // Buffed: Was 2-4, now 3-6 (rewarding ammo usage)
      const dmg = rand(3+bonus, 6+bonus);      
      SFX.rangedZap();                      
      e.hp -= dmg;
      
      // --- FIX: Show Bow Damage Text ---
      spawnFloatText(dmg, e.x, e.y, '#fff');
      if (typeof flashEnemy === 'function') flashEnemy(e, 'red'); // Add flash too
      // --------------------------------

      log(`You shoot an arrow for ${dmg}.`);

      // --- TUTORIAL OVERRIDE (Step 8 -> 9) ---
      if (state.gameMode === 'tutorial' && state.tutorialStep === 8 && e.type === 'Rat') {
         if (e.hp - dmg <= 0) {
            state.tutorialStep = 9;
            // Spawn Magic Scroll at Y=35
            state.pickups['10,35'] = {kind:'spell', payload:{name:'Spark', cost:1, tier:1}};
            state.tiles[35][10]=5;

            // FIX: Spawn a Magic Target at Y=38
            state.enemies.push({x:10, y:38, type:'Rat', hp:1, atk:[0,0], xp:0, stunTicks:9999, tutorialDummy:true});
            
            hideBanner();
            showBanner("Step 9: Pickup Scroll. Press (P) to open your spell book. Press (F) to swap between spells. Cast Magic (Q) on the Rat.", 999999);
         }
      }
      // ----------------------------------------

      const isFatal = e.hp <= 0;

      const onDone = ()=>{ 
        // Safety check: ensure enemy exists and is killed if fatal flag was set
        if (isFatal) {
          // 1. Handle Depth 50 Transitions
          if (state.floor === 50 && target.boss && target.type === 'Clone' && !(state.flags?.depth50Phase2)) {
             runDepth50Phase2(target); return;
          }
          if (state.floor === 50 && target.boss && target.type === 'Mad King' && !(state.flags?.depth50Done)) {
             runDepth50Outro(target); return;
          }

          // 2. Remove Enemy & Award XP
          state.enemies = state.enemies.filter(x=>x!==e);
          state.run.kills++; 
          awardKill('bow', Math.max(1, e.xp|0));
          SFX.kill();
          if (typeof log === 'function') log(`${e.type} falls.`);
        }

  enemyStep(); 
  draw(); 
};
      spawnProjectileEffect({
        kind: 'arrow',
        fromX: state.player.x,
        fromY: state.player.y,
        toX: e.x,
        toY: e.y,
        dx,   // from the facing-based direction earlier in shootBow
        dy,
        onDone
      });
      return;
    }
  }

  // nothing hit
  log('You loose an arrow into the hall.');
  enemyStep(); draw();
}



function attack(){
    if (state.gameOver) return;
    if (state._inputLocked || state._descending) return;

    // --- NEW: Staff Magic Shot ---
    if (state.player.weapon && state.player.weapon.type === 'staff') {
        useStaff(state.player.weapon); // Calls helper at bottom of file
        return;
    }
    // -----------------------------

    // New: Stamina Cost for Normal Attack
    if (state.player.stamina < 1) { 
       // Auto-Rest: Pass the turn to regenerate Stamina
       spawnFloatText("Resting...", state.player.x, state.player.y, '#9ca3af'); 
       log("You are out of breath and take a moment to recover.");
       enemyStep(); // Triggers natural regeneration
       draw();
       return; 
    }
    state.player.stamina--; 
    state._skipStaminaRegen = true; // <--- ADD THIS
    updateBars();

    // Tutorial Step 5: require weapon pickup before teaching melee
    if (state.gameMode === 'tutorial' && state._tutBowShot && !state._tutGotWeapon){
      showBanner("Tutorial: Step onto the Shortsword to pick it up first.", 2200);
      return;
    }

  const nbs = neighbors4(state.player.x,state.player.y);

  let target=null, ti=-1;
  for(let i=0;i<state.enemies.length;i++){
    const e=state.enemies[i]; const s=e.size||1;
    if(nbs.some(nb=> nb.x>=e.x && nb.x<e.x+s && nb.y>=e.y && nb.y<e.y+s)){ target=e; ti=i; break; }
  }
  if(!target){ 
    // --- NEW: Check for Smashable Props if no enemy ---
    for(const nb of nbs){
      if(inBounds(nb.x, nb.y) && state.tiles[nb.y][nb.x] === 8){
        handlePropSmash(nb.x, nb.y);
        return; 
      }
    }
    log('No enemy adjacent.'); return; 
  }
  const w = state.player.weapon;
if (!rollHitFor(w.type)){
  spawnFloatText("Miss", target.x, target.y, '#9ca3af'); // <--- ADDED
  log(`You miss the ${target.type}.`); SFX.miss(); enemyStep(); draw(); return;
}

SFX.swingFor(w.type);
// base swing
let dmg = rand(w.min, w.max);

// --- NEW: Cleric Blessing Buff ---
if (state.player.blessTicks > 0) {
  dmg += 2; // Flat +2 Damage
}
// --------------------------------

// --- NEW: Floor Effect Modifiers ---
if (state.floorEffect === 'AntiMagic') {
  dmg = Math.ceil(dmg * 1.5); // Melee buff
} else if (state.floorEffect === 'ArcaneFlux') {
  dmg = Math.ceil(dmg * 0.25); // Melee nerf (weak!)
  if (dmg < 1) dmg = 1;
}
// ----------------------------------

  let note = "";
  let isCrit = false;

  // Two-handed: critical (double the rolled damage)
  if (w.type === 'two' && proc(quirkChance('two'))){
    dmg *= 2;
    note = " (CRITICAL!)";
    isCrit = true;
  }

  target.hp -= dmg;
  if (typeof flashEnemy === 'function') flashEnemy(target, 'red'); 
  
// --- NEW: Floating Text & Vampiric Logic ---
  spawnFloatText(dmg + (isCrit ? "!" : ""), target.x, target.y, isCrit ? '#ff0' : '#fff');
  // Blood Particles (Reduced count)
  if (dmg > 0) spawnParticles(target.x, target.y, '#ef4444', 6);
  
  if (w.vampiric && dmg > 0) {
    // 1. MODIFIED: Scale healing based on 25% of damage dealt (minimum 1)
    const heal = Math.max(1, Math.floor(dmg * 0.25));
    
    state.player.hp = Math.min(state.player.hp + heal, state.player.hpMax);
    spawnFloatText("+" + heal, state.player.x, state.player.y, '#0f0');
    updateBars();
  }
  // ------------------------------------------

log(`You hit the ${target.type} for ${dmg}.${note}`);

  // --- TUTORIAL Step 6 (Melee + Poison) ---
  if (state.gameMode === 'tutorial' && state.tutorialStep === 6 && target.type === 'Rat') {
     // Poison on hit
     if (!state.player.poisoned) {
        state.player.poisoned = true;
        state.player.poisonTicks = 20;
        state.player.hp = Math.max(1, state.player.hp - 5); // Hurt them
        log("You are poisoned!");
        updateBars();
     }
     
     if (target.hp - dmg <= 0) {
        state.tutorialStep = 7;
        // Spawn Antidote & Potion at Y=25
        state.pickups['10,25'] = {kind:'antidote', payload:1};
        state.pickups['11,25'] = {kind:'potion', payload:1};
        state.tiles[25][10]=5; state.tiles[25][11]=5;
        
        hideBanner();
        showBanner("Step 7: Pick up and USE the Antidote (3) and Potion (1).", 999999);
     }
  }


if (dmg > 0) {
  const cvs = document.getElementById('view');
  if (cvs) {
    // 1. Apply a random shake to the canvas
    cvs.style.transform = `translate(${rand(-2,2)}px, ${rand(-2,2)}px)`;
    
    // 2. Set a small timeout to reset the shake and create the "stop" effect
    setTimeout(()=>{
      cvs.style.transform = 'none'; // Reset shake after 60ms
    }, 60); 
  }
}

// Spear: bleed
if (w.type === 'spear' && proc(quirkChance('spear'))){
  applyBleed(target, BLEED_TICKS, BLEED_DMG);
  log('The foe is bleeding!');
}

// Axe: cripple (slow)
if (w.type === 'axe' && proc(quirkChance('axe'))){
  applySlow(target, SLOW_TICKS);
  log('You cripple the foe!');
}

// Hand-to-hand: knockout (stun)
if (w.type === 'hand' && proc(quirkChance('hand'))){
  applyStun(target, STUN_TICKS);
  log('Knockout! The foe is dazed!');
}

// One-handed: follow-up strike for normal roll (no extra hit check; no extra dur loss)
if (w.type === 'one' && proc(quirkChance('one')) && target.hp > 0){
  const dmg2 = rand(w.min, w.max);
  target.hp -= dmg2;
  log(`Follow-up strike hits for ${dmg2}.`);
}

// durability (still only one tick for the whole action)
handleSuccessfulHitDurabilityTick();


  if (target.hp<=0){
        // Depth 50 two-phase hook (inserted)
    if (state.floor === 50 && target.boss && target.type === 'Clone' && !(state.flags && state.flags.depth50Phase2)) {
      // Fade out, delete clone during black, heal player, spawn Mad King, swap BGM
      runDepth50Phase2(target);
      return;
    }
    if (state.floor === 50 && target.boss && target.type === 'Mad King' && !(state.flags && state.flags.depth50Done)) {
      // Final line, fade, stairs, cleanup
      runDepth50Outro(target);
      return;
    }

  // Skeletons reassemble once, weaker
  if (target.type==='Skeleton' && !target._revived){
    target._revived = true;
    target.hp = Math.max(2,  Math.floor( (6) * 0.6 )); // simple weaker return
    target.atk[0] = Math.max(0, target.atk[0]-1);
    target.atk[1] = Math.max(target.atk[0], target.atk[1]-1);
    log('The Skeleton pulls itself back together‚Äîweaker, but still moving!');
    enemyStep(); draw();
    return;
  }

  // Boss dies ‚Üí stairs
  if(target.boss){
    state.tiles[target.y][target.x]=4;
    SFX.bossDown();
    log('A stairway appears where the boss fell!');

    // Pick 1 of 2: boss reward
    if (typeof offerPick2Choice === 'function'){
      offerPick2Choice('boss');
    }
  }

  // Goblin drops anything it stole ‚Äî supports boss multi-steal
if (target.stolenItems && target.stolenItems.length){
  for (const it of target.stolenItems){
    dropStolenNear(target.x, target.y, it);  // won't overwrite stairs
  }
  log('The stolen items scatter onto the floor!');
} else if (target.stolen){
  dropStolenNear(target.x, target.y, target.stolen); // won't overwrite stairs
  log('The stolen item drops to the floor!');
}


 // Award gold directly (no drop) for non-boss (50% chance)
if (!target.boss && Math.random() < GOLD_DROP_CHANCE){
  const g = goldFor(target);
  state.inventory.gold = (state.inventory.gold|0) + g;
  log(`You gain ${g} gold.`);
  if (typeof updateInvBody === 'function') updateInvBody();
}



// --- NEW: Volatile Aether (Death Timer) ---
  if (state.floorEffect === 'VolatileAether') {
    if (!state.explosions) state.explosions = [];
    state.explosions.push({ x: target.x, y: target.y, timer: 3 }); // Explodes in 3 turns
    spawnFloatText("3...", target.x, target.y, '#f97316');
  }
  // ------------------------------------------

// Remove enemy, award XP
  state.enemies.splice(ti,1);
  SFX.kill();                 // ‚Üê enemy down
  unlockCodex(target.displayName || target.type, true);
  log(`${target.type} falls.`);
  state.run.kills++; 
  awardKill(state.player.weapon.type, Math.max(1, target.xp|0));

  // === Tutorial Step 6: teach antidote (3) then potion (1) ===
  if (state.gameMode === 'tutorial' &&
      state._tutGotWeapon &&
      state._tutMeleeHit &&
      !state._tutStep6Started &&
      target.type === 'Rat' &&
      !target.tutorialDummy){
    state._tutStep6Started = true;
    state._tutStep6UsedAntidote = false;
    state._tutStep6UsedPotion = false;

    state.tutorialStep = 6;

    hideBanner();
    showBanner("You‚Äôre poisoned. Press 3 to use an antidote, then press 1 to drink a potion.", 999999);
  }
  
  // --- NEW: Tutorial Step 6.5 (Weapon Arts) ---
  if (state.gameMode === 'tutorial' && state._tutStep6Started && !state._tutArtTargetSpawned) {
    state._tutArtTargetSpawned = true;
    
    // Spawn 2 rats horizontally adjacent
    // ADDED: stunTicks:9999 here as well
    state.enemies.push({
        x:18, y:15, type:'Rat', hp:1, atk:[1,2], xp:3, 
        stunTicks:9999, tutorialDummy:true
    });
    state.enemies.push({
        x:19, y:15, type:'Rat', hp:1, atk:[1,2], xp:3, 
        stunTicks:9999, tutorialDummy:true
    });
    
    // The banner will be updated by the potion logic when you drink it next.
  }
  // ---------------------------------------------
}


  enemyStep();
  draw();
  return;
}

function spawnBossStairs(){
  if (state._bossStairsSpawned) return;
  const r = state.rooms && state.rooms[0] ? state.rooms[0]
      : {x:0, y:0, w:state.size.w, h:state.size.h};
  const sx = Math.floor(r.x + r.w/2);
  const sy = Math.floor(r.y + r.h/2);
  state.tiles[sy][sx] = 4;                 // put stairs down
  state._bossStairsSpawned = true;
  if (typeof ensurePathToStairsUnlocked === 'function'){
    ensurePathToStairsUnlocked();          // open any doors on path (already in your build)
  }
  log('A staircase appears!');
  draw();
}


// === player spell LOS helpers ===
function playerSpellRangeFor(name){
  // tune per spell
  return ({ Spark:2, Ember:3, Frost:3, Gust:2, Pebble:3, Heal:0 }[name] ?? 2);
}

function findFirstLinedTarget(px, py, range){
  const dirs = [
    {dx: 1, dy: 0},  // ‚Üí
    {dx:-1, dy: 0},  // ‚Üê
    {dx: 0, dy: 1},  // ‚Üì
    {dx: 0, dy:-1},  // ‚Üë
  ];
  for (const {dx,dy} of dirs){
    for (let s=1; s<=range; s++){
      const tx = px + dx*s, ty = py + dy*s;
      if (!inBounds(tx,ty)) break;
      // stop if wall blocks
      if (!clearStraightLine(px,py,tx,ty)) break;
      const e = state.enemies.find(en => {
  if (en.size > 1) {
    // any tile in the boss's footprint is targetable
    return tx >= en.x && tx < en.x + en.size &&
           ty >= en.y && ty < en.y + en.size;
  }
  return en.x === tx && en.y === ty;
});
      if (e) return e;
      // if we hit a closed door tile etc, stop (optional depending on your tiles)
      if (state.tiles[ty][tx]===0) break;
    }
  }
  return null;
}



// --- NEW: Weapon Arts (Active Skills) ---
function useWeaponArt(){
  if (state.gameOver || state._inputLocked || state._descending) return;
  
  if (state.player.artCooldown > 0) {
    log(`Ability not ready (${state.player.artCooldown} turns).`);
    return;
  }

  // --- NEW: Stamina Check ---
  const COST = 4;
  if (state.player.stamina < COST) {
    spawnFloatText("Need Stamina", state.player.x, state.player.y, '#9ca3af');
    log(`Not enough Stamina for Weapon Art (${state.player.stamina}/${COST}).`);
    return;
  }
  
  // Deduct Stamina
  state.player.stamina -= COST;
  updateBars();
  // --------------------------

  const w = state.player.weapon;
  const t = w.type;
  let acted = false;

 // 1. CLEAVE (Two-Handed / Axe): Hit all adjacent enemies (including diagonals)
  if (t === 'two' || t === 'axe') {
    SFX.swingFor(t);
    let hitCount = 0;
    const hitList = new Set(); // Prevent hitting the same 2x2 boss multiple times

    // Check 3x3 grid around player
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue; // skip self
        
        const tx = state.player.x + dx;
        const ty = state.player.y + dy;
        const e = enemyAt(tx, ty);
        
        if (e && !hitList.has(e)) {
          hitList.add(e); // Mark enemy as hit for this swing
          
          // 120% Damage
          const dmg = Math.floor(rand(w.min, w.max) * 1.2);
          e.hp -= dmg;
          spawnFloatText(dmg+"!", e.x, e.y, '#ffae00');
          
          if(e.hp <= 0) {
             state.enemies = state.enemies.filter(x=>x!==e);
             state.run.kills++;
             awardKill(t, e.xp);
             SFX.kill();
             if (e.boss) spawnBossStairs(); // Ensure stairs spawn
             
             // --- NEW: Trigger Volatile Aether ---
             if (state.floorEffect === 'VolatileAether') {
                if (!state.explosions) state.explosions = [];
                state.explosions.push({ x: e.x, y: e.y, timer: 3 }); 
                spawnFloatText("3...", e.x, e.y, '#f97316');
             }
             // ------------------------------------
          } else {
             flashEnemy(e, 'red');
          }
          hitCount++;
        }
      }
    }

    if(hitCount > 0) { // <--- FIXED TYPO (was 'hit')
      log(`You Cleave around you, hitting ${hitCount} foes!`);
      acted = true;
      state.player.artCooldown = 15; 
    } else {
      log("No enemies to Cleave.");
    }
  }
  
  // 2. PIERCE (Spear): Attack 2 tiles in a line
  else if (t === 'spear') {
    const dirs = {up:[0,-1],down:[0,1],left:[-1,0],right:[1,0]};
    const [dx,dy] = dirs[state.player.facing || 'down'];
    
    // Check tile 1
    let tx = state.player.x + dx, ty = state.player.y + dy;
    let e1 = enemyAt(tx, ty);
    
    // Check tile 2
    let tx2 = tx + dx, ty2 = ty + dy;
    let e2 = enemyAt(tx2, ty2);
    
    if (e1 || e2) {
      SFX.swingFor('spear');
      const dmg = rand(w.min, w.max);
      
      if(e1) { e1.hp -= dmg; spawnFloatText(dmg, e1.x, e1.y, '#fff'); flashEnemy(e1); if(e1.hp<=0){ state.enemies=state.enemies.filter(x=>x!==e1); state.run.kills++; awardKill(t,e1.xp); } }
      if(e2) { e2.hp -= dmg; spawnFloatText(dmg, e2.x, e2.y, '#fff'); flashEnemy(e2); if(e2.hp<=0){ state.enemies=state.enemies.filter(x=>x!==e2); state.run.kills++; awardKill(t,e2.xp); } }
      
      log("You Pierce through the line!");
      acted = true;
      state.player.artCooldown = 10;
    } else {
      log("Nothing to Pierce.");
    }
  }
  
  // 3. BACKSTAB (Shortsword/One-Handed): Teleport behind enemy and Crit
  else if (t === 'one') {
    const dirs = {up:[0,-1],down:[0,1],left:[-1,0],right:[1,0]};
    const [dx,dy] = dirs[state.player.facing || 'down'];
    const tx = state.player.x + dx, ty = state.player.y + dy;
    const e = enemyAt(tx, ty);
    
    if (e) {
      // Calc spot behind enemy
      const bx = e.x + dx, by = e.y + dy;
      if (inBounds(bx, by) && state.tiles[by][bx] === 1 && !enemyAt(bx, by)) {
        // Teleport (Snap visuals)
        state.player.x = bx; state.player.y = by;
        state.player.rx = bx; state.player.ry = by;
        
        // Crit Damage
        const dmg = rand(w.min, w.max) * 2;
        e.hp -= dmg;
        spawnFloatText("CRIT " + dmg, e.x, e.y, '#ff0');
        flashEnemy(e, 'red');
        SFX.enemyHit();
        log(`Backstab! Critical hit for ${dmg}.`);
        
        if (e.hp <= 0) { state.enemies = state.enemies.filter(x=>x!==e); state.run.kills++; awardKill(t, e.xp); SFX.kill(); }
        
        acted = true;
        state.player.artCooldown = 12;
      } else {
        log("No space behind foe to Backstab.");
      }
    } else {
      log("No enemy to Backstab.");
    }
  }
  
  // 4. FLURRY (Fists): 3 rapid hits for 60% dmg each
  else if (t === 'hand') {
    const nbs = neighbors4(state.player.x, state.player.y);
    const e = state.enemies.find(en => nbs.some(n => n.x===en.x && n.y===en.y));
    
    if(e){
      let total = 0;
      for(let i=0; i<3; i++){
        const d = Math.ceil(rand(w.min, w.max) * 0.6);
        total += d;
        spawnFloatText(d, e.x, e.y - (i*0.2), '#fff');
      }
      e.hp -= total;
      flashEnemy(e);
      SFX.attack();
      log(`Flurry of blows! ${total} total damage.`);
      
      if (e.hp <= 0) { state.enemies = state.enemies.filter(x=>x!==e); state.run.kills++; awardKill(t, e.xp); SFX.kill(); }
      
      acted = true;
      state.player.artCooldown = 8;
    } else {
      log("No enemy to Flurry.");
    }
  }

  // If we used a skill, trigger turns
  if(acted) {
    // 1. Determine the Name of the Art based on the weapon type 't'
    let artName = '';
    if (t === 'two' || t === 'axe') artName = 'Cleave';
    else if (t === 'spear')         artName = 'Pierce';
    else if (t === 'one')           artName = 'Backstab';
    else if (t === 'hand')          artName = 'Flurry';

    // 2. Record the action so the Shadow can copy it
    state.lastPlayerAction = { type: 'art', name: artName }; 
    
    // 3. Unlock the Codex entry for this specific art
    unlockCodex('Art_' + artName, true); 

    // --- TUTORIAL Step 5 -> 6 (Weapon Art) ---
    if (state.gameMode === 'tutorial' && state.tutorialStep === 5) {
      // Check if we killed the dummies
      const liveDummies = state.enemies.filter(e => e.tutorialDummy && e.y === 18).length;
      if (liveDummies === 0 || acted) { // acted means Art fired successfully
         state.tutorialStep = 6;
         // Ensure dummies are dead if they survived somehow
         state.enemies = state.enemies.filter(e => !(e.tutorialDummy && e.y === 18));
         hideBanner();
         showBanner("Step 6: Melee. Attack the next rat with SPACE. Beware poison!", 999999);
      }
    }
    
    // 5. (Existing) End turn and redraw
    updateEquipUI();
    draw();
    enemyStep();
  }
}

function cast(){
 if (state.gameOver) return;
 if (state._inputLocked || state._descending) return;
 const btn = document.getElementById('btnCast');

  // restart flow (unchanged)
  if (btn.dataset.restart === '1'){
  btn.dataset.restart = '';

  // NEW: clear game-over lock + hide modal
  state.gameOver = false;
  const m = document.getElementById('gameOverModal');
  if (m) m.style.display = 'none';

  Object.assign(state.player, {
    hp:20,hpMax:20,mp:10,mpMax:10,level:1,xp:0,next:24,
    weapon:{name:'Fists',min:1,max:2,type:'hand',base:{min:1,max:2},dur:null,durMax:null,shield: null,}
  
    });
    state._hitParity = 0;
    state._shieldParity = 0;
    state.skills = {};
    state.inventory = {
  lockpicks:0, potions:0, tonics:0, antidotes:0,
  weapons:{}, arrows:0, gold:0,
  stashed:{}, shields: 0,          // ‚Üê keep damaged weapon instances here
};


    state.spells = [];
    state.floor = 1;
    gen(); updateBars(); updateEquipUI(); renderSkills();
    log('You awaken with nothing. Explore, loot, survive.');
    log('A chest is nearby.');
    renderLog(); draw(); return;
  }

  // need a spell selected
  if (!state.equippedSpell){
    if (!state.spells.length){ log('No spells have been learned yet.'); }
    else { log('Select a spell in the Spells menu.'); }
    return;
  }

  const spell = state.equippedSpell;

  // --- NEW: Anti-Magic Block ---
  if (state.floorEffect === 'AntiMagic') {
    log('A field of silence prevents magic here!');
    return;
  }
  // -----------------------------
  
  
// Heal resolves immediately (no target)
if (spell.name === 'Heal'){
  const st = getSpellStats('Heal');                 // { cost, pct, range:0 }
  if (state.player.mp < st.cost){ log('Not enough MP.'); return; }
  state.player.mp -= st.cost; updateBars();

  const before = state.player.hp|0;
  const gain   = Math.max(1, Math.round(state.player.hpMax * (st.pct || 0)));
  state.player.hp = clamp(before + gain, 0, state.player.hpMax);
  const healed = state.player.hp - before;

  SFX.spell();
  log(`You cast Heal and restore ${healed} HP (${Math.round((st.pct||0)*100)}%).`);
  draw(); enemyStep(); return;
}



  // Damage/control spells: find LOS target first, THEN spend MP
  const st = getSpellStats(spell.name);               // { cost, min, max, range }
const target = findFirstLinedTarget(state.player.x, state.player.y, st.range);
if (!target){ log('No enemy in line of sight.'); return; }

if (state.player.mp < st.cost){ log('Not enough MP.'); return; }
SFX.spell();
state.player.mp -= st.cost; updateBars();

// --- NEW: Record spell for Shadow ---
state.lastPlayerAction = { type: 'spell', name: spell.name };


  // hit/miss
  if (!rollHitFor('magic')){
    spawnFloatText("Miss", target.x, target.y, '#9ca3af'); // <--- ADDED
    log(`Your ${spell.name} misses.`);
    SFX.miss();
    enemyStep(); draw(); return;
  }

  

// upgraded damage pulled from scaling table
const { min, max } = getSpellStats(spell.name);
let dmg = rand(min, max);

// --- NEW: Staff Elemental Boost ---
const wName = state.player.weapon ? state.player.weapon.name : '';
if (wName.includes('Fire') && spell.name === 'Ember') { dmg+=3; log('Fire Staff boost!'); }
else if (wName.includes('Fire') && spell.name === 'Spark') { dmg+=2; log('Fire Staff boost!'); }
else if (wName.includes('Ice') && spell.name === 'Frost') { dmg+=3; log('Ice Staff boost!'); }
else if (wName.includes('Light') && spell.name === 'Thunder') { dmg+=3; log('Lightning Staff boost!'); }
else if (wName.includes('Wind') && spell.name === 'Gust') { dmg+=3; log('Wind Staff boost!'); }
else if (wName.includes('Earth') && spell.name === 'Pebble') { dmg+=3; log('Earth Staff boost!'); }
// ----------------------------------

// --- NEW: Arcane Flux Boost ---
if (state.floorEffect === 'ArcaneFlux') {
  dmg = Math.ceil(dmg * 1.5);
}
// ------------------------------

target.hp -= dmg;
  if (typeof flashEnemy === 'function') flashEnemy(target, 'red'); 
  spawnParticles(target.x, target.y, '#60a5fa', 6); 
  
  // --- FIX: Show Magic Damage Text (Blue) ---
  spawnFloatText(dmg, target.x, target.y, '#60a5fa');
  // ------------------------------------------

  log(`Your ${spell.name} hits for ${dmg}.`);

// --- TUTORIAL Step 9 (Magic) ---
if (state.gameMode === 'tutorial' && state.tutorialStep === 9) {
  state.tutorialStep = 10;
  state.player.mp = 0; // Drain MP so they need tonic
  // Spawn Tonic
  state.pickups['10,36'] = {kind:'tonic', payload:1};
  state.tiles[36][10]=5;
  
  hideBanner();
  showBanner("Step 10: Low Mana! Mana recharges slowly. Pickup and use the Tonic (2) for instant recharge.", 999999);
}


if (target.hp <= 0){
        // Depth 50 two-phase hook (inserted)
    if (state.floor === 50 && target.boss && target.type === 'Clone' && !(state.flags && state.flags.depth50Phase2)) {
      runDepth50Phase2(target);
      return;
    }
    if (state.floor === 50 && target.boss && target.type === 'Mad King' && !(state.flags && state.flags.depth50Done)) {
      runDepth50Outro(target);
      return;
    }

  // Skeletons reassemble once, weaker
  if (target.type==='Skeleton' && !target._revived){
    target._revived = true;
    target.hp = Math.max(2, Math.floor(6 * 0.6));
    target.atk[0] = Math.max(0, target.atk[0]-1);
    target.atk[1] = Math.max(target.atk[0], target.atk[1]-1);
    log('The Skeleton pulls itself back together‚Äîweaker, but still moving!');
    enemyStep(); draw();
    return;
  }

  // Boss dies ‚Üí stairs
  if (target.boss){
    state.tiles[target.y][target.x] = 4;
    if (SFX.bossDown) SFX.bossDown();
    log('A stairway appears where the boss fell!');

    // Pick 1 of 2: boss reward
    if (typeof offerPick2Choice === 'function'){
      offerPick2Choice('boss');
    }
  }

  // Goblin drops anything it stole
  if (target.stolen){
    dropStolenAt(target.x, target.y, target.stolen);
    log('The stolen item drops to the floor!');
  }

 // Award gold directly (no drop) ‚Äî 50% chance
if (!target.boss && Math.random() < GOLD_DROP_CHANCE){
  const g = goldFor(target);
  state.inventory.gold = (state.inventory.gold|0) + g;
  log(`You gain ${g} gold.`);
  if (typeof updateInvBody === 'function') updateInvBody();
}


  // Remove enemy, award XP
  state.enemies = state.enemies.filter(x => x !== target);
  if (SFX.kill) SFX.kill();
  unlockCodex(target.displayName || target.type, true);
  log(`${target.type} falls.`);
  state.run.kills++;
  awardKill('magic', Math.max(1, target.xp|0));
}

// After hit / kill logic, let a projectile travel if the enemy
// is not right next to us. Heal already returned earlier.
const onDone = ()=>{ enemyStep(); draw(); };

spawnProjectileEffect({
  kind: 'magic',
  element: spell.name,          // for color
  fromX: state.player.x,
  fromY: state.player.y,
  toX: target.x,
  toY: target.y,
  onDone
});

return;
}


// --- Allowed merchant weapons (must match your game) ---
const MERCHANT_WEAPON_NAMES = ['Shortsword','Claymore','Spear','Axe','Knuckle Duster'];

// Pull stats from the same mapping used by equipWeaponByName()
function weaponStatsFor(name){
  let baseName = name;
  let bonMin=0, bonMax=0;
  
  // FIX: Strip Cursed prefix so the base type/stats lookup works
  if (name.includes('Cursed ')) {
     baseName = baseName.replace('Cursed ', '');
     baseName = baseName.replace('Blood ', '').replace('Greed ', '').replace('Rust ', '').replace('Frailty ', '');
  }

  if (name.includes('Sharp '))       { baseName = baseName.replace('Sharp ', '');   bonMin+=1; bonMax+=1; }
  else if (name.includes('Heavy '))  { baseName = baseName.replace('Heavy ', '');   bonMax+=3; }
  else if (name.includes('Vampiric ')){ baseName = baseName.replace('Vampiric ', ''); }
  else if (name.includes('Ancient ')) { baseName = baseName.replace('Ancient ', '');  bonMin+=2; bonMax+=2; }

const stats = {
    'Shortsword': [3,5,'one'],
    'Claymore':   [5,9,'two'],
    'Spear':      [4,7,'spear'],
    'Axe':        [4,8,'axe'],
    'Knuckle Duster': [3,5,'hand'],
    'Key of Destiny': [5,7,'one'],
    
    // --- NEW MELEE ---
    'Warhammer':      [6,10,'two'],
    'Battleaxe':      [5,10,'axe'],
    'Halberd':        [5,9,'spear'],
    'Claws':          [4,6,'hand'],

    // --- NEW STAFFS ---
    'Fire Staff':     [2,4,'staff'], 
    'Ice Staff':      [2,4,'staff'], 
    'Lightning Staff':[2,4,'staff'],
    'Wind Staff':     [2,4,'staff'], 
    'Earth Staff':    [2,4,'staff'],

    // --- NEW SHIELDS ---
    'Buckler':        [1,2,'shield'], 
    'Kite Shield':    [2,3,'shield'], 
    'Tower Shield':   [3,4,'shield'], 
    'Ancient Shield': [2,4,'shield']
  }[baseName];
  
  return stats ? { name, min:stats[0]+bonMin, max:stats[1]+bonMax, type:stats[2] } : null;
}

// Simple price table (tune freely)
const MERCHANT_WEAPON_PRICES = {
  'Shortsword': 18,
  'Claymore':   28,
  'Spear':      22,
  'Axe':        24,
  'Knuckle Duster': 14
};

function makeWeaponOffer(){
  const name = MERCHANT_WEAPON_NAMES[rand(0, MERCHANT_WEAPON_NAMES.length-1)];
  const st = weaponStatsFor(name);
  const price = depthPrice(MERCHANT_WEAPON_PRICES[name] || 20);
  return {
    kind: 'buy',
    item: `${name} (${st.min}‚Äì${st.max})`,
    price,
    do: ()=>{
      // Add like chest loot does:
      // state.inventory.weapons[w.name] = (state.inventory.weapons[w.name] || 0) + 1;
      state.inventory.weapons[name] = (state.inventory.weapons[name] || 0) + 1;
    }
  };
}

function makeWeaponOffer(){
  const name = MERCHANT_WEAPON_NAMES[rand(0, MERCHANT_WEAPON_NAMES.length-1)];
  const st = weaponStatsFor(name);

  // SAFETY GUARD: if a name slipped in without stats, fall back to a potion
  if (!st) {
    console.warn('Merchant picked unknown weapon:', name);
    return { kind:'buy', item:'Potion', price: depthPrice(10),
             do:()=>{ state.inventory.potions=(state.inventory.potions|0)+1; } };
  }

  const price = depthPrice(MERCHANT_WEAPON_PRICES[name] || 20);
  return {
    kind: 'buy',
    item: `${name} (${st.min}‚Äì${st.max})`,
    price,
    do: ()=>{
      state.inventory.weapons[name] = (state.inventory.weapons[name] || 0) + 1;
    }
  };


  // merchant buys extras from player (defined here as >3 in stock)
  const sells = [];
  if ((state.inventory.potions|0)   > 3) sells.push({kind:'sell', item:'Potion',   price:5, do:()=>{ state.inventory.potions--;   state.inventory.gold=(state.inventory.gold|0)+5; }});
  if ((state.inventory.tonics|0)    > 3) sells.push({kind:'sell', item:'Tonic',    price:6, do:()=>{ state.inventory.tonics--;    state.inventory.gold=(state.inventory.gold|0)+6; }});
  if ((state.inventory.antidotes|0) > 3) sells.push({kind:'sell', item:'Antidote', price:7, do:()=>{ state.inventory.antidotes--; state.inventory.gold=(state.inventory.gold|0)+7; }});
  if ((state.inventory.lockpicks|0) > 3) sells.push({kind:'sell', item:'Lockpick', price:8, do:()=>{ state.inventory.lockpicks--; state.inventory.gold=(state.inventory.gold|0)+8; }});

  // 2 buys + 1 sell (if any)
  const out = [];
  // Grab two unique buys
  while (out.length < 2 && buys.length){
    const i = rand(0, buys.length-1);
    out.push(buys.splice(i,1)[0]);
  }
  // Add a sell if available
  if (sells.length) out.push(sells[rand(0, sells.length-1)]);

  return out;
}

// ===== Merchant modal wiring (Buy/Sell greeting) =====
document.addEventListener('DOMContentLoaded', ()=>{
  // DOM
  const modal   = document.getElementById('merchantModal');
  const goldNow = document.getElementById('goldNow');
  const msg     = document.getElementById('merchantMsg');
  const btnA    = document.getElementById('mOfferA');
  const btnB    = document.getElementById('mOfferB');
  const btnC    = document.getElementById('mOfferC');
  const backBtn = document.getElementById('mBack');

  // Header Back/Close logic (kept local so the element exists)
  function setBackMode(mode){
    if (!backBtn) return;

    // clear stale state
    backBtn.removeAttribute('data-close');
    backBtn.onclick = null;

    if (mode === 'hide'){                 // greeting: hide header button
      backBtn.style.display = 'none';
    } else if (mode === 'back'){          // inside Buy/Sell: show Back
      backBtn.style.display = '';
      backBtn.textContent = 'Back';
      backBtn.onclick = renderGreeting;
    } else {                              // 'close' (if you ever want a real close)
  backBtn.style.display = '';
  backBtn.textContent = 'Close';
  backBtn.setAttribute('data-close','1');
  backBtn.onclick = ()=>{
    modal.style.display='none';

    // Unlock controls when closing via header
    state._inputLocked = false;

    if (!state._pauseOpen) {
      setMobileControlsVisible?.(true);
    }
  };
}

  }

  // --- Merchant weapon catalog (must match your real weapons) ---
  const MERCHANT_WEAPON_NAMES = ['Shortsword','Claymore','Spear','Axe','Knuckle Duster'];
  const MERCHANT_WEAPON_PRICES = {
    'Shortsword': 28,
    'Claymore':   42,
    'Spear':      36,
    'Axe':        38,
    'Knuckle Duster': 22
  };
  function weaponStatsFor(name){
    const stats = {
      'Shortsword': [3,5,'one'],
      'Claymore':   [5,9,'two'],
      'Spear':      [4,7,'spear'],
      'Axe':        [4,8,'axe'],
      'Knuckle Duster': [2,4,'hand'],
      'Key of Destiny': [5,7,'one']
    }[name];
    return stats ? { name, min:stats[0], max:stats[1], type:stats[2] } : null;
  }

  // Depth price: +10% every 3 floors
  function depthPrice(base){
    const f = state.floor | 0;
    const mult = 1 + 0.10 * Math.floor(Math.max(0, f - 1) / 3);
    return Math.ceil(base * mult);
  }

  // Labels and button binding
  const label = (o)=> o.kind==='buy'
  ? `Buy ${o.item} ‚Äî ${o.price}g${Number.isFinite(o.stock) ? ` (${o.stock} left)` : ''}`
  : `Sell ${o.item} ‚Äî +${o.price}g`;


  const bind = (el, text, fn)=>{
    // reset stale SOLD / disabled / pointer state from previous screen
    el.disabled = false;
    el.style.opacity = 1;
    el.style.pointerEvents = '';
    el.textContent = text || '';
    el.style.display = text ? '' : 'none';
    el.onclick = fn || null;
  };

  // Persistent 3-offer stock (per floor)
  function getBuyStock(){
    if (!state.merchant) state.merchant = {};
    if (!state.merchant.stock){
      state.merchant.stock = merchantBuyOnly().map(o => ({ ...o, sold:false }));
    }
    return state.merchant.stock;
  }

  // Random weapon line (guarded so it never crashes)
  function makeWeaponOffer(){
    const name = MERCHANT_WEAPON_NAMES[rand(0, MERCHANT_WEAPON_NAMES.length-1)];
    const st = weaponStatsFor(name);

    // Guard: if a weapon name slipped in without stats, fall back to a Potion
    if (!st){
      return {
        kind:'buy', item:'Potion', price: depthPrice(10),
        do:()=>{ state.inventory.potions=(state.inventory.potions|0)+1; }
      };
    }

    const price = depthPrice(MERCHANT_WEAPON_PRICES[name] || 20);
    return {
      kind: 'buy',
      item: `${name} (${st.min}‚Äì${st.max})`,
      price,
      do: ()=>{
        state.inventory.weapons[name] = (state.inventory.weapons[name] || 0) + 1;
      }
    };
  }

  
  // BUY: always 3 purchase choices (bundled consumables only)
function merchantBuyOnly(){
  const mk = (label, unitBasePrice, invKey) => {
    const stock = rand(1,5);
    const price = depthPrice(unitBasePrice);
    return {
      kind: 'buy',
      item: label,
      price,
      stock,
      do: ()=>{ state.inventory[invKey] = (state.inventory[invKey] | 0) + 1; }
    };
  };

  // Just return the fixed array directly. 
  // If you add more items later, bring back the shuffle.
  return [
    mk('Potion',   10, 'potions'),
    mk('Tonic',    12, 'tonics'),
    mk('Lockpick', 15, 'lockpicks'),
  ];
}



  // --- RENDERERS ---
  function renderBuy(){
    setBackMode('back');
    const offers = getBuyStock();
    msg.textContent = "I've got plenty of things that might interest you.";

    const paint = (btn, o) => {
      if (!o){ btn.style.display = 'none'; return; }
      const text = o.sold ? (label(o) + ' ‚Äî SOLD') : label(o);
      btn.textContent = text;
      btn.style.display = '';
      btn.disabled = !!o.sold;
      btn.style.opacity = o.sold ? 0.5 : 1;
      btn.style.pointerEvents = o.sold ? 'none' : '';
      btn.onclick = o.sold ? null : () => doBuy(o);
    };

function doBuy(o){
  const have = (state.inventory.gold|0);
  if (have < o.price){ msg.textContent = 'Not enough gold.'; return; }

  // Audio removed here (plays only on entering menu)

  state.inventory.gold = have - o.price;
  o.do();                                 // grant ONE item

  if (Number.isFinite(o.stock)) {
    o.stock = Math.max(0, o.stock - 1);   // decrement per click
    o.sold  = (o.stock <= 0);             // SOLD when stock runs out
  } else {
    o.sold = true;                        // fallback for any legacy line
  }
unlockCodex('Merchant_Bought', true); // <--- TRACK PURCHASE
  goldNow.textContent = state.inventory.gold|0;
  updateInvBody?.();
  renderBuy();                            // refresh labels / SOLD state
}



    paint(btnA, offers[0]);
    paint(btnB, offers[1]);
    paint(btnC, offers[2]);
  }

  function renderSell(){
    setBackMode('back');
    msg.textContent = "I'll buy just about anything you have. ";

    // Build three sell picks (only if you have extras)
    const picks = [];
    const push = (cond, label, price, doSell)=>{ if (cond) picks.push({label, price, doSell}); };

    // weapons: if you have >1 of any weapon, allow selling one
    // weapons: allow selling any you own; if it was the last equipped copy, swap to Fists
for (const [wName, count] of Object.entries(state.inventory.weapons || {})) {
  if (count > 0) {
    const price = Math.max(5, Math.floor((MERCHANT_WEAPON_PRICES[wName] || 20) * 0.5));
    picks.push({
      label: `Sell ${wName}`,
      price,
      doSell: () => {
        const equipped = state.player.weapon?.name === wName;
        const stashedCnt = (state.inventory.stashed?.[wName]?.length) || 0;

        // CHECK: If this is the last copy you own (inventory + stash) AND it's equipped
        if (equipped && count <= 1 && stashedCnt === 0) {
          // Force switch to Fists + recompute/UI update immediately
          state.player.weapon = {name:'Fists',min:1,max:2,type:'hand',base:{min:1,max:2},dur:null,durMax:null};
          
          if (typeof recomputeWeapon === 'function') recomputeWeapon();
          if (typeof updateEquipUI === 'function') updateEquipUI(); // <-- CRITICAL: Force HUD update NOW
          
          if (typeof log === 'function') log(`Sold your last ${wName}. Equipped Fists.`);
          
          if (state.player.shield) { 
            // Also unequip the shield if it was equipped with this two-handed weapon, 
            // though Fists should allow a shield, so this may not be needed, but safe to keep.
            unequipShield(); 
          }
        }
        
        // Decrement inventory count and gain gold
        state.inventory.weapons[wName] = Math.max(0, (state.inventory.weapons[wName] | 0) - 1);
        
        // CRITICAL STEP: CLEAN UP THE ZERO-COUNT ENTRY
        if (state.inventory.weapons[wName] === 0) {
            delete state.inventory.weapons[wName];
        }
        
        state.inventory.gold = (state.inventory.gold | 0) + price;
      }
    });
  }
}


    // paint up to three
    const paintSell = (btn, pick)=>{
  if (!pick){ bind(btn, '', null); return; }
  bind(btn, `${pick.label} ‚Äî +${pick.price}g`, ()=>{
    // Audio removed here (plays only on entering menu)
    pick.doSell();
    unlockCodex('Merchant_Sold', true); // <--- TRACK SALE
    goldNow.textContent = state.inventory.gold|0;
    updateInvBody?.();
    renderSell();
  });
};


    paintSell(btnA, picks[0] || null);
    paintSell(btnB, picks[1] || null);
    paintSell(btnC, picks[2] || null);
  }

function renderGreeting(){
    setBackMode('hide');
    msg.textContent = 'Hello adventurer, are you looking to buy or sell?';
    [btnA, btnB, btnC].forEach(b=>{
      b.disabled = false; b.style.opacity = 1; b.style.pointerEvents = '';
    });

    bind(btnA, 'Buy',  ()=>{
      playNpcDialogue(NPC_DIALOGUE_URLS.merchant.buy);
      renderBuy();
    });

    bind(btnB, 'Sell', ()=>{
      playNpcDialogue(NPC_DIALOGUE_URLS.merchant.sell);
      renderSell();
    });

    bind(btnC, 'Leave', ()=>{
      playNpcDialogue(NPC_DIALOGUE_URLS.merchant.leave);
      modal.style.display='none';

      // Unlock controls when leaving the merchant
      state._inputLocked = false;

      if (!state._pauseOpen) {
        setMobileControlsVisible?.(true);
      }
    });
  }

  // Public opener
  window.openMerchant = function openMerchant(){
    if (!modal) return;
    unlockCodex('Merchant'); // <--- ADD THIS
    playNpcDialogue(NPC_DIALOGUE_URLS.merchant.interact);

    goldNow.textContent = state.inventory.gold|0;
    renderGreeting();
    modal.style.display = 'flex';

    // Lock player input while talking to the merchant
    state._inputLocked = true;

    setMobileControlsVisible?.(false);
  };

});


// ===== Blacksmith modal wiring (repairs @ 2g per durability) =====
document.addEventListener('DOMContentLoaded', ()=>{
  const modal = document.getElementById('blacksmithModal');
  const bsMsg = document.getElementById('bsMsg');
  const bsGold= document.getElementById('bsGold');
  const b1 = document.getElementById('bsRepair1');
  const b5 = document.getElementById('bsRepair5');
  const bf = document.getElementById('bsRepairFull');

  let bsTarget = 'weapon'; // 'weapon' | 'shield'

function refreshBsUI(){
  const tgtW = document.getElementById('bsTargetWeapon');
  const tgtS = document.getElementById('bsTargetShield');

  const w  = state.player.weapon || {};
  const sh = state.player.shield || null;

  // Default target to something repairable if needed
  if (bsTarget === 'weapon' && !w.durMax && sh) bsTarget = 'shield';
  if (bsTarget === 'shield' && !sh && w.durMax) bsTarget = 'weapon';

  // Enable/disable target buttons based on availability
  if (tgtW) tgtW.disabled = !w.durMax;
  if (tgtS) tgtS.disabled = !sh;

  bsGold.textContent = (state.inventory.gold|0);

  let name, dur, max;
  if (bsTarget === 'shield'){
    name = SHIELD_NAME;
    dur  = (sh?.dur|0);
    max  = SHIELD_DUR;
  } else {
    name = w.name || '‚Äî';
    dur  = (w.dur|0);
    max  = (w.durMax|0);
  }

  if (!max){
    bsMsg.textContent = `Equipped: ${name}. This can‚Äôt be repaired.`;
    b1.disabled = b5.disabled = bf.disabled = true;
    return;
  }
  if (dur >= max){
    bsMsg.textContent = `Equipped: ${name} ${dur}/${max}. Already at full.`;
    b1.disabled = b5.disabled = bf.disabled = true;
    return;
  }

  const need = max - dur;
  // Cost scales: 2 base + 0.5 per floor. (Floor 10 = 7g/point, Floor 50 = 27g/point)
  const costPerPoint = Math.ceil(2 + (state.floor * 0.5)); 
  const costFull = need * costPerPoint;
  
  bsMsg.textContent = `Equipped: ${name} ${dur}/${max}. Repairs cost ${costPerPoint}g each. Full repair costs ${costFull}g.`;
  b1.disabled = (state.inventory.gold|0) < costPerPoint;
  b5.disabled = ((state.inventory.gold|0) < (costPerPoint * Math.min(5, need))) || need < 1;
  bf.disabled = (state.inventory.gold|0) < costFull;
}


function doRepair(points){
  const usingShield = (bsTarget === 'shield');
  let repairedToFull = false;
  let itemDur = 0;
  let itemMax = 0;
  let itemName = '';
  
  if (usingShield){
    const sh = state.player.shield; if (!sh) return;
    const need = Math.max(0, SHIELD_DUR - (sh.dur|0));
    if (need <= 0) return;
    const amt  = Math.max(1, Math.min(points, need));
    const costPerPoint = Math.ceil(2 + (state.floor * 0.5)); 
    const cost = amt * costPerPoint;
    if ((state.inventory.gold|0) < cost){ log('Not enough gold.'); return; }
    
    // Perform Repair
    state.inventory.gold -= cost;
    sh.dur = (sh.dur|0) + amt;
    repairedToFull = sh.dur >= SHIELD_DUR;
    log(`Blacksmith repaired ${SHIELD_NAME} +${amt} for ${cost}g.`);
    itemName = SHIELD_NAME;
  } else {
    const w = state.player.weapon || {};
    if (!w.durMax) return;
    const need = Math.max(0, w.durMax - (w.dur|0));
    if (need <= 0) return;
    const amt  = Math.max(1, Math.min(points, need));
    const cost = amt * 2;
    if ((state.inventory.gold|0) < cost){ log('Not enough gold.'); return; }
    
    // Perform Repair
    state.inventory.gold -= cost;
    w.dur = (w.dur|0) + amt;
    repairedToFull = w.dur >= w.durMax;
    log(`Blacksmith repaired ${w.name} +${amt} for ${cost}g.`);
    itemName = w.name;
  }
  
  // --- NEW DIALOGUE LOGIC ---
  if (repairedToFull) {
    playNpcDialogue(NPC_DIALOGUE_URLS.blacksmith.fullrepair);
  } else {
    playNpcDialogue(NPC_DIALOGUE_URLS.blacksmith.partialrepair);
  }
  
unlockCodex('Blacksmith_Repair', true); // <--- TRACK REPAIR
  updateEquipUI?.(); updateInvBody?.(); refreshBsUI();
}


const tgtW = document.getElementById('bsTargetWeapon');
const tgtS = document.getElementById('bsTargetShield');
if (tgtW) tgtW.onclick = ()=>{ bsTarget='weapon'; refreshBsUI(); };
if (tgtS) tgtS.onclick = ()=>{ bsTarget='shield'; refreshBsUI(); };


  if (b1) b1.onclick = ()=>doRepair(1);
  if (b5) b5.onclick = ()=>doRepair(5);
  if (bf) bf.onclick = ()=>doRepair(999);

  // global open
 window.openBlacksmith = function openBlacksmith(){
  unlockCodex('Blacksmith'); // <--- ADD THIS
  playNpcDialogue(NPC_DIALOGUE_URLS.blacksmith.interact);

  refreshBsUI();
  modal.style.display = 'flex';

  // Lock player input while at the blacksmith
  state._inputLocked = true;

  setMobileControlsVisible(false);
};

});

document.addEventListener('DOMContentLoaded', ()=>{
  const modal   = document.getElementById('jesterModal');
  const msg     = document.getElementById('jesterMsg');
  const spinBtn = document.getElementById('jSpin');
  const doneBtn = document.getElementById('jDone');
  const closeBtn= document.getElementById('jBack');
  // (no local "spun" flag ‚Äî rely on state.jesterSpun instead)

  drawJesterWheelCanvas(); // ‚úÖ INSERT THIS TO INITIALLY DRAW THE WHEEL

  // Close button
if (closeBtn) {
  closeBtn.onclick = ()=>{
    playNpcDialogue(NPC_DIALOGUE_URLS.jester.leave);
    modal.style.display = 'none';
    state._inputLocked = false;
    if (!state._pauseOpen) setMobileControlsVisible?.(true);
  };
}

// Spin button
if (spinBtn) spinBtn.onclick = () => {
  if (state.jesterSpun) return;

  playNpcDialogue(NPC_DIALOGUE_URLS.jester.spin);

// In jesterModal wiring, inside spinBtn.onclick
  state.jesterSpun = true;
  spinBtn.disabled = true;

unlockCodex('Jester_Spin', true); // <--- TRACK SPIN

    const wheelCanvas = document.getElementById('jesterWheel');

    // 1) Spin to a random angle (so the result is visual-first)
    const baseTurns    = 25;                // Increased turns so it spins fast for 10s
    const extraDegrees = Math.random() * 360; // 0‚Äì359.999
    const finalDeg     = baseTurns * 360 + extraDegrees;

    // Override CSS transition to match the 10.6s audio length
    wheelCanvas.style.transition = "transform 10.6s ease-out";
    
    // Force browser reflow to ensure the transition takes hold
    wheelCanvas.getBoundingClientRect(); 
    
    wheelCanvas.style.transform = `rotate(${finalDeg}deg)`;

    // 2) Wait for the VISUAL animation to end (Syncs perfectly)
    const onSpinEnd = () => {
      wheelCanvas.classList.add('glow');

      const ctx = wheelCanvas.getContext('2d');
      const W = wheelCanvas.width, H = wheelCanvas.height;
      const centerX = W / 2, centerY = H / 2;
      const radius  = Math.min(W, H) / 2 - 10;

      // Normalize final rotation to [0, 360)
      const deg360 = ((finalDeg % 360) + 360) % 360;

      // Arrow is at 270¬∞ (straight up in canvas coords).
      // Convert that into wheel coordinates after rotation.
      const arrowInWheel = (270 - deg360 + 360) % 360;

      // 10 slices, each 36¬∞
      const winningSlice = Math.floor(arrowInWheel / 36);

      // 3) Highlight the winning slice under the arrow
      ctx.save();
      ctx.globalAlpha = 0.4;
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      const startAngle = (2 * Math.PI / 10) * winningSlice;
      const endAngle   = startAngle + 2 * Math.PI / 10;
      ctx.arc(centerX, centerY, radius, startAngle, endAngle);
      ctx.closePath();
      ctx.fillStyle = '#ffff00';
      ctx.fill();
      ctx.restore();

      // 4) Apply reward/punishment based on the color of that slice
if (winningSlice % 2 === 1) {
  // odd = green (your draw function alternates starting red at 0)
  state.player.hp = state.player.hpMax;
  state.inventory.gold = (state.inventory.gold|0) + 100;
  msg.textContent = "Lucky you!";
  playNpcDialogue(NPC_DIALOGUE_URLS.jester.win);
  log('[Jester] Landed on GREEN: healed & +100g.');
} else {
  // even = red
  state.player.hp = Math.max(1, Math.floor(state.player.hpMax * 0.05));
  msg.textContent = "Ha ha ha, better luck next time!";
  playNpcDialogue(NPC_DIALOGUE_URLS.jester.lose);
      log('[Jester] Landed on RED: HP dropped to 5%.');
    }

    updateBars?.();
    }; // End of onSpinEnd function

    // Attach the listener
    wheelCanvas.addEventListener('transitionend', onSpinEnd, { once: true });
  };


  // Done/Leave button
  if (doneBtn) doneBtn.onclick = ()=>{
  playNpcDialogue(NPC_DIALOGUE_URLS.jester.leave);
  modal.style.display = 'none';
  state._inputLocked = false;
  if (!state._pauseOpen) setMobileControlsVisible?.(true);
};

});

// NEW: Cartographer modal wiring
document.addEventListener('DOMContentLoaded', ()=>{
  const modal   = document.getElementById('cartographerModal');
  const msg     = document.getElementById('cartographerMsg');
  const buyBtn  = document.getElementById('cBuyMap');
  const doneBtn = document.getElementById('cDone');
  const closeBtn= document.getElementById('cBack');
  const goldNow = document.getElementById('cGoldNow');

  const mapCost = ()=> Math.max(15, 20 + (state.floor|0)*3);

  function renderCarto(){
    if (!modal) return;
    const cost = mapCost();
    if (goldNow) goldNow.textContent = state.inventory.gold|0;

    if (state.cartographerMapBought){
      if (msg) msg.textContent = "Already mapped. Follow the arrow to the stairs.";
      if (buyBtn){ buyBtn.disabled = true; buyBtn.textContent = "Map bought"; }
      return;
    }
    if (msg) msg.textContent = `For ${cost} gold, I will reveal the entire floor and mark the way down.`;
    if (buyBtn){ buyBtn.disabled = false; buyBtn.textContent = `Buy Map (${cost}g)`; }
  }

function close(){
  if (!modal) return;
  playNpcDialogue(NPC_DIALOGUE_URLS.cartographer.leave);
  modal.style.display = 'none';
  state._inputLocked = false;
  if (!state._pauseOpen) setMobileControlsVisible?.(true);
}

window.openCartographer = function openCartographer(){
  if (!modal) return;
  unlockCodex('Cartographer'); // <--- ADD THIS
  playNpcDialogue(NPC_DIALOGUE_URLS.cartographer.interact);
  renderCarto();
  modal.style.display = 'flex';
  state._inputLocked = true;
  setMobileControlsVisible?.(false);
};

// --- NEW: Cleric Wiring ---
(function(){
  const modal = document.getElementById('clericModal');
  const msg = document.getElementById('clericMsg');
  const buyBtn = document.getElementById('clBuyBless');
  const doneBtn = document.getElementById('clDone');
  const closeBtn = document.getElementById('clBack');
  const goldNow = document.getElementById('clGoldNow');

  function close(){
    if (modal && modal.style.display !== 'none') {
        playNpcDialogue(NPC_DIALOGUE_URLS.cleric.leave); // <--- Play Goodbye
        modal.style.display = 'none';
    }
    state._inputLocked = false;
    if (!state._pauseOpen) setMobileControlsVisible?.(true);
  }

window.openCleric = function(){
    if (!modal) return;
    unlockCodex('Cleric'); 
    unlockCodex('Cleric_Bless', true);
    
    // Play Hello
    playNpcDialogue(NPC_DIALOGUE_URLS.cleric.interact);

    if (goldNow) goldNow.textContent = state.inventory.gold|0;
    
    const w = state.player.weapon;
    
    // --- NEW: Check for Cursed Weapon ---
    if (w && w.cursed) {
       msg.textContent = "I sense a dark binding on your weapon. I can purify it.";
       buyBtn.disabled = false;
       buyBtn.textContent = "Purify (100g)";
       
       // Override click handler for this specific case
       buyBtn.onclick = () => {
         if ((state.inventory.gold|0) < 100) {
           msg.textContent = "Purification requires a sacrifice of 100 gold.";
           return;
         }
         state.inventory.gold -= 100;
         
         // Remove curse properties
         delete w.cursed;
         delete w.curseType;
         // Note: We leave the high stats as a reward for surviving/paying!
         
         SFX.levelUp();
         playNpcDialogue(NPC_DIALOGUE_URLS.cleric.purify); // <--- Play Purify line
         log("The curse is lifted! The weapon is now yours to command.");
         close();
         updateEquipUI();
         updateInvBody();
         updateBars();
       };
    } 
    // Normal Blessing Logic
    else if (state.player.blessTicks > 0) {
       msg.textContent = "You are already walking in the light.";
       buyBtn.disabled = true;
       buyBtn.textContent = "Blessed";
    } else {
       msg.textContent = "The shadows are deep here. I can bless you for a price.";
       buyBtn.disabled = false;
       buyBtn.textContent = "Blessing (50g)";
       
       // Restore standard blessing handler
       buyBtn.onclick = ()=>{
         if ((state.inventory.gold|0) < 50) {
           msg.textContent = "The light is free, but my time is not. Come back with gold.";
           return;
         }
         state.inventory.gold -= 50;
         state.player.blessTicks = 50; 
         SFX.levelUp(); 
         spawnParticles(state.player.x, state.player.y, '#fbbf24', 12);
         log("You feel a holy power surround you! (+ATK, +DEF)");
         close();
         updateBars();
         draw();
       };
    }
    
    modal.style.display = 'flex';
    state._inputLocked = true;
    setMobileControlsVisible?.(false);
  };

  if (closeBtn) closeBtn.onclick = close;
  if (doneBtn) doneBtn.onclick = close;
  
  if (buyBtn) buyBtn.onclick = ()=>{
    if ((state.inventory.gold|0) < 50) {
      msg.textContent = "The light is free, but my time is not. Come back with gold.";
      return;
    }
    state.inventory.gold -= 50;
    state.player.blessTicks = 50; // Lasts 50 turns
    
    SFX.levelUp(); 
    playNpcDialogue(NPC_DIALOGUE_URLS.cleric.buy); // <--- Play Blessing line
    spawnParticles(state.player.x, state.player.y, '#fbbf24', 12);
    log("You feel a holy power surround you! (+ATK, +DEF)");
    
    close();
    updateBars();
    draw();
  };
})();
// --------------------------

  if (closeBtn) closeBtn.onclick = close;
  if (doneBtn)  doneBtn.onclick  = close;

if (buyBtn) buyBtn.onclick = ()=>{
  const cost = mapCost();
  if ((state.inventory.gold|0) < cost){
    if (msg) msg.textContent = "Come back when you can afford ink and parchment.";
    return;
  }

  state.inventory.gold = (state.inventory.gold|0) - cost;
  state.cartographerMapBought = true;
  state.cartographerMapActive = true;

  playNpcDialogue(NPC_DIALOGUE_URLS.cartographer.buy);
unlockCodex('Cartographer_Map', true); // <--- TRACK MAP PURCHASE
  cartographerRevealFloor();
  renderCarto();

  updateBars?.();
  draw?.();
  showBanner?.("A floor map is unrolled before you. The way down is marked.", 3200);
};

});


// Separate draw function you can place globally
function drawJesterWheelCanvas() {
  const canvas = document.getElementById('jesterWheel');
  if (!canvas) return;

  const ctx = canvas.getContext('2d');

  // Use the canvas element's own size (from width/height attributes)
  const W = canvas.width;   // 180
  const H = canvas.height;  // 180

  const centerX = W / 2;
  const centerY = H / 2;
  const radius  = Math.min(W, H) / 2 - 8;

  const red   = '#bd2220';
  const green = '#22c55e';

  ctx.clearRect(0, 0, W, H);

  const sliceAngle = (Math.PI * 2) / 10;   // 10 equal slices

  for (let i = 0; i < 10; i++) {
    const startAngle = sliceAngle * i;
    const endAngle   = startAngle + sliceAngle;

    ctx.beginPath();
    ctx.moveTo(centerX, centerY);
    ctx.arc(centerX, centerY, radius, startAngle, endAngle);
    ctx.closePath();

    // Even = red, odd = green  -> 5 of each, alternating
    ctx.fillStyle = (i % 2 === 0) ? red : green;
    ctx.fill();
  }
}



// Public opener
window.openJester = function openJester(){
  const modal = document.getElementById('jesterModal');
  if (!modal || state.jesterSpun) return;

  unlockCodex('Jester'); // <--- ADD THIS
  playNpcDialogue(NPC_DIALOGUE_URLS.jester.interact);

  msg = document.getElementById('jesterMsg');
  msg.textContent = 'Spin the wheel of fate! Land on green to win big, red means a big loss...';

  const wheel = document.getElementById('jesterWheel');
  wheel.classList.remove('glow');
  
  // Remove transition for instant reset
  wheel.style.transition = 'none'; 
  wheel.style.transform = 'rotate(0deg)';
  
  document.getElementById('jSpin').disabled = false;

  modal.style.display = 'flex';
  drawJesterWheelCanvas();   // ‚Üê ensure the wheel is visible
  state._inputLocked = true;
  setMobileControlsVisible?.(false);
};






function setMobileControlsVisible(on){
  const joy  = document.getElementById('joystick');
  const fabs = document.querySelector('.fabs');
  if (joy)  joy.style.display  = on ? '' : 'none';
  if (fabs) fabs.style.display = on ? '' : 'none';
}


document.addEventListener('click', (ev)=>{
  const t = ev.target.closest('[data-close]');
  if(!t) return;
  const sel = t.getAttribute('data-close');
  const modal = document.querySelector(sel);

  if (modal) {
    // 1. Audio feedback on close
    if (sel === '#blacksmithModal' && typeof playNpcDialogue === 'function') playNpcDialogue(NPC_DIALOGUE_URLS.blacksmith.leave);
    if (sel === '#merchantModal' && typeof playNpcDialogue === 'function') playNpcDialogue(NPC_DIALOGUE_URLS.merchant.leave);
    if (sel === '#jesterModal' && typeof playNpcDialogue === 'function') playNpcDialogue(NPC_DIALOGUE_URLS.jester.leave);
    if (sel === '#cartographerModal' && typeof playNpcDialogue === 'function') playNpcDialogue(NPC_DIALOGUE_URLS.cartographer.leave);

    modal.style.display='none';

    // 2. Unlock controls for ALL interaction modals
    // This list now includes Jester and Cartographer so you don't get stuck.
    const lockingModals = [
      '#blacksmithModal', 
      '#merchantModal', 
      '#jesterModal', 
      '#cartographerModal', 
      '#spellUpModal'
    ];

    if (lockingModals.includes(sel)) {
      state._inputLocked = false;
    }

    // 3. Restore mobile controls (unless paused)
    if (!state._pauseOpen) {
      if (typeof setMobileControlsVisible === 'function') setMobileControlsVisible(true);
    }
    
    // 4. Tutorial specific logic (keeps your existing tutorial flow working)
    if (sel === '#invModal' && state.gameMode === 'tutorial') {
      if (state.tutorialStep === 0 && !state._tutMoveDone) {
        showBanner("Tutorial: Move first ‚Äî press W A S D (or ‚Üë ‚Üì ‚Üê ‚Üí) once each.", 2200);
      }
      if (state.tutorialStep === 1) {
        hideBanner();
        state.tutorialStep = 2;
        say("Nice. Now press P to open your Spell Book.");
      }
    }
    if (sel === '#spellModal' && state.gameMode === 'tutorial') {
      if (state.tutorialStep === 3) {
        hideBanner();
        state.tutorialStep = 4;
        showBanner("Next: pick up the arrows on the floor. Then face the training rat and press B to shoot.", 999999);
      }
    }
  }
});





const invModal=document.getElementById('invModal');
const spellModal=document.getElementById('spellModal');
document.querySelectorAll('[data-close]:not(#mBack)')
  .forEach(b => b.addEventListener('click', e => {
    const sel = e.target.dataset.close;
    if (sel) {
      const modal = document.querySelector(sel);
      if (modal) {
        modal.style.display = 'none';

        // Tutorial (new Step 3): if we just closed the inventory via its Close button
if (sel === '#invModal' && state.gameMode === 'tutorial') {

  // movement safeguard
  if (state.tutorialStep === 0 && !state._tutMoveDone) {
    showBanner("Tutorial: Move first ‚Äî press W A S D (or ‚Üë ‚Üì ‚Üê ‚Üí) once each.", 2200);
  }

  // Step 3 advancement: close Inventory -> prompt Spell Book
  if (state.tutorialStep === 1) {
    hideBanner();
    state.tutorialStep = 2;
    say("Nice. Now press P to open your Spell Book.");
  }
}

// Tutorial (new Step 4): if we just closed the spell book via its Close button
if (sel === '#spellModal' && state.gameMode === 'tutorial') {
  if (state.tutorialStep === 3) {
    hideBanner();
    state.tutorialStep = 4;
    showBanner("Next: pick up the arrows on the floor. Then face the training rat and press B to shoot.", 999999);
  }
}


        // If we just closed merchant or blacksmith, unlock controls
        if (sel === '#blacksmithModal' || sel === '#merchantModal') {
          state._inputLocked = false;
        }

        if (!state._pauseOpen) {
          setMobileControlsVisible(true);
        }
      }
    }
  }));



document.getElementById('btnInv').onclick=()=>{ updateInvBody(); invModal.style.display='flex'; setMobileControlsVisible(false); }
document.getElementById('btnSpells').onclick=()=>{ updateSpellBody(); spellModal.style.display='flex'; setMobileControlsVisible(false); }



function updateInvBody(){
  const b = document.getElementById('invBody');
  const tab = (state.ui && state.ui.invTab) || 'items';

  // Tabs header
  b.innerHTML = `
    <div class="row" style="gap:6px; margin-bottom:8px;">
      <button class="btn" id="tabItems"   ${tab==='items'   ? 'disabled':''}>Items</button>
      <button class="btn" id="tabShield"  ${tab==='shield'  ? 'disabled':''}>Shield</button>
      <button class="btn" id="tabWeapons" ${tab==='weapons' ? 'disabled':''}>Weapons</button>
    </div>
    <div id="invSection"></div>
  `;

  const sec = b.querySelector('#invSection');

  // ---- Items tab ----
  function renderItems(){
  sec.innerHTML = `
    <div class="row" style="justify-content:space-between"><div>Gold x${state.inventory.gold||0}</div></div>
    <div class="row" style="justify-content:space-between; border-bottom:1px solid var(--chipBorder); padding-bottom:8px; margin-bottom:8px;">
      <div>Lockpicks x${state.inventory.lockpicks}</div>
    </div>

    <div class="row" style="justify-content:space-between"><div>Potions x${state.inventory.potions}</div><button class="btn" id="btnUsePot" ${state.inventory.potions ? '' : 'disabled'}>Use</button></div>
    <div class="row" style="justify-content:space-between"><div>Tonics x${state.inventory.tonics}</div><button class="btn" id="btnUseTon" ${state.inventory.tonics ? '' : 'disabled'}>Use</button></div>
    <div class="row" style="justify-content:space-between"><div>Antidotes x${state.inventory.antidotes || 0}</div><button class="btn" id="btnUseAnt" ${state.inventory.antidotes ? '' : 'disabled'}>Use</button></div>
    
    <div style="margin-top:8px; padding-top:8px; border-top:1px solid var(--chipBorder); opacity:0.9; font-size:12px; font-weight:800;">COMBAT ITEMS</div>
    <div class="row" style="justify-content:space-between"><div>Bombs x${state.inventory.bombs || 0}</div><button class="btn" id="btnUseBomb" ${state.inventory.bombs ? '' : 'disabled'}>Throw</button></div>
    <div class="row" style="justify-content:space-between"><div>Warp Stones x${state.inventory.warpStones || 0}</div><button class="btn" id="btnUseWarp" ${state.inventory.warpStones ? '' : 'disabled'}>Warp</button></div>
  `;
  sec.querySelector('#btnUsePot')?.addEventListener('click', usePotion);
  sec.querySelector('#btnUseTon')?.addEventListener('click', useTonic);
  sec.querySelector('#btnUseAnt')?.addEventListener('click', useAntidote);
  
  // Wire new buttons
  sec.querySelector('#btnUseBomb')?.addEventListener('click', useBomb);
  sec.querySelector('#btnUseWarp')?.addEventListener('click', useWarpStone);
}


  // ---- Shield tab ----
function renderShield(){
    sec.innerHTML = '';
    
    // 1. Generic Shields (Legacy/Standard)
    const haveGeneric = state.inventory.shields|0;
    if (haveGeneric > 0 || (state.player.shield && state.player.shieldName === 'Standard')) {
       const row = document.createElement('div');
       row.className = 'row';
       row.style.justifyContent = 'space-between';
       row.style.marginBottom = '10px';
       
       const isEquipped = (state.player.shield && state.player.shieldName === 'Standard');
       const dur = isEquipped ? ` (Dur ${state.player.shield.dur})` : '';
       
       const left = document.createElement('div');
       left.textContent = `Standard Shield x${haveGeneric}${dur}`;
       
       const btn = document.createElement('button');
       btn.className = 'btn';
       btn.textContent = isEquipped ? 'Unequip' : 'Equip';
       btn.onclick = () => { isEquipped ? unequipShield() : equipShield('Standard'); };
       
       row.append(left, btn);
       sec.appendChild(row);
    }

    // 2. Named Shields (Buckler, Tower, etc.)
    for (const [name, count] of Object.entries(state.inventory.weapons || {})) {
        if (getWeaponType(name) !== 'shield') continue;
        
        const row = document.createElement('div');
        row.className = 'row';
        row.style.justifyContent = 'space-between';
        
        const isEquipped = (state.player.shield && state.player.shieldName === name);
        const dur = isEquipped ? ` (Dur ${state.player.shield.dur})` : '';
        
        // Calculate Block % for display
        let blockChance = '20%';
        if (name.includes('Buckler')) blockChance = '15%';
        else if (name.includes('Tower')) blockChance = '35%';
        else if (name.includes('Ancient')) blockChance = '25%';

        const left = document.createElement('div');
        left.innerHTML = `${name} x${count} <span style="opacity:0.7; font-size:12px;">(${blockChance} Block)${dur}</span>`;
        
        const btn = document.createElement('button');
        btn.className = 'btn';
        btn.textContent = isEquipped ? 'Unequip' : 'Equip';
        btn.onclick = () => { isEquipped ? unequipShield() : equipShield(name); };
        
        row.append(left, btn);
        sec.appendChild(row);
    }

    // Empty State
    if (sec.innerHTML === '') sec.innerHTML = '<div>(none)</div>';

    const tip = document.createElement('div');
    tip.style.opacity = 0.8;
    tip.style.marginTop = '15px';
    tip.style.borderTop = '1px solid rgba(255,255,255,0.1)';
    tip.style.paddingTop = '5px';
    tip.textContent = 'Shields block damage based on their Block Chance.';
    sec.appendChild(tip);
  }

  // ---- Weapons tab ----
  function renderWeapons(){
    sec.innerHTML = '<div id="weaponsList"></div>';
    const wDiv = sec.querySelector('#weaponsList');
    const entries = Object.entries(state.inventory.weapons);

    // Helper to get type safely (handles Key of Destiny + Affixes)
    const getType = (name) => {
      if (name === 'Key of Destiny') return 'one';
      return weaponStatsFor(name)?.type || 'hand';
    };

    // Sort by Skill Name so groups stay together
    entries.sort((a, b) => {
      const skillA = typeNice(getType(a[0]));
      const skillB = typeNice(getType(b[0]));
      return skillA.localeCompare(skillB);
    });

    if (!entries.length) {
      wDiv.innerHTML = '<div>(none)</div>';
      return;
    }
    
    wDiv.innerHTML = '';
    let lastSkill = null; // Tracks the current group header

    for (const [name,count] of entries) {
      // --- NEW: Header Logic ---
      const wType = getType(name); 
      
      // --- FIX: Hide Shields from Weapon Tab ---
      if (wType === 'shield') continue;
      // ---------------------------------------

      const skillLabel = typeNice(wType); // e.g. "One-Handed"

      if (skillLabel !== lastSkill) {
        const h = document.createElement('div');
        h.style.cssText = 'color:#f9d65c; font-weight:800; font-size:12px; text-transform:uppercase; margin:10px 0 4px 0; border-bottom:1px solid rgba(255,255,255,0.1); opacity:0.8;';
        h.textContent = skillLabel;
        wDiv.appendChild(h);
        lastSkill = skillLabel;
      }
      // ------------------------

      const row = document.createElement('div');
      row.className = 'row';
      row.style.justifyContent = 'space-between';

      const left = document.createElement('div');
      
      // Determine stats: Use ACTUAL equipped stats (including Omen buffs to base) if equipped
      const isEquipped = state.player.weapon && state.player.weapon.name === name;
      let ws;
      
      if (isEquipped && state.player.weapon.base) {
          // Use the live modified base stats from the player object
        ws = { ...state.player.weapon.base, type: state.player.weapon.type };
    } else {
// -------------------- START OF FIX BLOCK --------------------
        // Check for 'Key of Destiny' or default to standard stats lookup
        if (name === 'Key of Destiny') {
            // Hardcode base stats for Key of Destiny when unequipped
            ws = { min: 5, max: 7, type: 'one' }; 
        } else {
            // Use the template stats for unequipped items (will return null for 'Key of Destiny')
            ws = weaponStatsFor(name) || (name === 'Fists' 
                ? { min: 1, max: 2, type: 'hand' } 
                : { min: 1, max: 1, type: wType });
        }
// -------------------- END OF FIX BLOCK --------------------
    }

// --- FIX: Include Global Omen Bonus ---
const flat = state.globalWeaponFlatBonus || 0;
const bonus = skillDamageBonus(ws.type) + flat;
// --------------------------------------
const pMin  = ws.min + bonus;
const pMax  = ws.max + bonus;

// --- NEW: Apply Floor Modifiers to Display ---
let dMin = pMin, dMax = pMax;
let dStyle = ''; 

if (state.floorEffect === 'AntiMagic') {
    dMin = Math.ceil(dMin * 1.5);
    dMax = Math.ceil(dMax * 1.5);
    dStyle = 'color:#4ade80; font-weight:bold;'; // Green (Buff)
} else if (state.floorEffect === 'ArcaneFlux') {
    dMin = Math.max(1, Math.ceil(dMin * 0.25));
    dMax = Math.max(1, Math.ceil(dMax * 0.25));
    dStyle = 'color:#f87171; font-weight:bold;'; // Red (Nerf)
}
// ---------------------------------------------

const durTxt = (isEquipped && Number.isFinite(state.player.weapon.durMax))
  ? ` ‚Äî Dur ${state.player.weapon.dur}/${state.player.weapon.durMax}` : '';

// --- NEW: Comparison Logic (Updated to use modified values) ---
let diffHTML = '';
if (!isEquipped) {
  const cur = state.player.weapon; // Note: 'cur' stats in state are technically raw, but we want to compare apples to apples
  
  // Recalculate equipped effective dmg for fair comparison
  let curMin = cur.min, curMax = cur.max;
  if (state.floorEffect === 'AntiMagic') { curMin*=1.5; curMax*=1.5; }
  else if (state.floorEffect === 'ArcaneFlux') { curMin*=0.25; curMax*=0.25; }
  
  const curAvg = (curMin + curMax) / 2;
  const rowAvg = (dMin + dMax) / 2;
  
  const diff = rowAvg - curAvg;
  if (diff > 0) diffHTML = ` <span style="color:#4ade80; font-weight:bold;">(+${diff.toFixed(1)})</span>`;
  else if (diff < 0) diffHTML = ` <span style="color:#f87171; font-weight:bold;">(${diff.toFixed(1)})</span>`;
  else diffHTML = ` <span style="color:#9ca3af;">(=)</span>`;
}

left.innerHTML = `${name} x${count} ‚Äî <span style="${dStyle}">Dmg ${dMin}‚Äì${dMax}</span>${durTxt}${diffHTML}`;
// -----------------------------


      const btn = document.createElement('button');
      btn.className = 'btn';
      
      // --- NEW: Cursed Logic ---
      const curWep = state.player.weapon;
      if (curWep && curWep.cursed) {
        // If we are currently holding a cursed weapon...
        if (isEquipped) {
          btn.textContent = "BOUND";
          btn.disabled = true;
          btn.style.color = "#ef4444"; // Red text
          btn.title = "Visit a Cleric to remove this curse.";
        } else {
          // Cannot equip other things while cursed
          btn.textContent = "Equip";
          btn.disabled = true;
          btn.style.opacity = "0.5";
        }
      } else {
        // Normal behavior
        btn.textContent = isEquipped ? 'Unequip' : 'Equip';
      }
      // --------------------------

      // Hide button when you truly have zero copies (keeps row but disables action)
      const stashCount = (state.inventory.stashed?.[name]?.length) || 0;
      const hasCopies  = (name === 'Fists') || (count && count > 0) || (stashCount > 0);
      if (!hasCopies && !isEquipped) {
        left.style.opacity = 0.6;
        row.append(left);
        wDiv.appendChild(row);
        continue;
      }

      btn.addEventListener('click', ()=>{
        const currentlyEquipped = state.player.weapon && state.player.weapon.name === name;
        if (currentlyEquipped){
          if (!state.inventory.stashed) state.inventory.stashed = {};
          const cur = state.player.weapon;
          if (Number.isFinite(cur?.durMax) && cur.dur > 0){
            (state.inventory.stashed[cur.name] ||= []).push({ ...cur, base: { ...cur.base } });
          }
          state.player.weapon = {name:'Fists', min:1, max:2, type:'hand', base:{min:1,max:2}, dur:null, durMax:null};
          recomputeWeapon(); updateEquipUI(); log(`Unequipped ${name}.`); updateInvBody();
         } else {
          equipWeaponByName(name);

          // >>> Tutorial: after equipping the Shortsword, move to next step
          if (state.gameMode === 'tutorial' &&
              state.tutorialStep === 2 &&
              name === 'Shortsword') {
            state.tutorialStep = 3;
            say("Nice. Now attack a rat with SPACE.");
          }
          // <<<

          log(`Equipped ${name}.`);
          updateInvBody();
        }
      });

      row.append(left, btn);
      wDiv.appendChild(row);
    }
  }

  // Render selected tab
  if (tab==='items')      renderItems();
  else if (tab==='shield')renderShield();
  else                    renderWeapons();

  // Wire tabs
  b.querySelector('#tabItems')  ?.addEventListener('click', ()=>{ state.ui.invTab='items';   updateInvBody(); });
  b.querySelector('#tabShield') ?.addEventListener('click', ()=>{ state.ui.invTab='shield';  updateInvBody(); });
  b.querySelector('#tabWeapons')?.addEventListener('click', ()=>{ state.ui.invTab='weapons'; updateInvBody(); });
}


// --- NEW: Consumable Logic (Bomb & Warp Stone) ---
function useBomb(){
  if ((state.inventory.bombs|0) > 0) {
    state.inventory.bombs--;
    SFX.descend(); 
    
    // --- FIX: Throw 3 tiles in facing direction ---
    const range = 3;
    const dirs = {up:[0,-1], down:[0,1], left:[-1,0], right:[1,0]};
    // Default to down if facing is undefined
    const [dx, dy] = dirs[state.player.facing || 'down']; 
    
    const targetX = state.player.x + (dx * range);
    const targetY = state.player.y + (dy * range);
    // ----------------------------------------------

    // 3x3 Explosion centered on targetX, targetY
    const rad = 1; 
    let hitCount = 0;
    for(let y = -rad; y <= rad; y++){
      for(let x = -rad; x <= rad; x++){
        const tx = targetX + x;
        const ty = targetY + y;
        
        // Visuals
        spawnFloatText("üí•", tx, ty, '#ff0000');
        spawnParticles(tx, ty, '#f97316', 6); // Fire
        spawnParticles(tx, ty, '#4b5563', 4); // Smoke
        
        // Damage Enemy
        const e = enemyAt(tx, ty);
        if (e) {
           const dmg = 10 + Math.floor(state.floor * 1.5);
           e.hp -= dmg;
           spawnFloatText(dmg, e.x, e.y, '#ff0000');
           if (e.hp <= 0) {
             
             // --- FIX: Depth 50 Boss Cutscene Checks ---
             if (state.floor === 50 && e.boss) {
                // Phase 1 -> Phase 2
                if (e.type === 'Clone' && !state.flags.depth50Phase2) {
                   runDepth50Phase2(e); 
                   return; // Stop here, let the cutscene handle the rest
                }
                // Phase 2 -> Outro
                if (e.type === 'Mad King' && !state.flags.depth50Done) {
                   runDepth50Outro(e); 
                   return; // Stop here, let the cutscene handle the rest
                }
             }
             // ------------------------------------------

             state.enemies = state.enemies.filter(en => en !== e);
             state.run.kills++;
             
             // --- FIX: Trigger Stairs if Boss ---
             if (e.boss) {
                spawnBossStairs();
                log("The explosion clears the path!");
             }
             // ----------------------------------
             
             // --- FIX: Award Player XP Only (No Skill XP) ---
             state.player.xp += (e.xp || 1);
             
             // Check for Level Up
             while(state.player.xp >= state.player.next){
               state.player.xp -= state.player.next;
               state.player.level++;
               state.player.next = Math.floor(state.player.next * 1.30); 
               
               // Trigger Level Up UI
               state._inputLocked = true;
               if (typeof setMobileControlsVisible === 'function') setMobileControlsVisible(false);
               const m = document.getElementById('lvlupModal');
               if(m) m.style.display = 'flex';
               SFX.levelUp();
             }
             // -----------------------------------------------
           }
           hitCount++;
        }
      }
    }
log(`You throw a bomb! Hit ${hitCount} foes.`);
    
    // Force close inventory to show the explosion
    const m = document.getElementById('invModal');
    if (m && m.style.display !== 'none') {
      m.style.display = 'none';
      if (!state._pauseOpen) setMobileControlsVisible?.(true);
    }

    updateInvBody();
    
// --- TUTORIAL Step 11 (Bomb) ---
    if (state.gameMode === 'tutorial' && state.tutorialStep === 11) {
       state.tutorialStep = 12;
       // Spawn Lockpicks
       state.pickups['10,42'] = {kind:'lockpicks', payload:3};
       state.tiles[42][10]=5;
       
       hideBanner();
       showBanner("Step 12: Pickup Lockpicks. Unlock the Door below (E). Note: It may fail!", 999999);
    }
    // ----------------------------

    draw();
    enemyStep(); 
  }
}

function useWarpStone(){
  if ((state.inventory.warpStones|0) > 0) {
    state.inventory.warpStones--;
    SFX.spell();
    
    // Find random safe spot
    const spot = findFreeFloorTile(5); // Minimum 5 tiles away
    if (spot) {
      state.player.x = spot.x;
      state.player.y = spot.y;
      // Snap visuals instantly
      state.player.rx = spot.x; state.player.ry = spot.y; 
      
      log("You warp through the ether!");
      spawnFloatText("WARP", state.player.x, state.player.y, '#00ffff');
    } else {
      log(" The warp fizzles...");
    }
    
    updateInvBody();
    draw();
    enemyStep();
  }
}

// (Original Potion function remains, just ensuring we sit next to it)
function usePotion(){
  if (state.inventory.potions > 0) {
    state.inventory.potions--;
    const before = state.player.hp|0;
    let gain = Math.max(1, Math.round(state.player.hpMax * POTION_PCT));
    
    // --- NEW CODE: Check for Poison Debuff ---
    if (state.player.poisoned) {
      gain = Math.max(1, Math.floor(gain / 2)); // Halve the healing power
      log(`The poison saps the potion's power.`);
    }
    // --- END NEW CODE ---

    state.player.hp = clamp(before + gain, 0, state.player.hpMax);
   const healed = state.player.hp - before;
    spawnFloatText("+" + healed, state.player.x, state.player.y, '#0f0'); 
    SFX.drink();
    
    // --- NEW: Record heal for Shadow ---
    state.lastPlayerAction = { type: 'heal', amount: healed };
    updateBars();
    log(`Drank a potion (+${healed} HP).`);

    // --- TUTORIAL Step 7 (Potion Part) ---
    if (state.gameMode === 'tutorial' && state.tutorialStep === 7) {
       state._tutProgress['potion'] = true;
       checkStep7Completion();
    }
    // -------------------------------------

    updateInvBody();
    draw();
  }
}

// --- Helper for Step 7 ---
function checkStep7Completion() {
   if (state._tutProgress['antidote'] && state._tutProgress['potion']) {
      state.tutorialStep = 8;
      // Spawn Arrows ONLY at Y=26
      state.pickups['11,26'] = {kind:'arrows', payload:10};
      state.tiles[26][11]=5;
      
      hideBanner();
      showBanner("Step 8: Pickup Arrows. Face the Rat and press B to shoot.", 999999);
   }
}

function useTonic(){
  if (state.inventory.tonics > 0) {
    state.inventory.tonics--;
    const before = state.player.mp|0;
    const gain   = Math.max(1, Math.round(state.player.mpMax * TONIC_PCT));
    state.player.mp = clamp(before + gain, 0, state.player.mpMax);
    const restored = state.player.mp - before;

    SFX.drink();
    updateBars();
    log(`Used a tonic (+${restored} MP).`);
    
    // --- TUTORIAL Step 10 (Tonic) ---
    if (state.gameMode === 'tutorial' && state.tutorialStep === 10) {
       state.tutorialStep = 11;
       // Spawn Bomb
       state.pickups['10,40'] = {kind:'bomb', payload:1};
       state.tiles[40][10]=5;
       hideBanner();
       showBanner("Step 11: Pickup Bomb. Press 4 to throw it.", 999999);
    }

    updateInvBody();
    draw();
  }
}


function useAntidote(){
  if (state.inventory.antidotes > 0) {
    state.inventory.antidotes--;
    if (state.player.poisoned) { state.player.poisoned = false; state.player.poisonTicks = 0; }
    SFX.drink();;
    updateBars();
    log('You use an antidote. The poison is cured.');
    
    // --- TUTORIAL Step 7 (Antidote Part) ---
    if (state.gameMode === 'tutorial' && state.tutorialStep === 7) {
       state._tutProgress['antidote'] = true;
       checkStep7Completion();
    }
    // ---------------------------------------

    updateInvBody();
    draw();
  }
}


function updateSpellBody(){
  const b = document.getElementById('spellBody');
  if(!state.spells.length){ b.innerHTML = '<div>No spells learned.</div>'; return; }
  b.innerHTML = '';
  state.spells.forEach((s)=>{
    const row = document.createElement('div');
    row.className = 'row';
    row.style.justifyContent = 'space-between';

    const left = document.createElement('div');
    const up = (state.spellUpgrades && state.spellUpgrades[s.name]) || { dmg:0, range:0 };
    const st = getSpellStats(s.name); // use tiered stats for ALL spells (incl. Heal)
    
    // --- NEW: Spell Floor Modifiers ---
    let sMin = st.min, sMax = st.max;
    let sStyle = "";
    let sNote = "";

    if (state.floorEffect === 'ArcaneFlux') {
        sMin = Math.ceil(sMin * 1.5);
        sMax = Math.ceil(sMax * 1.5);
        sStyle = "color:#4ade80; font-weight:bold;"; // Green
    } else if (state.floorEffect === 'AntiMagic') {
        sNote = " (SILENCED)";
        sStyle = "color:#f87171; text-decoration:line-through;"; // Red + Strike
    }
    // ----------------------------------

    if (s.name === 'Heal'){
      const pct = Math.round((st.pct || 0) * 100);
      // Heal is usually unaffected by damage flux, but blocked by AntiMagic
      if (state.floorEffect === 'AntiMagic') {
         left.innerHTML = `${s.name} Lv${s.tier||1} ‚Äî <span style="${sStyle}">SILENCED</span>`;
      } else {
         left.textContent = `${s.name} Lv${s.tier||1} ‚Äî ${st.cost} MP ‚Äî heals ${pct}% of Max HP`;
      }
    } else {
      left.innerHTML = `${s.name} Lv${s.tier||1} ‚Äî ${st.cost} MP ‚Äî <span style="${sStyle}">${sMin}‚Äì${sMax} DMG${sNote}</span> ‚Äî Range ${st.range}`;
    }

    const btn = document.createElement('button');
    btn.className='btn';
    const isEquipped = state.equippedSpell && state.equippedSpell.name===s.name;
    btn.textContent = isEquipped ? 'Unequip' : 'Equip';
    btn.onclick = ()=>{
      const isEquipped = state.equippedSpell && state.equippedSpell.name === s.name;
      if (isEquipped){
        state.equippedSpell = null;
        log(`Unequipped ${s.name}.`);
      }else{
        state.equippedSpell = s;
        log(`Equipped ${s.name}.`);
      }
      updateEquipUI();
      updateSpellBody();
    };

    row.append(left, btn);
    b.appendChild(row);
  });
}



// ---- Level-up scaling helpers ----
function dangerFactor() {
  // Scales with floor; boss floors (every 10th) get a bump
  const base = 1 + (state.floor - 1) * 0.12;   // +12% per floor
  const bossBump = (state.floor % 10 === 0) ? 0.25 : 0; // +25% on boss floors
  return Math.max(1, base + bossBump);
}

function levelHpGain() {
  const L = state.player.level;   // current level (pre-gain)
  const F = state.floor;
  const raw = 4 + 0.6 * L + 0.5 * F;
  return Math.max(3, Math.round(raw * dangerFactor()));
}

function levelMpGain() {
  const L = state.player.level;
  const F = state.floor;
  const magicLvl = (state.skills?.magic?.lvl || 1);
  const casterBias = Math.min(2, Math.floor(magicLvl / 3)) * 0.5; // up to +1
  const raw = 2 + 0.35 * L + 0.3 * F + casterBias;
  return Math.max(2, Math.round(raw));
}

// --- NEW: Stamina Scaling ---
function levelStamGain() {
  const L = state.player.level;
  const F = state.floor;
  // Base 3 + (Level/5) + (Floor/10). Multiplied by dangerFactor (boss floors give more).
  const raw = 3 + 0.20 * L + 0.10 * F; 
  return Math.max(3, Math.round(raw * dangerFactor()));
}


// ====== Level Up choice modal (HP / MP / Stamina) ======
const lvlupModal = document.getElementById('lvlupModal');
const btnHP      = document.getElementById('btnHP');
const btnMP      = document.getElementById('btnMP');
const btnStam    = document.getElementById('btnStam'); // <--- NEW

function openLevelUpModal(){
  if (!lvlupModal) return;
  
  // --- FIX: Reset the title so it doesn't say "Golden Well" ---
  const t = lvlupModal.querySelector('.title');
  if(t) t.innerText = "Level Up!";
  // ------------------------------------------------------------

  lvlupModal.style.display = 'flex';
  state._inputLocked = true;

  // hide mobile controls while choosing
  setMobileControlsVisible?.(false);
}
window.openLevelUpModal = openLevelUpModal;

if (btnHP){
  btnHP.onclick = ()=>{
    const inc = (typeof levelHpGain === 'function') ? levelHpGain() : 5;
    state.player.hpMax += inc;

    const before = state.player.hp|0;
    const gain   = Math.max(1, Math.round(state.player.hpMax * POTION_PCT));
    state.player.hp = clamp(before + gain, 0, state.player.hpMax);

    updateBars();
    lvlupModal.style.display='none';
    state._inputLocked = false;

    // restore mobile controls (unless paused)
    if (!state._pauseOpen) setMobileControlsVisible?.(true);

    log('You feel more attuned to magic.');
  };
}

// --- NEW: Stamina Level Up Logic ---
if (btnStam){
  btnStam.onclick = ()=>{
    // Increase Max Stamina (Scaled)
    const inc = (typeof levelStamGain === 'function') ? levelStamGain() : 4;
    state.player.staminaMax = (state.player.staminaMax || 10) + inc;
    
    // Full Refill (Reward for picking it)
    state.player.stamina = state.player.staminaMax;

    updateBars();
    lvlupModal.style.display='none';
    state._inputLocked = false;

    if (!state._pauseOpen) setMobileControlsVisible?.(true);

    log('Your endurance grows. Max Stamina increased.');
  };
}
if (btnMP){
  btnMP.onclick = ()=>{
    const inc = (typeof levelMpGain === 'function') ? levelMpGain() : 5;
    state.player.mpMax += inc;

    const before = state.player.mp|0;
    const gain   = Math.max(1, Math.round(state.player.mpMax * TONIC_PCT));
    state.player.mp = clamp(before + gain, 0, state.player.mpMax);

    updateBars();
    lvlupModal.style.display='none';
    state._inputLocked = false;

    // restore mobile controls (unless paused)
    if (!state._pauseOpen) setMobileControlsVisible?.(true);

    log('You feel more attuned to magic.');
  };
}





// ====== Pick 1 of 2 (run modifiers) ======
const pick2Modal  = document.getElementById('pick2Modal');
const pick2Title  = document.getElementById('pick2Title');
const pick2Desc   = document.getElementById('pick2Desc');
const btnPick2A   = document.getElementById('btnPick2A');
const btnPick2B   = document.getElementById('btnPick2B');

// global flat bonus for all weapons; used in recomputeWeapon()
state.globalWeaponFlatBonus = state.globalWeaponFlatBonus || 0;

// pool of possible blessing/curse pairs
const PICK2_POOL = [
  // ===== Stamina Omens =====
  {
    id: 'second_wind',
    label: '+10 Max Stamina / -5 Max MP',
    apply(){
      const p = state.player;
      p.staminaMax += 10;
      p.stamina = p.staminaMax;
      p.mpMax = Math.max(0, p.mpMax - 5);
      if (p.mp > p.mpMax) p.mp = p.mpMax;
      updateBars?.();
      log('[Omen] Lungs of iron... mind of fog.');
    }
  },
  {
    id: 'heavy_heart',
    label: '+12 Max HP / -8 Max Stamina',
    apply(){
      const p = state.player;
      p.hpMax += 12;
      p.hp = p.hpMax;
      p.staminaMax = Math.max(5, p.staminaMax - 8);
      p.stamina = Math.min(p.stamina, p.staminaMax);
      updateBars?.();
      log('[Omen] A mountain of health... that cannot move.');
    }
  },
  {
    id: 'adrenaline_rush',
    label: '+Full Stamina Restore +2 Bombs / -15% Max HP',
    apply(){
      state.player.stamina = state.player.staminaMax;
      state.inventory.bombs = (state.inventory.bombs|0) + 2;
      state.player.hpMax = Math.max(1, Math.floor(state.player.hpMax * 0.85));
      if(state.player.hp > state.player.hpMax) state.player.hp = state.player.hpMax;
      updateBars?.(); updateInvBody?.();
      log('[Omen] Explosive energy... at a cost.');
    }
  },
  // --- NEW CREATIVE OMENS ---
  {
    id: 'titan_grip',
    label: '+15 ATK (all weapons) / -Max Stamina set to 5',
    apply(){
      state.globalWeaponFlatBonus = (state.globalWeaponFlatBonus || 0) + 15;
      if (typeof recomputeWeapon === 'function') recomputeWeapon();
      state.player.staminaMax = 5; 
      state.player.stamina = Math.min(state.player.stamina, 5);
      updateBars?.();
      log('[Omen] You are a juggernaut... slow and deadly.');
    }
  },
  {
    id: 'rogues_gambit',
    label: '+3 Warp Stones / -All Gold',
    apply(){
      state.inventory.warpStones = (state.inventory.warpStones|0) + 3;
      state.inventory.gold = 0;
      updateInvBody?.();
      log('[Omen] You escape fate... but leave your fortune behind.');
    }
  },
  {
    id: 'glass_sprinter',
    label: '+15 Max Stamina / -Max HP set to 10',
    apply(){
      state.player.staminaMax += 15;
      state.player.stamina = state.player.staminaMax;
      state.player.hpMax = 10;
      state.player.hp = Math.min(state.player.hp, 10);
      updateBars?.();
      log('[Omen] You can run forever... if you survive.');
    }
  },
  {
    id: 'explorers_burden',
    label: '+10 Lockpicks +10 Torches (Vision) / -5 Max Stamina',
    apply(){
      state.inventory.lockpicks += 10;
      state.fovRadius = Math.min(10, (state.fovRadius||5) + 2);
      state.player.staminaMax = Math.max(2, state.player.staminaMax - 5);
      state.player.stamina = Math.min(state.player.stamina, state.player.staminaMax);
      updateBars?.(); updateInvBody?.();
      log('[Omen] Prepared for everything... except the run.');
    }
  },
  // ===== originals =====
  {
    id: 'mp_up_hp_down',
    label: '+12 Max MP / -6 Max HP',
    apply(){
      const p = state.player;
      p.mpMax += 12;
      p.mp = Math.min(p.mp + 12, p.mpMax);
      p.hpMax = Math.max(5, p.hpMax - 6);
      if (p.hp > p.hpMax) p.hp = p.hpMax;
      if (typeof updateBars === 'function') updateBars();
      log('[Omen] +12 Max MP, -6 Max HP.');
    }
  },
  {
    id: 'atk_up_vision_down',
    label: '+3 ATK (all weapons) / -1 Vision Range',
    apply(){
      state.globalWeaponFlatBonus = (state.globalWeaponFlatBonus || 0) + 3;
      if (typeof recomputeWeapon === 'function') recomputeWeapon();
      state.fovRadius = Math.max(2, (state.fovRadius || 5) - 1);
      log('[Omen] +3 weapon damage, -1 vision range.');
    }
  },
  {
    id: 'hp_up_mp_down',
    label: '+10 Max HP / -10 Max MP',
    apply(){
      const p = state.player;
      p.hpMax += 10;
      p.hp = Math.min(p.hp + 10, p.hpMax);
      p.mpMax = Math.max(0, p.mpMax - 10);
      if (p.mp > p.mpMax) p.mp = p.mpMax;
      if (typeof updateBars === 'function') updateBars();
      log('[Omen] +10 Max HP, -10 Max MP.');
    }
  },
  {
    id: 'gold_up_hp_down',
    label: '+35 Gold / -6 Max HP',
    apply(){
      state.inventory.gold = (state.inventory.gold|0) + 35;
      const p = state.player;
      p.hpMax = Math.max(5, p.hpMax - 6);
      if (p.hp > p.hpMax) p.hp = p.hpMax;
      if (typeof updateBars === 'function') updateBars();
      if (typeof updateInvBody === 'function') updateInvBody();
      log('[Omen] +60 gold, -6 Max HP.');
    }
  },

  // ===== new spicy ones =====
  {
    id: 'night_eyes',
    label: '+2 Vision Range / -4 Max HP',
    apply(){
      state.fovRadius = Math.min(8, (state.fovRadius || 5) + 2);
      const p = state.player;
      p.hpMax = Math.max(5, p.hpMax - 4);
      if (p.hp > p.hpMax) p.hp = p.hpMax;
      if (typeof updateBars === 'function') updateBars();
      log('[Omen] Your eyes sharpen‚Ä¶ but your body thins.');
    }
  },
  {
    id: 'tunnel_curse',
    label: '+4 ATK (all weapons) / -2 Vision Range',
    apply(){
      state.globalWeaponFlatBonus = (state.globalWeaponFlatBonus || 0) + 4;
      if (typeof recomputeWeapon === 'function') recomputeWeapon();
      state.fovRadius = Math.max(2, (state.fovRadius || 5) - 2);
      log('[Omen] Brutal power, brutal blindness.');
    }
  },
  {
    id: 'hawkeye',
    label: '+2 Bow Range +10 Arrows / -6 Max MP',
    apply(){
      const b = state.player.bow || (state.player.bow = { range:5, loaded:0 });
      b.range = Math.min(10, (b.range|0) + 2);
      state.inventory.arrows = (state.inventory.arrows|0) + 10;

      const p = state.player;
      p.mpMax = Math.max(0, p.mpMax - 6);
      if (p.mp > p.mpMax) p.mp = p.mpMax;

      if (typeof updateBars === 'function') updateBars();
      if (typeof updateInvBody === 'function') updateInvBody();
      log('[Omen] Hawkeye‚Äôs gift‚Ä¶ with a mana tax.');
    }
  },
  {
    id: 'quickdraw',
    label: '+Loaded Shot +1 Bow Range / -6 Max HP',
    apply(){
      const b = state.player.bow || (state.player.bow = { range:5, loaded:0 });
      b.range = Math.min(10, (b.range|0) + 1);
      b.loaded = Math.max(1, b.loaded|0);

      const p = state.player;
      p.hpMax = Math.max(5, p.hpMax - 6);
      if (p.hp > p.hpMax) p.hp = p.hpMax;

      if (typeof updateBars === 'function') updateBars();
      log('[Omen] A shot chambered‚Ä¶ paid in blood.');
    }
  },
  {
    id: 'pack_rat',
    label: '+2 Potions +1 Tonic / -40 Gold',
    apply(){
      state.inventory.potions = (state.inventory.potions|0) + 2;
      state.inventory.tonics  = (state.inventory.tonics|0) + 1;
      state.inventory.gold    = Math.max(0, (state.inventory.gold|0) - 40);
      if (typeof updateInvBody === 'function') updateInvBody();
      log('[Omen] Supplies secured‚Ä¶ coin spent.');
    }
  },
  {
    id: 'locksmith',
    label: '+4 Lockpicks / -1 Vision Range',
    apply(){
      state.inventory.lockpicks = (state.inventory.lockpicks|0) + 4;
      state.fovRadius = Math.max(2, (state.fovRadius || 5) - 1);
      if (typeof updateInvBody === 'function') updateInvBody();
      log('[Omen] Doors fear you. Darkness doesn‚Äôt.');
    }
  },
  {
    id: 'alchemist',
    label: '+2 Antidotes +6 Max HP / -8 Max MP',
    apply(){
      state.inventory.antidotes = (state.inventory.antidotes|0) + 2;

      const p = state.player;
      p.hpMax += 6;
      p.hp = Math.min(p.hp + 6, p.hpMax);

      p.mpMax = Math.max(0, p.mpMax - 8);
      if (p.mp > p.mpMax) p.mp = p.mpMax;

      if (typeof updateBars === 'function') updateBars();
      if (typeof updateInvBody === 'function') updateInvBody();
      log('[Omen] Better living through chemistry‚Ä¶ worse magic.');
    }
  },
  {
    id: 'ironhide',
    label: '+1 Shield +2 ATK (all weapons) / -1 Vision Range',
    apply(){
      state.inventory.shields = (state.inventory.shields|0) + 1;
      state.globalWeaponFlatBonus = (state.globalWeaponFlatBonus || 0) + 2;
      if (typeof recomputeWeapon === 'function') recomputeWeapon();
      state.fovRadius = Math.max(2, (state.fovRadius || 5) - 1);

      if (typeof updateInvBody === 'function') updateInvBody();
      log('[Omen] Steel favors you. Sight does not.');
    }
  },
  {
    id: 'blood_tithe',
    label: '+120 Gold / Become Poisoned',
    apply(){
      state.inventory.gold = (state.inventory.gold|0) + 120;

      const p = state.player;
      p.poisoned = true;
      p.poisonTicks = Math.max(p.poisonTicks|0, 6);

      if (typeof updateInvBody === 'function') updateInvBody();
      log('[Omen] The coins are warm‚Ä¶ and wrong.');
    }
  },
  {
    id: 'overcharge',
    label: '+10 Max MP (Full MP) / -10 Max HP',
    apply(){
      const p = state.player;
      p.mpMax += 10;
      p.mp = p.mpMax;

      p.hpMax = Math.max(5, p.hpMax - 10);
      if (p.hp > p.hpMax) p.hp = p.hpMax;

      if (typeof updateBars === 'function') updateBars();
      log('[Omen] Mana floods in. Your frame buckles.');
    }
  },
  {
    id: 'battle_trance',
    label: '+Full Heal / -6 Max MP',
    apply(){
      const p = state.player;
      p.hp = p.hpMax;

      p.mpMax = Math.max(0, p.mpMax - 6);
      if (p.mp > p.mpMax) p.mp = p.mpMax;

      if (typeof updateBars === 'function') updateBars();
      log('[Omen] You breathe easy‚Ä¶ magic chokes.');
    }
  },
  {
    id: 'gambler',
    label: '+120 Gold / -2 Vision Range',
    apply(){
      state.inventory.gold = (state.inventory.gold|0) + 120;
      state.fovRadius = Math.max(2, (state.fovRadius || 5) - 2);
      if (typeof updateInvBody === 'function') updateInvBody();
      log('[Omen] Riches, at the edge of darkness.');
    }
  },
  {
    id: 'scavenger',
    label: '+80 Gold & +8 Arrows / -1 Potion',
    apply(){
      state.inventory.gold   = (state.inventory.gold|0) + 80;
      state.inventory.arrows = (state.inventory.arrows|0) + 8;
      state.inventory.potions = Math.max(0, (state.inventory.potions|0) - 1);
      if (typeof updateInvBody === 'function') updateInvBody();
      log('[Omen] Loot in hand‚Ä¶ medicine denied.');
    }
  },
  {
    id: 'clarity',
    label: '+6 Max MP +1 Vision Range / -6 Max HP',
    apply(){
      const p = state.player;
      p.mpMax += 6;
      p.mp = Math.min(p.mp + 6, p.mpMax);

      state.fovRadius = Math.min(8, (state.fovRadius || 5) + 1);

      p.hpMax = Math.max(5, p.hpMax - 6);
      if (p.hp > p.hpMax) p.hp = p.hpMax;

      if (typeof updateBars === 'function') updateBars();
      log('[Omen] Mind sharpened. Body thinned.');
    }
  },
  {
    id: 'starved_power',
    label: '+5 ATK (all weapons) / -2 Potions',
    apply(){
      state.globalWeaponFlatBonus = (state.globalWeaponFlatBonus || 0) + 5;
      if (typeof recomputeWeapon === 'function') recomputeWeapon();

      state.inventory.potions = Math.max(0, (state.inventory.potions|0) - 2);
      if (typeof updateInvBody === 'function') updateInvBody();

      log('[Omen] Damage rises. Safety evaporates.');
    }
  },
  {
    id: 'fogwalker',
    label: '+3 Vision Range / -12 Gold',
    apply(){
      state.fovRadius = Math.min(8, (state.fovRadius || 5) + 3);
      state.inventory.gold = Math.max(0, (state.inventory.gold|0) - 12);
      if (typeof updateInvBody === 'function') updateInvBody();
      log('[Omen] The fog parts. Your purse doesn‚Äôt.');
    }
  },

  // ======= EVEN MORE OMENS (go nuts) =======

  {
    id: 'blacksmith_boil',
    label: 'Repair Weapon (Full Durability) / -60 Gold',
    apply(){
      const w = state.player.weapon;
      if (Number.isFinite(w?.durMax)){
        w.dur = w.durMax;
        updateEquipUI?.();
      }
      state.inventory.gold = Math.max(0, (state.inventory.gold|0) - 60);
      updateInvBody?.();
      log('[Omen] The blade sings again‚Ä¶ your coin goes quiet.');
    }
  },
  {
    id: 'tempered_edge',
    label: '+1 Weapon Base Damage / -5 Weapon Max Durability',
    apply(){
      const w = state.player.weapon;
      if (w?.base){
        w.base.min += 1;
        w.base.max += 1;
        if (Number.isFinite(w.durMax)){
          w.durMax = Math.max(1, (w.durMax|0) - 5);
          w.dur = Math.min(w.dur|0, w.durMax);
        }
        if (typeof recomputeWeapon === 'function') recomputeWeapon();
        updateEquipUI?.();
      }
      log('[Omen] Sharper steel‚Ä¶ shorter life.');
    }
  },
  {
    id: 'rust_tax',
    label: '+180 Gold / -8 Weapon Max Durability',
    apply(){
      state.inventory.gold = (state.inventory.gold|0) + 180;
      const w = state.player.weapon;
      if (Number.isFinite(w?.durMax)){
        w.durMax = Math.max(1, (w.durMax|0) - 8);
        w.dur = Math.min(w.dur|0, w.durMax);
        updateEquipUI?.();
      }
      updateInvBody?.();
      log('[Omen] Heavy purse‚Ä¶ rusted edge.');
    }
  },
  {
    id: 'glass_cannon',
    label: '+7 ATK (all weapons) / -30% Max HP',
    apply(){
      state.globalWeaponFlatBonus = (state.globalWeaponFlatBonus || 0) + 7;
      if (typeof recomputeWeapon === 'function') recomputeWeapon();

      const p = state.player;
      p.hpMax = Math.max(5, Math.floor(p.hpMax * 0.70));
      if (p.hp > p.hpMax) p.hp = p.hpMax;
      updateBars?.();
      log('[Omen] You hit like a storm‚Ä¶ and break like glass.');
    }
  },
  {
    id: 'tunnel_vision_extreme',
    label: '+9 ATK (all weapons) / Set Vision to 2',
    apply(){
      state.globalWeaponFlatBonus = (state.globalWeaponFlatBonus || 0) + 9;
      if (typeof recomputeWeapon === 'function') recomputeWeapon();
      state.fovRadius = 2;
      log('[Omen] Power without sight.');
    }
  },
  {
    id: 'night_market',
    label: '+3 Potions +2 Tonics / -120 Gold',
    apply(){
      state.inventory.potions = (state.inventory.potions|0) + 3;
      state.inventory.tonics  = (state.inventory.tonics|0) + 2;
      state.inventory.gold    = Math.max(0, (state.inventory.gold|0) - 120);
      updateInvBody?.();
      log('[Omen] A bargain‚Ä¶ if you never look at the receipt.');
    }
  },
  {
    id: 'snake_oil',
    label: '+4 Tonics / Become Poisoned',
    apply(){
      state.inventory.tonics = (state.inventory.tonics|0) + 4;
      const p = state.player;
      p.poisoned = true;
      p.poisonTicks = Math.max(p.poisonTicks|0, 8);
      updateInvBody?.();
      log('[Omen] Sweet medicine‚Ä¶ bitter aftertaste.');
    }
  },
  {
    id: 'antivenom_cache_plus',
    label: '+4 Antidotes +1 Vision / -2 Potions',
    apply(){
      state.inventory.antidotes = (state.inventory.antidotes|0) + 4;
      state.fovRadius = Math.min(8, (state.fovRadius || 5) + 1);
      state.inventory.potions = Math.max(0, (state.inventory.potions|0) - 2);
      updateInvBody?.();
      log('[Omen] You‚Äôll survive toxins‚Ä¶ if you survive the next hit.');
    }
  },
  {
    id: 'quiver_king',
    label: '+25 Arrows +Loaded Shot / -1 Vision Range',
    apply(){
      state.inventory.arrows = (state.inventory.arrows|0) + 25;
      state.player.bow = state.player.bow || { range:5, loaded:0 };
      state.player.bow.loaded = Math.max(1, state.player.bow.loaded|0);
      state.fovRadius = Math.max(2, (state.fovRadius || 5) - 1);
      updateInvBody?.();
      updateEquipUI?.();
      log('[Omen] The quiver fattens‚Ä¶ the dark creeps closer.');
    }
  },
  {
    id: 'bowstring_hymn',
    label: '+3 Bow Range / -8 Max HP',
    apply(){
      const b = state.player.bow || (state.player.bow = { range:5, loaded:0 });
      b.range = Math.min(12, (b.range|0) + 3);
      const p = state.player;
      p.hpMax = Math.max(5, p.hpMax - 8);
      if (p.hp > p.hpMax) p.hp = p.hpMax;
      updateBars?.(); updateEquipUI?.();
      log('[Omen] Long shots‚Ä¶ short life.');
    }
  },
  {
    id: 'loaded_lie',
    label: '+Loaded Shot (Free) +10 Gold / -6 Max MP',
    apply(){
      state.player.bow = state.player.bow || { range:5, loaded:0 };
      state.player.bow.loaded = 1;
      state.inventory.gold = (state.inventory.gold|0) + 10;

      const p = state.player;
      p.mpMax = Math.max(0, p.mpMax - 6);
      if (p.mp > p.mpMax) p.mp = p.mpMax;

      updateBars?.(); updateEquipUI?.(); updateInvBody?.();
      log('[Omen] A free arrow‚Ä¶ paid in mana.');
    }
  },
  {
    id: 'skill_drill_weapon',
    label: '+2 Levels (Current Weapon Skill) / -1 Vision Range',
    apply(){
      const t = state.player?.weapon?.type;
      if (t){
        ensureSkill(t);
        state.skills[t].lvl = (state.skills[t].lvl|0) + 2;
        state.skills[t].shown = true;
        if (typeof recomputeWeapon === 'function') recomputeWeapon();
        renderSkills?.();
      }
      state.fovRadius = Math.max(2, (state.fovRadius || 5) - 1);
      log('[Omen] Training pays‚Ä¶ the dark collects interest.');
    }
  },
  {
    id: 'skill_drill_magic',
    label: '+2 Magic Levels (Full MP) / -1 Potion',
    apply(){
      ensureSkill('magic');
      state.skills.magic.lvl = (state.skills.magic.lvl|0) + 2;
      state.skills.magic.shown = true;

      const p = state.player;
      p.mp = p.mpMax;

      state.inventory.potions = Math.max(0, (state.inventory.potions|0) - 1);

      updateBars?.(); updateInvBody?.(); renderSkills?.();
      log('[Omen] Your mind expands‚Ä¶ your supplies shrink.');
    }
  },
  {
    id: 'survivor_ritual',
    label: '+3 Survivability Levels / -10 Max MP',
    apply(){
      ensureSkill('survivability');
      state.skills.survivability.lvl = (state.skills.survivability.lvl|0) + 3;
      state.skills.survivability.shown = true;

      const p = state.player;
      p.mpMax = Math.max(0, p.mpMax - 10);
      if (p.mp > p.mpMax) p.mp = p.mpMax;

      updateBars?.(); renderSkills?.();
      log('[Omen] Your body learns‚Ä¶ your mana forgets.');
    }
  },
  {
    id: 'cache_of_steel',
    label: '+2 Shields +2 Lockpicks / -2 Vision Range',
    apply(){
      state.inventory.shields  = (state.inventory.shields|0) + 2;
      state.inventory.lockpicks = (state.inventory.lockpicks|0) + 2;
      state.fovRadius = Math.max(2, (state.fovRadius || 5) - 2);
      updateInvBody?.();
      log('[Omen] Tools in hand‚Ä¶ darkness at your throat.');
    }
  },
  {
    id: 'miserly_lantern',
    label: '+3 Vision Range / -200 Gold',
    apply(){
      state.fovRadius = Math.min(8, (state.fovRadius || 5) + 3);
      state.inventory.gold = Math.max(0, (state.inventory.gold|0) - 200);
      updateInvBody?.();
      log('[Omen] Light for sale. No refunds.');
    }
  },
  {
    id: 'blood_lantern',
    label: '+4 Vision Range / -12 Max HP',
    apply(){
      state.fovRadius = Math.min(8, (state.fovRadius || 5) + 4);
      const p = state.player;
      p.hpMax = Math.max(5, p.hpMax - 12);
      if (p.hp > p.hpMax) p.hp = p.hpMax;
      updateBars?.();
      log('[Omen] The light is warm‚Ä¶ because it‚Äôs yours.');
    }
  },
  {
    id: 'spellbook_stolen',
    label: 'Learn Random Spell / -8 Max HP',
    apply(){
      const p = state.player;
      p.hpMax = Math.max(5, p.hpMax - 8);
      if (p.hp > p.hpMax) p.hp = p.hpMax;

      if (typeof randomSpell === 'function'){
        const sp = randomSpell();
        if (sp){
          const have = state.spells.find(s => s.name === sp.name);
          if (!have){
            state.spells.push(sp);
            if (typeof ensureSpellUpgradeSlot === 'function') ensureSpellUpgradeSlot(sp.name);
            if (!state.equippedSpell) state.equippedSpell = sp;
            log(`[Omen] You stole a spell: ${sp.name} Lv${sp.tier}.`);
          } else {
            ensureSkill('magic');
            state.skills.magic.xp += 4; // MAGIC_SCROLL_XP default in your file
            renderSkills?.();
            log('[Omen] The pages were duplicates‚Ä¶ but you learned something.');
          }
        }
      }

      updateBars?.();
      log('[Omen] Knowledge costs flesh.');
    }
  },
  {
    id: 'armory_raffle',
    label: '+Random Weapon +50 Gold / -1 Vision Range',
    apply(){
      const names = ['Shortsword','Claymore','Spear','Axe','Knuckle Duster'];
      const name  = names[(Math.random()*names.length)|0];
      state.inventory.weapons[name] = (state.inventory.weapons[name] || 0) + 1;
      state.inventory.gold = (state.inventory.gold|0) + 50;
      state.fovRadius = Math.max(2, (state.fovRadius || 5) - 1);
      updateInvBody?.();
      log(`[Omen] The armory smiles: +1 ${name}.`);
    }
  },
  {
    id: 'poverty_pack',
    label: '+6 Lockpicks +2 Potions / -150 Gold',
    apply(){
      state.inventory.lockpicks = (state.inventory.lockpicks|0) + 6;
      state.inventory.potions   = (state.inventory.potions|0) + 2;
      state.inventory.gold      = Math.max(0, (state.inventory.gold|0) - 150);
      updateInvBody?.();
      log('[Omen] You can open anything‚Ä¶ except your wallet.');
    }
  },
  {
    id: 'mana_for_gold',
    label: '+240 Gold / -12 Max MP',
    apply(){
      state.inventory.gold = (state.inventory.gold|0) + 240;
      const p = state.player;
      p.mpMax = Math.max(0, p.mpMax - 12);
      if (p.mp > p.mpMax) p.mp = p.mpMax;
      updateBars?.(); updateInvBody?.();
      log('[Omen] Riches now‚Ä¶ spells later.');
    }
  },
  {
    id: 'blood_for_gold',
    label: '+180 Gold / -15% Max HP',
    apply(){
      state.inventory.gold = (state.inventory.gold|0) + 180;
      const p = state.player;
      p.hpMax = Math.max(5, Math.floor(p.hpMax * 0.85));
      if (p.hp > p.hpMax) p.hp = p.hpMax;
      updateBars?.(); updateInvBody?.();
      log('[Omen] The price is measured in heartbeats.');
    }
  },
  {
    id: 'merciless_focus',
    label: '+5 ATK (all weapons) +1 Vision / -3 Potions',
    apply(){
      state.globalWeaponFlatBonus = (state.globalWeaponFlatBonus || 0) + 5;
      if (typeof recomputeWeapon === 'function') recomputeWeapon();

      state.fovRadius = Math.min(8, (state.fovRadius || 5) + 1);
      state.inventory.potions = Math.max(0, (state.inventory.potions|0) - 3);

      updateInvBody?.();
      log('[Omen] Sharper senses‚Ä¶ fewer second chances.');
    }
  },
  {
    id: 'panic_heal',
    label: '+Full Heal +2 Potions / -2 Vision Range',
    apply(){
      const p = state.player;
      p.hp = p.hpMax;
      state.inventory.potions = (state.inventory.potions|0) + 2;
      state.fovRadius = Math.max(2, (state.fovRadius || 5) - 2);
      updateBars?.(); updateInvBody?.();
      log('[Omen] You live‚Ä¶ but the dark presses close.');
    }
  },
  {
    id: 'altar_of_thorns',
    label: '+15 Max HP / Become Poisoned (10 ticks)',
    apply(){
      const p = state.player;
      p.hpMax += 15;
      p.hp = Math.min(p.hp + 15, p.hpMax);

      p.poisoned = true;
      p.poisonTicks = Math.max(p.poisonTicks|0, 10);

      updateBars?.();
      log('[Omen] A stronger body‚Ä¶ a thorned soul.');
    }
  }
];


let _pick2Current = null;

function hidePick2Modal(){
  if (pick2Modal) pick2Modal.style.display = 'none';
  state._inputLocked = false;
  if (!state._pauseOpen && typeof setMobileControlsVisible === 'function'){
    setMobileControlsVisible(true);
  }
  if (typeof draw === 'function') draw();
}

// === UPDATE INSIDE choosePick2 ===
function choosePick2(idx){
  if (!_pick2Current || !_pick2Current[idx]) return;
  const cfg = _pick2Current[idx];
  try { cfg.apply(); } catch (err) { console.error(err); }
  
  // Pass 'true' to increment the "Picked" count
  unlockCodex(cfg.id, true); 

  hidePick2Modal();
}

if (btnPick2A){
  btnPick2A.onclick = ()=>choosePick2(0);
}
if (btnPick2B){
  btnPick2B.onclick = ()=>choosePick2(1);
}

// expose a helper so game logic can trigger the choice
window.offerPick2Choice = function offerPick2Choice(context){
  // safety: if the modal or buttons aren't there, do nothing
  if (!pick2Modal || !btnPick2A || !btnPick2B) return;
  
  // Omen/Pick 1 of 2 is exclusive to Endless Mode.
  if (state.gameMode !== 'endless') return;

  // Boss Reward pick should only fire if we are actually in Endless mode
  if (context === 'boss' && state.gameMode !== 'endless') return; // Redundant, but harmless safety.

  if (!Array.isArray(PICK2_POOL) || PICK2_POOL.length < 2) return;

  // pick two distinct options
  let i = Math.floor(Math.random() * PICK2_POOL.length);
  let j = Math.floor(Math.random() * PICK2_POOL.length);
  if (j === i) j = (j + 1) % PICK2_POOL.length;

  _pick2Current = [PICK2_POOL[i], PICK2_POOL[j]];

  if (pick2Title){
    pick2Title.textContent =
      (context === 'start')
        ? 'Pick 1 of 2 ‚Äî Opening Omen'
        : 'Pick 1 of 2 ‚Äî Boss Reward';
  }
  if (pick2Desc){
    pick2Desc.textContent = 'Each choice has a blessing and a curse.';
  }

  btnPick2A.textContent = _pick2Current[0].label;
  btnPick2B.textContent = _pick2Current[1].label;

  state._inputLocked = true;
  if (typeof setMobileControlsVisible === 'function'){
    setMobileControlsVisible(false);
  }

  pick2Modal.style.display = 'flex';
};


// ====== Pause Menu helpers ======
const pauseOverlay = document.getElementById('pauseOverlay');
const btnResume    = document.getElementById('btnResume');
const btnHelp      = document.getElementById('btnHelp');
const btnQuit      = document.getElementById('btnQuit');


// ====== Pause Menu helpers ======
function openPauseMenu(){
  const modal = document.getElementById('pauseModal');
  if (!modal) return;

  // mark game as paused
  state._pauseOpen = true;
  state._inputLocked = true;

  if (typeof setMobileControlsVisible === 'function') {
    setMobileControlsVisible(false);
  }

  modal.style.display = 'flex';
}

function closePauseMenu(){
  const modal = document.getElementById('pauseModal');
  if (!modal) return;

  modal.style.display = 'none';

  state._pauseOpen = false;
  state._inputLocked = false;

  if (typeof setMobileControlsVisible === 'function') {
    setMobileControlsVisible(true);
  }
}

// Wire Pause menu buttons
(function(){
  const modal       = document.getElementById('pauseModal');
  if (!modal) return;

  const btnResume   = document.getElementById('btnPauseResume');
  const btnHelp     = document.getElementById('btnPauseHelp');
  const btnSettings = document.getElementById('btnPauseSettings');
  const btnQuit     = document.getElementById('btnPauseQuit');

  if (btnResume){
    btnResume.addEventListener('click', () => {
      closePauseMenu();
    });
  }

  if (btnHelp){
    btnHelp.addEventListener('click', () => {
      // keep paused; just show Help on top
      const h = document.getElementById('helpModal');
      if (h) h.style.display = 'flex';
    });
  }

  if (btnSettings){
    btnSettings.addEventListener('click', () => {
      // keep paused; open Settings full-screen overlay
      const s = document.getElementById('settingsOverlay');
      if (s) s.style.display = 'flex';
    });
  }

  if (btnQuit){
    btnQuit.addEventListener('click', () => {
      // Close pause & go back to main menu
      closePauseMenu();
      if (typeof goMenu === 'function') {
        goMenu();
      }
    });
  }

  // Optional: clicking the dark backdrop also resumes
  modal.addEventListener('click', (e) => {
    if (e.target === modal){
      closePauseMenu();
    }
  });
})();


// ====== Input Buttons ======
document.getElementById('btnE').onclick=interact;
document.getElementById('btnAtk').onclick=attack;
document.getElementById('btnCast').onclick=cast;
document.getElementById('btnBow').onclick = shootBow; 

// swipe controls (no page scroll)
const wrap=document.getElementById('cw');
let touchStart=null;
wrap.addEventListener('touchstart',e=>{ document.body.classList.add('noscroll'); touchStart = {x:e.touches[0].clientX,y:e.touches[0].clientY}; },{passive:false});
wrap.addEventListener('touchmove',e=>{ e.preventDefault(); },{passive:false});
wrap.addEventListener('touchend',e=>{
  document.body.classList.remove('noscroll');
  if(!touchStart) return;
  const dx=(e.changedTouches[0].clientX-touchStart.x), dy=(e.changedTouches[0].clientY-touchStart.y);
  const ax=Math.abs(dx), ay=Math.abs(dy);
  if(Math.max(ax,ay)<24) return;
  if(ax>ay){ tryMove(dx>0?1:-1,0); } else { tryMove(0,dy>0?1:-1); }
  touchStart=null; updateBars();
});

// keyboard controls (desktop)
window.addEventListener('keydown', (e) => {
  // Don‚Äôt hijack keys while typing in inputs/textareas
  if (document.activeElement && /INPUT|TEXTAREA/.test(document.activeElement.tagName)) return;

  const k = (e.key || '').toLowerCase();
  const isPaused = !!state._pauseOpen;

  // Prevent page scrolling / default behavior for our game keys
  if (['arrowup','arrowdown','arrowleft','arrowright',' ','e','q','w','a','s','d','h','i','p','b','1','2','3','escape'].includes(k)) {
    e.preventDefault();
  }

  // --- Escape: toggle Pause menu while in a run ---
  if (k === 'escape') {
    const title    = document.getElementById('titleScreen');
    const menu     = document.getElementById('mainMenu');
    const demoEnd  = document.getElementById('demoEndOverlay');
    const settings = document.getElementById('settingsOverlay');
    const credits  = document.getElementById('creditsOverlay');

    const onTitle   = title    && title.style.display !== 'none';
    const onMenu    = menu     && menu.style.display !== 'none';
    const inOverlay = (demoEnd  && demoEnd.style.display  !== 'none') ||
                      (settings && settings.style.display !== 'none') ||
                      (credits  && credits.style.display  !== 'none');

    const inRun = !onTitle && !onMenu && !inOverlay && !state.gameOver;

    if (isPaused) {
      // Already paused ‚Üí Resume
      closePauseMenu();
    } else if (inRun && !state._inputLocked && !state._descending) {
    // Start pause only during active runs, not during level-up/cutscenes
    openPauseMenu();
  }

    return; // don‚Äôt let Escape fall through
  }

  // If paused, ignore all other keys (mouse-only while menu is open)
  if (isPaused) {
    return;
  }

  // If input is hard-locked (level-up, merchant, blacksmith, cutscenes, STAIRS), ignore keys
  if (state._inputLocked || state._descending) {
    return;
  }

 // Tutorial Step 1: Movement
if (state.gameMode === 'tutorial' && state.tutorialStep === 1){
  if (k === 'w' || k === 'arrowup') state._tutMoveWASD.w = true;
  if (k === 'a' || k === 'arrowleft') state._tutMoveWASD.a = true;
  if (k === 's' || k === 'arrowdown') state._tutMoveWASD.s = true;
  if (k === 'd' || k === 'arrowright') state._tutMoveWASD.d = true;

  if (state._tutMoveWASD.w && state._tutMoveWASD.a && state._tutMoveWASD.s && state._tutMoveWASD.d){
    state.tutorialStep = 2;
    hideBanner();
    showBanner("Step 2: Sprinting. Hold SHIFT while moving to Sprint. Be careful this consumes stamina.", 999999);
  }
}

// --- normal controls (Updated for Sprint) ---
if (k === 'arrowup' || k === 'w' || k === 'arrowdown' || k === 's' || k === 'arrowleft' || k === 'a' || k === 'arrowright'|| k === 'd') {
  
  let dx = 0, dy = 0;
  if (k === 'arrowup'   || k === 'w') dy = -1;
  if (k === 'arrowdown' || k === 's') dy = 1;
  if (k === 'arrowleft' || k === 'a') dx = -1;
  if (k === 'arrowright'|| k === 'd') dx = 1;

// SPRINT CHECK: Holding Shift?
    if (e.shiftKey) {
      if (state.player.stamina >= 3) {
         // Attempt to move 2 tiles
         const x1 = state.player.x + dx;
         // ... (rest of existing sprint logic inside this block) ...
         const y1 = state.player.y + dy;
         const x2 = x1 + dx;
         const y2 = y1 + dy;
         
         if (isPassableForPlayer(x1,y1) && isPassableForPlayer(x2,y2)) {
            state.player.stamina -= 3;
            
            // --- NEW: Glacial Slide (Extra Step) ---
            if (state.floorEffect === 'GlacialFreeze') {
               const x3 = x2 + dx, y3 = y2 + dy;
               if (isPassableForPlayer(x3, y3)) {
                  // Extend movement to 3rd tile without extra stamina cost
                  x2 = x3; y2 = y3; // Update target
                  spawnFloatText("Slide!", state.player.x, state.player.y, '#6ec5ff');
               }
            }
            // ---------------------------------------

            // --- TUTORIAL: Step 2 -> 3 (Sprint) ---
            if (state.gameMode === 'tutorial' && state.tutorialStep === 2) {
               state.tutorialStep = 3;
               hideBanner();
               showBanner("Step 3: Break the Crate! Walk up to it and press SPACE. Be careful this consumes stamina", 999999);
            }

            updateBars(); // Update UI immediately
            
            // Prevent stamina regen this turn
            state._skipStaminaRegen = true; 

            spawnFloatText("Sprint", state.player.x, state.player.y, '#4ade80');
            // ... (facing/move logic) ...
            if (dx>0) state.player.facing='right'; else if (dx<0) state.player.facing='left';
            else if (dy>0) state.player.facing='down'; else if (dy<0) state.player.facing='up';
            
            state.player.x = x2; state.player.y = y2;
            SFX.step(); 
            collectIfPickup();
            enemyStep(); 
            draw();
            return; 
         }
      } else {
         // --- NEW: Not enough Stamina feedback ---
         spawnFloatText("No Stamina", state.player.x, state.player.y, '#9ca3af');
         // We let the code fall through to tryMove() below so you still walk
      }
    }
  
  // Normal Move (1 tile)
  tryMove(dx, dy);
}

  else if (k === 'e') interact();
  else if (k === ' ') attack();        // melee
  else if (k === 'b') {                // bow
  const hadArrowLoaded = (state.player?.bow?.loaded|0) > 0;

  shootBow();

  // Tutorial (new): confirm they actually fired a shot (not "No arrow loaded.")
// IMPORTANT: do NOT advance the tutorial here ‚Äî advancement happens when the stationary rat dies.
if (state.gameMode === 'tutorial' && (state._tutGotArrows || state._tutArrowsPicked) && hadArrowLoaded && !state._tutFiredBowOnce){
  state._tutFiredBowOnce = true;
}


  return;                            // consume the key so enemies don‚Äôt also move
}

  else if (k === 'q') cast();
  else if (k === 'r') useWeaponArt(); // --- NEW: Bind R for Ability ---

  // --- NEW: Cycle Spells (F) ---
  else if (k === 'f') {
    if (state.spells && state.spells.length > 0) {
       let idx = -1;
       if (state.equippedSpell) {
         idx = state.spells.findIndex(s => s.name === state.equippedSpell.name);
       }
       // Cycle forward, loop to start
       const next = state.spells[(idx + 1) % state.spells.length];
       state.equippedSpell = next;
       
       updateEquipUI();
       spawnFloatText(next.name, state.player.x, state.player.y, '#60a5fa'); // Blue text
       SFX.pickup(); // Click sound
    } else {
       log("No spells memorized.");
    }
  }
  // -----------------------------

    // --- Hotkeys / modals / tutorial steps ---
    else if (k === '1') {

      // === Tutorial Step 6: must use antidote (3) before potion (1) ===
      if (state.gameMode === 'tutorial' && state.tutorialStep === 6) {

        // Don‚Äôt let them waste the only potion before curing poison
        if (!state._tutStep6UsedAntidote) {
          hideBanner();
          showBanner("Use 3 first (antidote). Then use 1 (potion).", 2200);
        } else {
          // drink potion
          usePotion();

          if (!state._tutStep6UsedPotion) {
            state._tutStep6UsedPotion = true;
            // INSERT NEW STEP: Weapon Arts
            state.tutorialStep = 6.5; 
            
            // Reset cooldown so they can use it immediately
            state.player.artCooldown = 0;
            updateEquipUI();

            // --- FIX: Check flag so we don't spawn 4 rats if attack() already spawned 2 ---
            if (!state._tutArtTargetSpawned) {
              state._tutArtTargetSpawned = true;
              
              // Spawn 2 rats horizontally adjacent (18,15 and 19,15)
              // ADDED: stunTicks:9999 so they don't move/attack
              state.enemies.push({
                x:18, y:15, type:'Rat', hp:1, atk:[1,2], xp:3, 
                stunTicks:9999, tutorialDummy:true
              });
              state.enemies.push({
                x:19, y:15, type:'Rat', hp:1, atk:[1,2], xp:3, 
                stunTicks:9999, tutorialDummy:true
              });
            }
            // -----------------------------------------------------------------------------

            hideBanner();
            showBanner("Health restored. New targets ahead! Walk up to them and press R to use your Axe's CLEAVE ability.", 999999);
          }
        }

      } else {
        // normal behavior
        usePotion();

        // Tutorial: (legacy) advancement disabled ‚Äî new tutorial uses different steps now
        if (state.gameMode === 'tutorial' && state.tutorialStep === 999) {
          state.tutorialStep = 2;
          say("Great! Now use the WASD/Arrow Keys to pick up and equip the weapon off the floor.");
        }
      }
    }
  else if (k === '2') {
    useTonic();

    // Tutorial Step 8 -> 9 (Tonic used)
    if (state.gameMode === 'tutorial' && state.tutorialStep === 8) {
      state.tutorialStep = 9;
      hideBanner();
      showBanner("Mana restored. Walk to the locked door below and press E to use a lockpick.", 999999);
    }
  }
  else if (k === '3') {
    useAntidote();
  }
  // --- NEW: Keybinds for Consumables ---
  else if (k === '4') { useBomb(); }
  else if (k === '5') { useWarpStone(); }
  // -------------------------------------

  else if (k === 'h') {
    const m = document.getElementById('helpModal');
    if (m) m.style.display = (m.style.display === 'flex' ? 'none' : 'flex');
  }
    else if (k === 'i') {
  const m = document.getElementById('invModal');

  if (m && m.style.display === 'flex') {
    // closing inventory
    m.style.display = 'none';

    // clear tab highlight (in case we added it)
    try{
      ['tabItems','tabShield','tabWeapons'].forEach(id=>{
        const btn = document.getElementById(id);
        if (btn){ btn.style.outline=''; btn.style.outlineOffset=''; }
      });
    }catch{}

    // Tutorial Step 2 safeguard (movement first)
    if (state.gameMode === 'tutorial' && state.tutorialStep === 0 && !state._tutMoveDone) {
      showBanner("Tutorial: Move first ‚Äî press W A S D (or ‚Üë ‚Üì ‚Üê ‚Üí) once each.", 2200);
    }

    // Tutorial Step 3: after they close Inventory, prompt Spell Book (P)
    if (state.gameMode === 'tutorial' && state.tutorialStep === 1) {
      hideBanner();
      state.tutorialStep = 2;
      say("Nice. Now press P to open your Spell Book.");
    }

} else {
  // opening inventory

  // Tutorial: when they press I the first time after movement, clear the "press I" prompt immediately
  if (state.gameMode === 'tutorial' && state.tutorialStep === 1 && state._tutMoveDone && !state._tutInvPromptCleared){
    state._tutInvPromptCleared = true;
    hideBanner();
  }

  updateInvBody();
  if (m) {
    m.style.display = 'flex';
  }

  // Tutorial Step 3: show tabs + highlight them once
  if (state.gameMode === 'tutorial' && state.tutorialStep === 1 && !state._tutInvTabsShown) {
    state._tutInvTabsShown = true;
    showBanner("Inventory tabs: Items / Shield / Weapons. Click a tab, then press I to close.", 999999);

    try{
      ['tabItems','tabShield','tabWeapons'].forEach(id=>{
        const btn = document.getElementById(id);
        if (btn){ btn.style.outline='2px solid #f9d65c'; btn.style.outlineOffset='2px'; }
      });
    }catch{}
  }
}

}

else if (k === 'p') {
  const m = document.getElementById('spellModal');

  if (m && m.style.display === 'flex') {
    // closing spell menu
    m.style.display = 'none';

    // Tutorial Step 4: ONLY after closing Spell Book, prompt arrows pickup
    if (state.gameMode === 'tutorial' && state.tutorialStep === 3) {
      hideBanner();
      state.tutorialStep = 4;
      showBanner("Next: pick up the arrows on the floor. Then face the training rat and press B to shoot.", 999999);
    }

  } else {
    updateSpellBody();
    if (m) {
      m.style.display = 'flex';

      // Tutorial Step 3: open Spell Book, but DON'T mention arrows yet
      if (state.gameMode === 'tutorial' && state.tutorialStep === 2) {
        hideBanner();
        state.tutorialStep = 3;
        showBanner("Spell Book opened. This is where you manage spells. Press P again to close.", 999999);
      }

      // keep your existing (legacy) tutorial logic untouched for now
      if (state.gameMode === 'tutorial' && state.tutorialStep === 4) {
        state.tutorialStep = 5;
        say("Spell menu opened. Press Q to use your equipped spell. Close the spell menu, then stand next to the locked door and press E to pick the lock.");
      }
    }
  }
}




  updateBars();
});


// ====== Boot ======
function boot(){
  gen();
  enemyStep();            // ‚Üê ADD: wake AI on room load
  // NEW: make sure the starting tile is revealed immediately
  state.seen.add(key(state.player.x, state.player.y));

  state.spells = [];
  updateBars(); updateEquipUI(); renderSkills();
  log('You awaken with nothing. Explore, loot, survive.');
  log('A chest is nearby.');
  renderLog();
  draw();
}



// === High score / run stats bootstrap ===
const HS_KEY = 'dc_hi10';
const META_KEY = 'dc_meta_v1';

// --- NEW: Classes & Meta Progress ---
const CLASSES = {
  Adventurer: { name:'Adventurer', desc:'Just a basic adventurer.', unlock:true },
  Rogue:      { name:'Rogue',      desc:'Starts with a Shortsword. + 5 Lockpicks. +5 MP / -3 HP.', req:'locks', val:5, msg:'Unlock: Pick 5 locks.' },
  Barbarian:  { name:'Barbarian',  desc:'Starts with a Axe. +10 HP / -5 MP.', req:'kills_axe', val:10, msg:'Unlock: 10 Axe kills.' },
  Wizard:    { name:'Wizard',    desc:'Starts with Fire Staff & Spark. +10 MP / -5 HP.', req:'kills_magic', val:10, msg:'Unlock: 10 Magic kills.' },
  
  // --- Endless Only Classes ---
  Mercenary: { name:'Mercenary', desc:'Starts with a Claymore. +8 HP / -8 MP.', req:'kills_two', val:10, msg:'Unlock: 10 Two-Handed kills.', endless:true },
  Monk:      { name:'Monk',      desc:'Starts with Knuckle Dusters. +10 MP / -5 HP.', req:'kills_hand', val:10, msg:'Unlock: 10 Hand to Hand kills.', endless:true },
  Ranger:    { name:'Ranger',    desc:'Starts with a Shortsword & 20 Arrows. +5 MP / -2 HP.', req:'kills_bow', val:10, msg:'Unlock: 10 Bow kills.', endless:true },
  
  // Endless Classes
  Lancer:    { name:'Lancer',    desc:'Polearm Specialist. Starts with Halberd. +10 Stamina / -5 MP.', req:'kills_spear', val:10, msg:'Unlock: 10 Polearm kills.', endless:true },
  Soldier:   { name:'Soldier',   desc:'Standard Infantry. Starts with Shortsword & Kite Shield. Balanced stats.', req:'depth', val:5, msg:'Unlock: Reach Depth 5.', endless:true },
  Spellblade:{ name:'Spellblade',desc:'Magic Knight. Starts with Shortsword & Ice Staff. Balanced stats.', req:'kills_magic', val:20, msg:'Unlock: 20 Magic kills.', endless:true },
  Legionary: { name:'Legionary', desc:'Iron Wall. Starts with Shortsword & Tower Shield. +15 HP / -10 Stamina.', req:'kills_one', val:30, msg:'Unlock: 30 One-Handed kills.', endless:true },
  Paladin:   { name:'Paladin',   desc:'Holy Crusader. Starts with Warhammer. +25 HP / +10 Stamina / -10 MP.', req:'depth', val:25, msg:'Unlock: Reach Depth 25.', endless:true },
};

// --- NEW: Soul Shop Definitions ---
const SOUL_UPGRADES = {
  vitality: { name:'Vitality', desc:'Start with +5 Max HP.', cost:100, max:5 },
  greed:    { name:'Greed',    desc:'Start with +25 Gold.',  cost:75,  max:5 },
  wisdom:   { name:'Wisdom',   desc:'Start with +10 Max MP.',cost:100, max:5 },
  pockets:  { name:'Deep Pockets', desc:'Start with +1 Potion.', cost:150, max:3 },
  vision:   { name:'Owl Eyes', desc:'Start with +1 Vision Range.', cost:300, max:2 }
};

function getSoulBalance(){
  const m = loadMeta();
  return m.shards || 0;
}

function renderShopUI(){
  const list = document.getElementById('shopList');
  const balEl = document.getElementById('shopBalance');
  const modeLabel = document.getElementById('shopModeLabel');
  
  // Default to Classic if not set
  if (!state.ui) state.ui = {};
  if (!state.ui.shopTab) state.ui.shopTab = 'classic'; 

  const isEndlessUnlocked = localStorage.getItem('endlessUnlocked') === '1';
  // If Endless is not unlocked, force user onto Classic tab
  if (!isEndlessUnlocked) state.ui.shopTab = 'classic'; 

  const isEndless = (state.ui.shopTab === 'endless');
  const prefix = isEndless ? 'endless_upg_' : 'upg_'; // Separate save keys

  // Update Tab Visuals
  const btnC = document.getElementById('btnShopClassic');
  const btnE = document.getElementById('btnShopEndless');
  if(btnC) {
      btnC.style.border = isEndless ? '1px solid var(--chipBorder)' : '2px solid #f9d65c';
      btnC.style.opacity = isEndless ? '0.6' : '1.0';
      btnC.onclick = () => { state.ui.shopTab = 'classic'; renderShopUI(); };
  }
  if(btnE) {
      // NEW: Show/Hide Endless Button
      btnE.style.display = isEndlessUnlocked ? '' : 'none';
      
      btnE.style.border = isEndless ? '2px solid #f9d65c' : '1px solid var(--chipBorder)';
      btnE.style.opacity = isEndless ? '1.0' : '0.6';
      btnE.onclick = () => { state.ui.shopTab = 'endless'; renderShopUI(); };
  }
  
  if (modeLabel) modeLabel.textContent = isEndless ? "Endless Mode Upgrades" : "Classic Mode Upgrades";

  const m = loadMeta();
  const bal = m.shards || 0;
  
  balEl.textContent = `${bal} Shards`;
  list.innerHTML = '';

  for(const [k, def] of Object.entries(SOUL_UPGRADES)){
    // Use the prefix to load specific data
    const level = m[prefix + k] || 0; 
    
    const isMax = level >= def.max;
    const cost = Math.floor(def.cost * (1 + level * 0.5));
    
    const row = document.createElement('div');
    row.className = 'card';
    row.style.padding = '10px';
    row.style.display = 'flex';
    row.style.justifyContent = 'space-between';
    row.style.alignItems = 'center';
    row.style.backgroundColor = 'rgba(0,0,0,0.2)';
    
    const info = document.createElement('div');
    info.innerHTML = `<div style="font-weight:bold; color:#d9e7f5">${def.name} <span style="opacity:0.6">(${level}/${def.max})</span></div>
                      <div style="font-size:13px; opacity:0.8">${def.desc}</div>`;
    
    const btn = document.createElement('button');
    btn.className = 'btn';
    
    if(isMax){
      btn.textContent = 'MAX';
      btn.disabled = true;
      btn.style.opacity = 0.5;
    } else {
      btn.textContent = `Buy (${cost})`;
      if(bal < cost) {
        btn.disabled = true;
        btn.style.opacity = 0.5;
      }
      btn.onclick = () => {
        m.shards -= cost;
        // Use the prefix to SAVE specific data
        m[prefix + k] = level + 1;
        saveMeta(m);
        SFX.levelUp(); 
        renderShopUI(); 
        updateMainMenuShopLabel();
      };
    }
    
    row.appendChild(info);
    row.appendChild(btn);
    list.appendChild(row);
  }
}

function updateMainMenuShopLabel(){
  const el = document.getElementById('btnShop');
  if(el) el.textContent = `Soul Shop`;
}

function loadMeta(){ try{ return JSON.parse(localStorage.getItem(META_KEY)||'{}'); }catch{ return {}; } }
function saveMeta(m){ localStorage.setItem(META_KEY, JSON.stringify(m)); }

function incrementMetaStat(key, amt=1){
  const m = loadMeta();
  m[key] = (m[key]||0) + amt;
  
  // Check for unlocks immediately
  for(const cKey in CLASSES){
    const c = CLASSES[cKey];

    // --- NEW: Prevent unlocking Endless classes while playing Classic ---
    if (c.endless && state.gameMode !== 'endless') continue;
    // ------------------------------------------------------------------

    if(c.req === key && m[key] >= c.val && !m['unlocked_'+cKey]){
      m['unlocked_'+cKey] = true;
      showBanner(`Unlocked Class: ${c.name}!`, 4000);
      SFX.levelUp?.();
    }
  }
  saveMeta(m);
}

function loadHi(){ try{ return JSON.parse(localStorage.getItem(HS_KEY)||'[]'); }catch{ return []; } }
function saveHi(list){ localStorage.setItem(HS_KEY, JSON.stringify(list)); }

function freshRunStats(){
  return {
    initials: '',
    depth: 1,
    level: 1,
    kills: 0,
    ended: false,
    when: Date.now(),     // tiebreak
    startAt: 0,           // timer start
    endAt:   0,           // timer freeze
    elapsedMs: 0,
    finalMs: 0,
    timeMs:  0
  };
}

state.run = freshRunStats();
state._hiscores = loadHi();

// ===== Run Timer helpers =====
let __runTimerIvl = null;

function formatRunTime(ms){
  ms = Math.max(0, ms|0);
  const totalS = Math.floor(ms / 1000);
  const h = Math.floor(totalS / 3600);
  const m = Math.floor((totalS % 3600) / 60);
  const s = totalS % 60;
  const hh = String(h).padStart(2,'0');
  const mm = String(m).padStart(2,'0');
  const ss = String(s).padStart(2,'0');
  return `${hh}:${mm}:${ss}`;
}


function ensureRunTimerNode(){
  let el = document.getElementById('runTimer');
  if (!el){
    const cw = document.getElementById('cw');
    if (cw){
      el = document.createElement('div');
      el.id = 'runTimer';
      el.textContent = '00:00:00';
      el.style.cssText = 'position:absolute; top:8px; left:8px; z-index:16; padding:4px 8px; border-radius:8px; background:rgba(0,0,0,.45); border:1px solid rgba(255,255,255,.15); color:#eaf2ff; font:800 13px/1 ui-sans-serif,system-ui; letter-spacing:.02em;';
      cw.appendChild(el);
    }
  }
  return el;
}

function currentRunMs(){
  const r = (typeof state !== 'undefined' && state.run) ? state.run : { startAt:0, elapsedMs:0, endAt:0 };
  if (!r.startAt) return 0;
  const end = r.endAt || Date.now();
  return (r.elapsedMs|0) + (end - r.startAt);
}

function updateRunTimerNow(){
  const el = ensureRunTimerNode();
  if (!el) return;
  const ms = currentRunMs();
  el.textContent = formatRunTime(ms);
}

function startRunTimer(){
  // reset and start
  state.run.startAt = Date.now();
  state.run.endAt   = 0;
  state.run.elapsedMs = 0;
  state.run.finalMs = 0;
  state.run.timeMs  = 0;
  updateRunTimerNow();
  if (__runTimerIvl) clearInterval(__runTimerIvl);
  __runTimerIvl = setInterval(updateRunTimerNow, 100); // smooth ticking even when idle
}

function stopRunTimerFreeze(){
  if (!state.run.endAt){
    state.run.endAt  = Date.now();
    state.run.finalMs = currentRunMs();
    state.run.timeMs  = state.run.finalMs;
  }
  updateRunTimerNow();
}


function doRestart(className){
  // --- FIX: Toggle UI Bars ---
  // Hide bars if in menu (no className), Show them if starting run (has className)
  const uiBars = document.querySelector('.bars');
  if (uiBars) uiBars.style.visibility = className ? 'visible' : 'hidden';

  // --- Class Selection Intercept ---
  if (!className) {
    const meta = loadMeta();
    let available = Object.keys(CLASSES);

    // FILTER: If Classic Mode, hide classes marked 'endless: true'
    if (state.gameMode === 'classic') {
      available = available.filter(k => !CLASSES[k].endless);
    }

    // Determine which of the available classes are actually unlocked
    const unlocked = available.filter(k => CLASSES[k].unlock || meta['unlocked_'+k]);
    
    // Show menu if ANY class is available (even just the default)
    if (unlocked.length >= 1) {
      // --- FIX: Clear the view so we don't see the dead run behind the menu ---
      const cvs = document.getElementById('view');
      const cx = cvs ? cvs.getContext('2d') : null;
      if (cx) {
        cx.fillStyle = '#0b141d';
        cx.fillRect(0, 0, cvs.width, cvs.height);
      }
      // 1. ADDED: Clear any lingering floor tint (Miasma, Bloodhunt, etc.)
      const ft = document.getElementById('floorTint');
      if (ft) ft.style.background = 'rgba(0,0,0,0)';
      // -----------------------------------------------------------------------

      const m = document.getElementById('classSelectModal');
      const b = document.getElementById('classSelectBody');
      b.innerHTML = '';
      // --- NEW: Grid Layout Styles (4 Columns Fixed) ---
      b.style.display = 'grid';
      b.style.gridTemplateColumns = 'repeat(4, 1fr)'; 
      b.style.gap = '10px';
      b.style.padding = '10px';
      
      // 1. Show Unlocked Classes
      unlocked.forEach(k => {
        const c = CLASSES[k];
        const btn = document.createElement('button');
        btn.className = 'btn';
        btn.style.textAlign = 'center';
        
        // Force Square Shape & Center Content
        btn.style.aspectRatio = '1 / 1'; 
        btn.style.display = 'flex';
        btn.style.flexDirection = 'column';
        btn.style.justifyContent = 'center';
        btn.style.alignItems = 'center';
        btn.style.padding = '4px';
        btn.style.minHeight = '0'; // Reset min-height so aspect-ratio rules
        
        const badge = c.endless ? '<div style="color:#a78bfa; font-size:9px; margin-bottom:2px;">(Endless)</div>' : '';
        
        // Name is bold, Description is small (visible inside the square)
        btn.innerHTML = `
            ${badge}
            <div style="font-weight:800; font-size:13px; color:#f9d65c; line-height:1.1; margin-bottom:4px;">${c.name}</div>
            <div style="font-size:10px; opacity:0.8; line-height:1.1; overflow:hidden;">${c.desc}</div>
        `;
        
        // Also add full description as tooltip just in case it cuts off
        btn.title = c.desc; 
        
        btn.onclick = () => {
          m.style.display = 'none';
          doRestart(k); 
        };
        b.appendChild(btn);
      });
      
      // 2. Show Locked Classes (grayed out)
      available.forEach(k => {
        if (unlocked.includes(k)) return;
        const c = CLASSES[k];
        const d = document.createElement('div');
        d.className = 'chip';
        d.style.opacity = '0.5';
        d.style.textAlign = 'left';
        d.innerHTML = `üîí <b>${c.name}</b><br><span style="font-size:12px">${c.msg || 'Locked'}</span>`;
        b.appendChild(d);
      });

      m.style.display = 'flex';
      const go = document.getElementById('gameOverModal');
      if (go) go.style.display = 'none';
      return; 
    }
    
    className = 'Peasant';
  }
  // --------------------------------------

  state.gameOver = false;
  state._inputLocked = false; 
  state.player.poisoned = false;
  state.player.poisonTicks = 0;
  state.gameMode = state.gameMode || 'classic';

  // 1. ADDED: Clear run flags (cutscenes, boss states)
  state.flags = {}; 

  delete state.floorEffect;
  delete state.player.tempVisionRange;
  state._miasmaSteps = 0;
  const tintEl = document.getElementById('floorTint');
  if (tintEl) tintEl.style.background = 'rgba(0,0,0,0)';

  state.run = freshRunStats();
  if (!state._hiscores) state._hiscores = loadHi();

  state.floor = 1;
  state.player.level = 1;
  state.player.xp = 0;
  state.player.next = PLAYER_XP_START;          
  state.player.hpMax = 20;
  state.player.mpMax = 10;
  
  // --- NEW: Stamina Init ---
  state.player.staminaMax = 10;
  state.player.stamina = 10;

// --- HARD RESET PLAYER STATE (Moved Above Class Modifiers) ---
  state.player = {
    x:0, y:0, rx:0, ry:0,
    level:1, xp:0, next:PLAYER_XP_START,
    hpMax:20, mpMax:10,
    hp:20, mp:10,
    stamina:10, staminaMax:10,
    poisoned:false, poisonTicks:0,
    facing:'down',
    bow:{ range:5, loaded:0 },
    artCooldown: 0,
    shield: null
  };

  // --- Apply Class Stats Modifiers ---
  if (className === 'Barbarian') {
    state.player.hpMax += 10; state.player.hp = state.player.hpMax;
    state.player.mpMax = Math.max(0, state.player.mpMax - 5); state.player.mp = state.player.mpMax;
  } else if (className === 'Wizard') {
    state.player.mpMax += 20; state.player.mp = state.player.mpMax;
    state.player.hpMax -= 5;  state.player.hp = state.player.hpMax;
  } else if (className === 'Rogue') {
    state.player.mpMax += 5;  state.player.mp = state.player.mpMax;
    state.player.hpMax -= 3;  state.player.hp = state.player.hpMax;
  } else if (className === 'Mercenary') {
    state.player.hpMax += 8;  state.player.hp = state.player.hpMax;
    state.player.mpMax = Math.max(0, state.player.mpMax - 8); state.player.mp = state.player.mpMax;
  } else if (className === 'Monk') {
    state.player.mpMax += 10; state.player.mp = state.player.mpMax;
    state.player.hpMax -= 5;  state.player.hp = state.player.hpMax;
  } else if (className === 'Ranger') {
    state.player.mpMax += 5;  state.player.mp = state.player.mpMax;
    state.player.hpMax -= 2;  state.player.hp = state.player.hpMax;
  } else if (className === 'Lancer') {
    state.player.staminaMax += 10; state.player.stamina = state.player.staminaMax;
    state.player.mpMax = Math.max(0, state.player.mpMax - 5); state.player.mp = state.player.mpMax;
  } else if (className === 'Soldier') {
    state.player.hpMax += 5;       state.player.hp = state.player.hpMax;
    state.player.staminaMax += 5;  state.player.stamina = state.player.staminaMax;
    state.player.mpMax = Math.max(0, state.player.mpMax - 10); state.player.mp = state.player.mpMax;
  } else if (className === 'Spellblade') {
    state.player.mpMax += 5; state.player.mp = state.player.mpMax;
    state.player.staminaMax += 5; state.player.stamina = state.player.staminaMax;
  } else if (className === 'Paladin') {
    state.player.hpMax += 25; state.player.hp = state.player.hpMax;
    state.player.staminaMax += 10; state.player.stamina = state.player.staminaMax;
    state.player.mpMax = Math.max(0, state.player.mpMax - 10); state.player.mp = state.player.mpMax;
  } else if (className === 'Legionary') {
    state.player.hpMax += 10; state.player.hp = state.player.hpMax;
    state.player.staminaMax = Math.max(0, state.player.staminaMax - 5); state.player.stamina = state.player.staminaMax;
  }

  // --- Apply Soul Shop Upgrades (IF NOT TUTORIAL) ---
  const meta = loadMeta();
  // Disable shop upgrades for Tutorial to keep it standard
  const upgPrefix = (state.gameMode === 'endless') ? 'endless_upg_' : 'upg_';
  const isTut = (state.gameMode === 'tutorial');

  if (!isTut) {
    state.player.hpMax += ((meta[upgPrefix+'vitality']||0) * 5);
    state.player.mpMax += ((meta[upgPrefix+'wisdom']||0) * 10);
  }

  state.player.hp = state.player.hpMax;
  state.player.mp = state.player.mpMax;

  // Defaults
  state.player.weapon = { name:'Fists', type:'hand', min:1, max:2, base:{min:1,max:2}, dur:null, durMax:null };
  state.player.artCooldown = 0; 

  state.fovRadius = 5 + ((meta[upgPrefix+'vision']||0) * 1);
  state.spells = [];
  state.equippedSpell = null;
  state.player.bow = { range:5, loaded:0 };
  state._hitParity = 0;
  state.player.shield = null;     
  state._shieldParity = 0;
  state.skills = {};

// Disable shop items for Tutorial
  const pockets = isTut ? 0 : ((meta[upgPrefix+'pockets']||0) * 1);
  const greed   = isTut ? 0 : ((meta[upgPrefix+'greed']||0) * 25);

  state.inventory = {
    lockpicks: 0, 
    potions: pockets, 
    tonics: 0, antidotes: 0, 
    weapons: {}, stashed: {}, arrows: 0, 
    gold: greed,     
    shields: 0, bombs:0, warpStones:0
  };

  // --- Apply Class Gear ---
  if (className === 'Rogue') {
    state.inventory.weapons['Shortsword'] = 1; 
    equipWeaponByName('Shortsword');
    state.inventory.lockpicks = 5;
  } else if (className === 'Barbarian') {
    state.inventory.weapons['Axe'] = 1;
    equipWeaponByName('Axe');
  } else if (className === 'Wizard') {
    state.inventory.weapons['Fire Staff'] = 1; equipWeaponByName('Fire Staff');
state.spells.push({name:'Ember', cost:3, tier:1}); state.equippedSpell = state.spells[0];  }
// -- New Classes --
  else if (className === 'Mercenary') {
    // Claymore: High damage, cleave ability
    state.inventory.weapons['Claymore'] = 1;
    equipWeaponByName('Claymore');
    // REMOVED DUPLICATE STATS (Already applied at top of function)
  } else if (className === 'Monk') {
    // Knuckle Duster: Fast attack, stun chance
    state.inventory.weapons['Knuckle Duster'] = 1;
    equipWeaponByName('Knuckle Duster');
    // REMOVED DUPLICATE STATS (Already applied at top of function)
  } else if (className === 'Ranger') {
    // Ranger gets standard sword backup + lots of ammo
    state.inventory.weapons['Shortsword'] = 1;
    equipWeaponByName('Shortsword');
    state.inventory.arrows = 20;
    state.player.bow.loaded = 1;
  } else if (className === 'Lancer') {
    state.inventory.weapons['Halberd'] = 1; equipWeaponByName('Halberd');
  } else if (className === 'Soldier') {
    state.inventory.weapons['Shortsword'] = 1; equipWeaponByName('Shortsword');
    state.inventory.weapons['Kite Shield'] = 1; equipShield('Kite Shield');
  } else if (className === 'Spellblade') {
    state.inventory.weapons['Shortsword'] = 1; equipWeaponByName('Shortsword');
    state.inventory.weapons['Ice Staff'] = 1; // Backup
    state.spells.push({name:'Frost', cost:3, tier:1}); state.equippedSpell = state.spells[0];
  } else if (className === 'Legionary') {
    state.inventory.weapons['Shortsword'] = 1; equipWeaponByName('Shortsword');
    state.inventory.weapons['Tower Shield'] = 1; equipShield('Tower Shield');
  } else if (className === 'Paladin') {
    state.inventory.weapons['Warhammer'] = 1; equipWeaponByName('Warhammer');
  }

  // Finalize
  gen();
  state.player.rx = state.player.x;
  state.player.ry = state.player.y;
  enemyStep();
  draw?.();
  updateBars();
  updateEquipUI();
  renderSkills && renderSkills();
  startRunTimer();
  updateRunTimerNow();

  // 1. ADDED: Restore the opening flavor text
  log('You awaken with nothing. Explore, loot, survive.');
  log('A chest is nearby.');

  const m = document.getElementById('gameOverModal');
  if (m) m.style.display = 'none';

  // Pick 1 of 2 (Endless only)
  if (state.gameMode === 'endless') {
    requestAnimationFrame(()=>{
      const f = window.offerPick2Choice;
      if (f) { try { f('start'); } catch(e){} }
    });
  }
}


// === Arcade score flow ===
function openScoreEntry(){
  stopRunTimerFreeze();                    // ‚Üê add this line
  const m  = document.getElementById('scoreModal');
  const inp= document.getElementById('scoreInitials');
  const ent= document.getElementById('scoreEntry');
  const lst= document.getElementById('hiscoreList');
  if (!m) return;

  // snapshot final values once
  state.run.level = state.player.level;
state.run.depth = state.floor|0;                  // ‚Üê NEW
state.run.timeMs = state.run.finalMs || currentRunMs();  // ‚Üê NEW

  ent.style.display = 'block';
  lst.style.display = 'none';
  m.style.display = 'flex';
if (typeof setMobileControlsVisible === 'function') setMobileControlsVisible(false);

  setTimeout(()=>{ if (inp){ inp.focus(); inp.select(); } }, 0);
}

function renderHiscores(){
  const tables = document.querySelectorAll('#hiscoreTable');
  tables.forEach(tbl=>{
    tbl.innerHTML = '';

    ['Initials','Depth','Time','Level','Kills'].forEach(h=>{
      const d = document.createElement('div');
      d.style.fontWeight = '800';
      d.textContent = h;
      tbl.appendChild(d);
    });

    (state._hiscores || []).forEach(row=>{
      const cells = [
        (row.initials || '???').toUpperCase(),
        row.depth|0,
        formatRunTime(row.timeMs ?? row.finalMs ?? 0),
        row.level|0,
        row.kills|0
      ];
      cells.forEach(v=>{
        const d = document.createElement('div');
        d.textContent = v;
        tbl.appendChild(d);
      });
    });
  });

}

function saveScore(initialsRaw){
  const initials = (initialsRaw||'???').toUpperCase().replace(/[^A-Z]/g,'').slice(0,3) || '???';
  const row = { initials, depth: state.run.depth|0, level: state.run.level|0, kills: state.run.kills|0, when: state.run.when|0, timeMs: state.run.timeMs|0  };
  // --- NEW: Calculate & Save Shards ---
  // --- Adjusted Shard Scaling ---
  // Formula: (Depth * 1) + (Kills * 0.5) + (Level * 2)
  const earnedShards = (state.gameMode === 'tutorial') ? 0 
     : Math.floor((state.run.depth * 1) + (state.run.kills * 0.5) + (state.run.level * 2));

  if (earnedShards > 0) {
    const m = loadMeta();
    m.shards = (m.shards || 0) + earnedShards;
    saveMeta(m);
    showBanner(`Soul Shards Earned: +${earnedShards}`, 4000);
    updateMainMenuShopLabel();
  }
  // ------------------------------------

  const list = (state._hiscores||[]).concat([row]).sort((a,b)=>{
    // sort by depth desc, then kills desc, then level desc, then earlier date
    if (b.depth !== a.depth) return b.depth - a.depth;
    if (b.kills !== a.kills) return b.kills - a.kills;
    if (b.level !== a.level) return b.level - a.level;
    return a.when - b.when;
  }).slice(0,10);
  state._hiscores = list;
  saveHi(list);
}

document.addEventListener('DOMContentLoaded', ()=>{   // <-- ensure elements exist
  (function attachScoreUI(){
    const m  = document.getElementById('gameOverModal');
    const scoreM = document.getElementById('scoreModal');
    const btnSave = document.getElementById('btnSaveScore');
    const inp = document.getElementById('scoreInitials');
    const ent= document.getElementById('scoreEntry');
    const lst= document.getElementById('hiscoreList');
    const playAgain = document.getElementById('btnPlayAgain');

    if (btnSave) btnSave.addEventListener('click', ()=>{
      // If entry is visible, allow save regardless of run.ended being set.
      if (ent && ent.style.display !== 'none') {
        saveScore(inp && inp.value);
        ent.style.display = 'none';
        lst.style.display = 'block';
        renderHiscores();
      }
    });

    if (inp) inp.addEventListener('keydown', (e)=>{
      e.stopPropagation(); // don't move the player while typing
      if (e.key === 'Enter'){ e.preventDefault(); btnSave?.click(); }
    });

    // after:  const playAgain = document.getElementById('btnPlayAgain');
if (playAgain) playAgain.addEventListener('click', ()=>{
      // hide leaderboard modal
      const scoreM = document.getElementById('scoreModal');
      if (scoreM) scoreM.style.display = 'none';
      
      // Also ensure Game Over modal is closed (it might be underneath)
      const goM = document.getElementById('gameOverModal');
      if (goM) goM.style.display = 'none';

      // Return to Main Menu instead of instant restart
      if (typeof goMenu === 'function') goMenu();
    });

    // Observe Game Over modal becoming visible ‚Üí trigger score entry once
    if (m){
      const obs = new MutationObserver(()=>{
        // consider any visible state, not just "block" (your modal uses flex)
        if (getComputedStyle(m).display !== 'none' && !state.run._scoreOpened){
          state.run._scoreOpened = true;   // guard so it only opens once
          // make sure save button isn‚Äôt blocked by this flag
          state.run.ended = true;          // <-- guarantees Save handler can proceed
          openScoreEntry();
        }
      });
      obs.observe(m, { attributes:true, attributeFilter:['style'] });
    }
  })();
});

// === Spell upgrade modal wiring ===
(function(){
  let _pendingSpellToUpgrade = null;

  function maybePromptSpellUpgrade(name){
    const up = ensureSpellUpgradeSlot(name);
    const canDmg   = up.dmg   < MAX_SPELL_BONUS;
    const canRange = up.range < MAX_SPELL_BONUS;
    if (up.shards >= 5 && (canDmg || canRange)){
      _pendingSpellToUpgrade = name;
      const t = document.getElementById('spellUpTitle');
      const m = document.getElementById('spellUpMsg');
      if (t) t.textContent = `Upgrade ${name}`;
      if (m) m.textContent = `You‚Äôve collected 5 duplicate ${name} scrolls. Choose an upgrade:`;
      const modal = document.getElementById('spellUpModal');
      if (modal) modal.style.display='flex';
    }
  }

  window.__maybePromptSpellUpgrade = maybePromptSpellUpgrade;

  const modal = document.getElementById('spellUpModal');
  const close = ()=>{ if (modal) modal.style.display='none'; _pendingSpellToUpgrade=null; setMobileControlsVisible(true); };

  const bD = document.getElementById('btnSpellUpDmg');
  const bR = document.getElementById('btnSpellUpRange');

  function consumeFiveShardsAndApply(name, which){
    const up = ensureSpellUpgradeSlot(name);
    if (up.shards < 5) return;
    if (which==='dmg'   && up.dmg   < MAX_SPELL_BONUS){ up.dmg++;   up.shards -= 5; log(`${name} damage increased (+1).`); }
    if (which==='range' && up.range < MAX_SPELL_BONUS){ up.range++; up.shards -= 5; log(`${name} range increased (+1).`); }
    if (typeof updateSpellBody === 'function') updateSpellBody();
  }

  if (bD) bD.onclick = ()=>{ if (_pendingSpellToUpgrade) consumeFiveShardsAndApply(_pendingSpellToUpgrade,'dmg'); close(); };
  if (bR) bR.onclick = ()=>{ if (_pendingSpellToUpgrade) consumeFiveShardsAndApply(_pendingSpellToUpgrade,'range'); close(); };
  if (modal) modal.addEventListener('click', e=>{ if (e.target===modal) close(); });
})();


document.addEventListener('click', (ev)=>{
  if(ev.target && ev.target.id==='btnRestart'){ 
    document.getElementById('gameOverModal').style.display = 'none';
    goMenu(); 
  }
});

window.openGoldWell = function(){
  // 1. Inject HTML if missing (Restores the Popup)
  if (!document.getElementById('goldWellModal')) {
    const d = document.createElement('div');
    d.id = 'goldWellModal'; d.className = 'modal'; d.style.display = 'none';
    d.innerHTML = `
      <div class="sheet">
        <div class="row"><div class="title">Golden Well</div><button class="btn" id="gwClose">Close</button></div>
        <div id="gwMsg" style="opacity:.9; margin:10px 0; text-align:center;">
           A mystical well glows with power. Toss 500 gold to receive a blessing?
        </div>
        <div class="row" style="justify-content:center; gap:10px;">
           <button class="btn" id="gwBuy">Toss Gold (500g)</button>
        </div>
        <div style="text-align:center; margin-top:8px; opacity:0.8;">
           Gold: <span id="gwGold">0</span>
        </div>
      </div>`;
    document.body.appendChild(d);
    
    // Wire buttons
    d.querySelector('#gwClose').onclick = () => {
       d.style.display = 'none'; 
       state._inputLocked = false;
       if (!state._pauseOpen) setMobileControlsVisible(true);
    };
    
    d.querySelector('#gwBuy').onclick = () => {
       const w = state.goldWell;
       if (!w || w.used) { document.getElementById('gwMsg').textContent = "The well is empty."; return; }
       if ((state.inventory.gold|0) < 500) { document.getElementById('gwMsg').textContent = "Not enough gold."; return; }
       
       // Pay Logic
       state.inventory.gold -= 500;
       w.used = true;
       unlockCodex('Gold_Well', true);
       
       SFX.levelUp();
       spawnParticles(state.player.x, state.player.y, '#facc15', 12);
       updateBars(); updateInvBody();
       
       // Close the Confirmation Modal
       d.style.display = 'none';
       
       // Open the Choice Modal (Helper)
       // We keep input locked here because the Choice modal takes over immediately
       if (typeof openGoldenWellChoice === 'function') {
           openGoldenWellChoice();
       } else {
           // Fallback safety
           state.player.hpMax += 5; state.player.hp = state.player.hpMax;
           log("Vitality surges! (+5 Max HP)");
           state._inputLocked = false;
           if (!state._pauseOpen) setMobileControlsVisible(true);
       }
    };
  }
  
  // Logic to Open the Confirmation Modal
  const m = document.getElementById('goldWellModal');
  const w = state.goldWell;
  const msg = document.getElementById('gwMsg');
  const btn = document.getElementById('gwBuy');
  const g = document.getElementById('gwGold');
  
  if (g) g.textContent = state.inventory.gold|0;
  unlockCodex('Gold_Well'); 
  
  if (w.used) {
     msg.textContent = "The waters are still. The magic is gone.";
     btn.style.display = 'none';
  } else {
     msg.textContent = "A mystical well glows with power. Toss 500 gold to receive a blessing?";
     btn.style.display = '';
     btn.textContent = "Toss Gold (500g)";
     btn.disabled = (state.inventory.gold|0) < 500;
  }
  
  m.style.display = 'flex';
  state._inputLocked = true;
  setMobileControlsVisible(false);
};

// --- NEW: Weapon Swap / Inventory Limit Logic ---
const MAX_WEAPON_CAT = 5;

function getWeaponType(name) {
  // Reliance on weaponStatsFor ensures a single source of truth
  const st = weaponStatsFor(name);
  return st ? st.type : 'hand';
}

function countWeaponsInCategory(targetType) {
  let count = 0;
  for (const [name, qty] of Object.entries(state.inventory.weapons || {})) {
    if (getWeaponType(name) === targetType) count += (qty|0);
  }
  return count;
}

window.openWeaponSwapModal = function(newItemPayload, pickupKey, x, y) {
  // 1. Inject HTML if missing
  if (!document.getElementById('swapModal')) {
    const d = document.createElement('div');
    d.id = 'swapModal'; d.className = 'modal'; d.style.display = 'none'; d.style.zIndex = '10002';
    d.innerHTML = `
      <div class="sheet" style="width:min(600px, 94vw)">
        <div class="title" style="margin-bottom:10px; text-align:center; color:#f9d65c">Inventory Full</div>
        <div id="swapMsg" style="text-align:center; margin-bottom:15px; opacity:0.9">
           You can only carry ${MAX_WEAPON_CAT} weapons of this type.
        </div>
        
        <div style="display:grid; grid-template-columns:1fr 1px 1fr; gap:10px; align-items:start;">
           <div style="display:flex; flex-direction:column; gap:8px;">
              <div style="font-weight:bold; text-align:center; font-size:12px; opacity:0.7">SCRAP ONE:</div>
              <div id="swapList" style="display:flex; flex-direction:column; gap:6px;"></div>
           </div>
           
           <div style="background:rgba(255,255,255,0.2); height:100%;"></div>

           <div style="display:flex; flex-direction:column; gap:8px;">
              <div style="font-weight:bold; text-align:center; font-size:12px; opacity:0.7">OR LEAVE NEW:</div>
              <button class="btn" id="swapNewBtn" style="border:1px solid #facc15; padding:12px; text-align:left;"></button>
           </div>
        </div>
      </div>`;
    document.body.appendChild(d);
  }

  const m = document.getElementById('swapModal');
  const list = document.getElementById('swapList');
  const newBtn = document.getElementById('swapNewBtn');
  const msg = document.getElementById('swapMsg');
  
  const wType = getWeaponType(newItemPayload.name);
  const niceType = typeNice(wType);
  
  msg.textContent = `Your ${niceType} bag is full (${MAX_WEAPON_CAT}/${MAX_WEAPON_CAT}). Scrap an old one to take the new one?`;
  list.innerHTML = '';

  // 1. Helper to format stats
  const fmt = (name, min, max) => {
     // Apply floor effect logic for display
     let dMin = min, dMax = max;
     if (state.floorEffect === 'AntiMagic') { dMin = Math.ceil(dMin*1.5); dMax = Math.ceil(dMax*1.5); }
     else if (state.floorEffect === 'ArcaneFlux') { dMin = Math.ceil(dMin*0.25); dMax = Math.ceil(dMax*0.25); }
     return `<b>${name}</b><br><span style="font-size:12px; opacity:0.8">Dmg: ${dMin}-${dMax}</span>`;
  };

  // 2. Populate "Scrap" List (Current Inventory)
  for (const [name, qty] of Object.entries(state.inventory.weapons || {})) {
    if (getWeaponType(name) !== wType) continue; // Only show matching category
    
    const stats = weaponStatsFor(name) || { min:0, max:0 };
    const btn = document.createElement('button');
    btn.className = 'btn';
    btn.style.cssText = 'text-align:left; padding:8px; border:1px solid #ef4444; color:#fca5a5;';
    const xpVal = 10 + (state.floor * 2);
    btn.innerHTML = `SCRAP (+${xpVal} XP): ${fmt(name, stats.min, stats.max)}`;
    
    // ACTION: Scrap Old -> Take New
    btn.onclick = () => {
       // Remove Old
       state.inventory.weapons[name]--;
       if (state.inventory.weapons[name] <= 0) delete state.inventory.weapons[name];
       
       // Add New
       state.inventory.weapons[newItemPayload.name] = (state.inventory.weapons[newItemPayload.name]||0) + 1;
       
       // Clear Floor
       delete state.pickups[pickupKey];
       state.tiles[y][x] = 1;
       
       // --- NEW: Grant Weapon Skill XP ---
       // Award XP to the weapon category (e.g., One-Handed)
       // Base 10 XP + 2 per floor
       const xpAmt = 10 + (state.floor * 2);
       
       ensureSkill(wType);
       const s = state.skills[wType];
       s.shown = true; // <--- ADD THIS: Force the UI to show this skill
       s.xp += xpAmt;
       
       // Handle Level Up immediately
       let leveled = false;
       while(s.xp >= s.next){ 
           s.xp -= s.next; 
           s.lvl++; 
           s.next = Math.floor(s.next * SKILL_XP_GROWTH); 
           leveled = true;
       }
       
       if(leveled) {
           log(`${typeNice(wType)} advanced to ${s.lvl}!`);
           renderSkills(); // Update UI
           recomputeWeapon(); // Apply new damage bonus
       }

       spawnFloatText(`+${xpAmt} XP`, state.player.x, state.player.y, '#a78bfa');
       // -------------------------------------

       log(`Dismantled ${name}. Learned from its design.`);
       SFX.weaponBreak(); // Crunch sound for scrapping
       SFX.pickup();      // Pickup sound
       
       m.style.display = 'none';
       state._inputLocked = false;
       updateInvBody();
       updateEquipUI();
       draw();
    };
    list.appendChild(btn);
  }

  // 3. Populate "Leave" Button (New Item)
  newBtn.innerHTML = `LEAVE: ${fmt(newItemPayload.name, newItemPayload.min, newItemPayload.max)}`;
  newBtn.onclick = () => {
     log(`You leave the ${newItemPayload.name} on the floor.`);
     m.style.display = 'none';
     state._inputLocked = false;
  };

  // Show
  m.style.display = 'flex';
  state._inputLocked = true;
};

// --- NEW HELPER FUNCTIONS ---

function checkMiniBossReward(e) {
    if (e.miniBoss && state.gameMode === 'endless') {
        log("The Warlord falls! A dark power calls to you...");
        spawnFloatText("OMEN!", e.x, e.y, '#a78bfa');
        setTimeout(() => { triggerOmenChoice(); }, 800);
    }
}

function useStaff(w) {
    const cost = 2; 
    if (state.player.mp < cost) {
        log("Out of mana! You bash with the staff.");
        const t = getFacingEnemy(); 
        if(t){
           t.hp -= 1; spawnFloatText("1", t.x, t.y, '#fff');
           if(t.hp<=0) { state.enemies=state.enemies.filter(x=>x!==t); state.run.kills++; awardKill('staff', t.xp); SFX.kill(); }
        } else log("You swing at the air.");
        enemyStep(); draw(); return;
    }

    let color='#fff', el='Magic';
    if(w.name.includes('Fire')){ color='#ef4444'; el='Fire'; }
    else if(w.name.includes('Ice')){ color='#06b6d4'; el='Ice'; }
    else if(w.name.includes('Light')){ color='#eab308'; el='Lightning'; }
    else if(w.name.includes('Wind')){ color='#a3a3a3'; el='Wind'; }
    else if(w.name.includes('Earth')){ color='#78350f'; el='Earth'; }

    state.player.mp -= cost; updateBars();
    const t = findFirstLinedTarget(state.player.x, state.player.y, 4);
    const tx = t ? t.x : (state.player.x + (state.player.facing==='right'?4 : state.player.facing==='left'?-4 : 0));
    const ty = t ? t.y : (state.player.y + (state.player.facing==='down'?4 : state.player.facing==='up'?-4 : 0));

    spawnProjectileEffect({
        kind:'magic', element:el, color:color, fromX:state.player.x, fromY:state.player.y, toX:tx, toY:ty,
        onDone:()=>{
            if(t){
                const bonus = Math.floor((state.skills.magic?.lvl||1)/2);
                const dmg = rand(w.min, w.max) + bonus;
                t.hp = Math.max(0, t.hp - dmg);
                spawnFloatText(dmg, t.x, t.y, color);
                checkMiniBossReward(t); 
                if(t.hp<=0) {
                    state.enemies=state.enemies.filter(x=>x!==t); state.run.kills++; awardKill('magic', t.xp); SFX.kill();
                }
            }
            enemyStep(); draw();
        }
    });
}

function equipShield(variant = 'Standard'){
  if (typeof variant !== 'string') variant = 'Standard'; // fallback
  
  if (state.player.shield && state.player.shieldName && state.player.shieldName !== 'Standard'){
     const old = state.player.shieldName;
     state.inventory.weapons[old] = (state.inventory.weapons[old]||0)+1;
  }

  state.player.shield = { name: variant, dur: 20 };
  state.player.shieldName = variant;
  
  if (variant.includes('Buckler')) state.player.blockChance = 0.15;
  else if (variant.includes('Tower')) state.player.blockChance = 0.35;
  else if (variant.includes('Ancient')) state.player.blockChance = 0.25;
  else state.player.blockChance = 0.20; 

  if (variant !== 'Standard' && state.inventory.weapons[variant]) {
      state.inventory.weapons[variant]--;
      if(state.inventory.weapons[variant]<=0) delete state.inventory.weapons[variant];
  } else if (variant === 'Standard') {
      state.inventory.shields = Math.max(0, (state.inventory.shields|0) - 1);
  }
  
  log(`You equip the ${variant}.`);
  updateEquipUI(); updateInvBody();
}

function openGoldenWellChoice(){
    const m = document.getElementById('lvlupModal');
    if(!m) return;
    
    const t = m.querySelector('.title');
    if(t) t.innerText = "Golden Well: Choose a Blessing";
    
    // Clone buttons to strip old listeners
    const bH = document.getElementById('btnHP'), bM = document.getElementById('btnMP'), bS = document.getElementById('btnStam');
    const nH = bH.cloneNode(true), nM = bM.cloneNode(true), nS = bS.cloneNode(true);
    bH.replaceWith(nH); bM.replaceWith(nM); bS.replaceWith(nS);

    // --- FIX: Use Game Scaling Helpers + Full Heal ---
    nH.onclick = () => { 
        // Use standard level-up formula (scales with floor/level)
        const inc = (typeof levelHpGain === 'function') ? levelHpGain() : 5;
        state.player.hpMax += inc; 
        state.player.hp = state.player.hpMax; // Full Heal
        log(`The well grants vitality! +${inc} Max HP (Healed)`); 
        closeWell(); 
    };
    
    nM.onclick = () => { 
        const inc = (typeof levelMpGain === 'function') ? levelMpGain() : 3;
        state.player.mpMax += inc; 
        state.player.mp = state.player.mpMax; // Full Mana
        log(`The well grants wisdom! +${inc} Max MP (Restored)`); 
        closeWell(); 
    };
    
    nS.onclick = () => { 
        const inc = (typeof levelStamGain === 'function') ? levelStamGain() : 3;
        state.player.staminaMax += inc; 
        state.player.stamina = state.player.staminaMax; // Full Stamina
        log(`The well grants endurance! +${inc} Max Stamina (Restored)`); 
        closeWell(); 
    };

    m.style.display = 'flex';
    state._inputLocked = true;
    
    function closeWell(){ 
        m.style.display='none'; 
        state._inputLocked=false; 
        updateBars(); 
        if(t) t.innerText = "Level Up!"; // Reset title for next time
    }
}

function triggerOmenChoice() {
    if (typeof PICK2_POOL === 'undefined' || PICK2_POOL.length < 2) return;
    const o1 = PICK2_POOL[Math.floor(Math.random() * PICK2_POOL.length)];
    let o2 = PICK2_POOL[Math.floor(Math.random() * PICK2_POOL.length)];
    while (o1.id === o2.id) { o2 = PICK2_POOL[Math.floor(Math.random() * PICK2_POOL.length)]; }

    const m = document.getElementById('pick2Modal'); 
    if (!m) return;
    m.querySelector('#pick2Title').innerText = "Choose an Omen";
    m.querySelector('#descPick1').innerText = o1.label;
    m.querySelector('#descPick2').innerText = o2.label;
    
    document.getElementById('btnPick2A').onclick = () => { o1.apply(); log(`Accepted: ${o1.id}`); m.style.display='none'; state._inputLocked=false; };
    document.getElementById('btnPick2B').onclick = () => { o2.apply(); log(`Accepted: ${o2.id}`); m.style.display='none'; state._inputLocked=false; };
    
    state._inputLocked = true; m.style.display = 'flex';
}

function getFacingEnemy(){
    const dirs = {up:[0,-1],down:[0,1],left:[-1,0],right:[1,0]};
    const [dx,dy] = dirs[state.player.facing||'down'];
    return enemyAt(state.player.x+dx, state.player.y+dy);
}

</script>

<!-- Help Modal -->
<div class="modal" id="helpModal">
  <div class="sheet">
    <div class="row"><div class="title">Keyboard Controls</div><button class="btn" data-close="#helpModal">Close</button></div>
    <div style="display:grid;grid-template-columns:140px 1fr;gap:6px;margin-top:6px">
      <div><b>WASD / Arrows</b></div><div>Move</div>
      <div><b>Space</b></div><div>Attack (adjacent)</div>
      <div><b>E</b></div><div>Interact (open chest, unlock door, descend)</div>
      <div><b>Q</b></div><div>Cast equipped spell (faced direction)</div>
      <div><b>F</b></div><div>Cycle Spells</div>
      <div><b>R</b></div><div>Weapon Art (Special Ability)</div>
      <div><b>I</b></div><div>Inventory</div>
      <div><b>P</b></div><div>Spells</div>
      <div><b>B</b></div><div>Bow (shoot)</div>
      <div><b>H</b></div><div>Show/Hide this help</div>
      <div><b>1</b></div><div>Use Potion</div>
      <div><b>2</b></div><div>Use Tonic</div>
      <div><b>3</b></div><div>Use Antidote</div>
      <div><b>4</b></div><div>Throw Bomb</div>
      <div><b>5</b></div><div>Use Warp Stone</div>
    </div>
  </div>
</div>

<!-- Game Over Modal -->
<div class="modal" id="gameOverModal">
  <div class="sheet">
    <div class="row"><div class="title">Game Over</div></div>
    <p style="margin:6px 0 12px 0">You have fallen. Tap Restart to try again.</p>
    <div class="row" style="justify-content:flex-end; gap:8px">
      <button class="btn" id="btnRestart">Restart</button>
    </div>
  </div>
</div>

<!-- Skill Details Modal -->
<div class="modal" id="skillModal" style="display:none;">
  <div class="sheet">
    <div class="row">
      <div class="title" id="skTitle">Skill</div>
      <button class="btn" data-close="#skillModal">Close</button>
    </div>
    <div id="skMsg" style="opacity:.9; margin-top:6px"></div>
  </div>
</div>

<!-- Classic Mode Clear Modal -->
<div class="modal" id="classicClearModal" style="display:none;">
  <div class="sheet">
    <div class="row"><div class="title">Classic Mode Cleared!</div></div>
    <p style="margin:6px 0 12px 0">
      Congratulations! You've beaten Classic Mode. Head on over to Endless Mode from the menu to delve deeper into the dungeon and find what mysteries lie within!
    </p>
    <div class="row" style="justify-content:flex-end; gap:8px">
      <button class="btn" id="btnReturnToMenu">Return to Menu</button>
    </div>
  </div>
</div>


<!-- Class Select Modal -->
<div class="modal" id="classSelectModal" style="display:none; z-index:25;">
  <div class="sheet">
    <div class="title" style="text-align:center; margin-bottom:10px;">Choose Your Path</div>
    <div id="classSelectBody" style="display:flex; flex-direction:column; gap:8px;"></div>
  </div>
</div>

<!-- High Score Modal -->
<div class="modal" id="scoreModal" style="display:none">
  <div class="sheet">
    <div class="row"><div class="title">New High Score</div>
      <button class="btn" data-close="#scoreModal">Close</button>
    </div>

    <div id="scoreEntry" style="margin:8px 0 12px">
      <div style="margin-bottom:8px">
        Enter Initials (3 letters):
      </div>
      <input id="scoreInitials" maxlength="3" style="font:700 28px/1 ui-sans-serif; text-transform:uppercase; width:120px; text-align:center; padding:8px; background:#0e1923; color:#dfe7f2; border:1px solid var(--chipBorder); border-radius:10px">
      <button class="btn" id="btnSaveScore" style="margin-left:8px">Save</button>
    </div>

    <div id="hiscoreList" style="display:none">
      <div style="font-weight:800;margin-bottom:6px">Top 10 Runs</div>
      <div id="hiscoreTable" style="display:grid; grid-template-columns:140px 1fr 1fr 1fr 1fr; gap:8px 18px"></div>
      <div class="row" style="justify-content:flex-end; gap:8px; margin-top:12px">
        <button class="btn" id="btnPlayAgain">Play Again</button>
      </div>
    </div>
  </div>
</div>



<!-- ===== Hard restart patch (drop-in) ===== -->
<script>
(function () {
  if (window.__restartPatchInstalled) return;
  window.__restartPatchInstalled = true;

  function hide(id) {
    var el = document.getElementById(id);
    if (el) el.style.display = 'none';
  }

  window.hardRestartGame = function hardRestartGame() {
    try {
      const S = window.gameState || window.state || (window.G && window.G.state);
      if (!S) {
  if (typeof window.doRestart === 'function') { window.doRestart(); }
  return;
}

      S.player = {
        x: 0, y: 0,
        hp: 20, mp: 10,
        maxHp: 20, maxMp: 10,
        level: 1, xp: 0,
        poisoned: false, poisonTicks: 0
      };

S.player.shield = null;     // üëâ add
S._shieldParity = 0; 

      S.inventory = { lockpicks: 0, potions: 0, tonics: 0 };
      S.inventory.shields = 0;
      S.weapons = {};
      S.equippedWeapon = null;
      S.spells = [];
      S.equippedSpell = null;
      state.player.bow.loaded = 0;
state.inventory.arrows = 0;   // or give a starter stash if you prefer
updateEquipUI();


      S.skillLevel = {
        handToHand: 1, oneHanded: 1, spear: 1, axe: 1, twoHanded: 1, lockpicking: 1
      };
      S.skillXp = {
        handToHand: 0, oneHanded: 0, spear: 0, axe: 0, twoHanded: 0, lockpicking: 0
      };

      S.floor = 1;
      S.entities = [];
      S.doors = [];
      S.chests = [];
      S.map = null;

      S.eventLog = [];

      hide('gameOverModal');
      hide('inventoryModal');
      hide('spellsModal');
      hide('helpModal');

      const init = window.initGame || window.newRun || window.bootstrap || window.generateRun;
      if (typeof init === 'function') init();

      if (window.renderAll) window.renderAll();
      if (window.renderHud) window.renderHud();
      if (window.renderMap) window.renderMap();
      startRunTimer();


    } catch (e) {
  console.error('Hard restart failed:', e);
  if (typeof window.doRestart === 'function') { window.doRestart(); }
}
  };

// <!-- AFTER --> //
const restartBtn = document.getElementById('btnRestart') || document.getElementById('restartButton');
if (restartBtn) {
  restartBtn.onclick = (window.doRestart || window.hardRestartGame);
}


  window.addEventListener('keydown', function (ev) {
    if ((ev.key === 'r' || ev.key === 'R') && document.getElementById('gameOverModal')?.style.display === 'block') {
      ev.preventDefault();
      window.hardRestartGame();
    }
  });
})();

// ===== Debug Menu (secret combo: Ctrl + Alt + D, plus Depth long-press) =====
(function(){
  const dbg = {
    modal: null, inp: null, btn: null, depthChip: null,
    longTimer: null, longMs: 700
  };

  function showDebug(){
    if (!dbg.modal) return;
    dbg.modal.style.display = 'flex';
    document.body.classList.add('noscroll');
    // prefill with current floor
    if (dbg.inp) { dbg.inp.value = state.floor; dbg.inp.focus(); dbg.inp.select(); }
  }
  function hideDebug(){
    if (!dbg.modal) return;
    dbg.modal.style.display = 'none';
    document.body.classList.remove('noscroll');
  }

  function teleportToFloor(n){
  n = Math.max(1, Math.floor(Number(n)||1));
  state.floor = n;
  state.gameOver = false;

  // regenerate & redraw
  gen();
  enemyStep();            // ‚Üê ADD: give enemies a turn immediately
  if (typeof draw === 'function') draw();
  if (typeof updateBars === 'function') updateBars();
  if (typeof updateEquipUI === 'function') updateEquipUI();

  const fc = document.getElementById('floorChip');
  if (fc) fc.textContent = 'Depth ' + state.floor;
  hideDebug();
  log('[debug] Teleported to floor ' + state.floor + '.');
}


  // Wait for DOM (your file already uses DOMContentLoaded in a few places)
  
  document.addEventListener('DOMContentLoaded', ()=>{
    dbg.modal = document.getElementById('debugModal');
    dbg.inp   = document.getElementById('dbgFloor');
    dbg.btn   = document.getElementById('dbgGo');
    dbg.depthChip = document.getElementById('floorChip');

    // Close buttons (re-use your data-close pattern)
    document.querySelectorAll('[data-close="#debugModal"]').forEach(b=>{
      b.addEventListener('click', hideDebug);
    });

    if (dbg.btn) dbg.btn.addEventListener('click', ()=>{
      teleportToFloor(dbg.inp && dbg.inp.value);
    });
    if (dbg.inp) dbg.inp.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter'){ e.preventDefault(); teleportToFloor(dbg.inp.value); }
      e.stopPropagation(); // prevent game movement while typing
    });

    // Secret keyboard combo: Ctrl + Alt + D
    window.addEventListener('keydown', (e)=>{
      if (e.ctrlKey && e.altKey && (e.code === 'KeyD')){
        e.preventDefault();
        showDebug();
      }
    });

    // Touch Easter egg: Triple-tap the "Depth" chip
    if (dbg.depthChip){
      let tapCount = 0;
      let tapTimer = null;
      
      dbg.depthChip.addEventListener('click', (e)=>{
        // prevent unintended clicks if needed, though usually fine on chip
        tapCount++;
        
        // Reset count if too much time passes between taps (e.g. 400ms)
        clearTimeout(tapTimer);
        tapTimer = setTimeout(() => { tapCount = 0; }, 400);

        if (tapCount >= 3){
           showDebug();
           tapCount = 0;
           clearTimeout(tapTimer);
        }
      });
    }

    const spawnBtn = document.getElementById('dbgSpawnShield');
if (spawnBtn) spawnBtn.addEventListener('click', ()=>{
  // ensure pickup dict exists
  state.pickups ||= {};

  const px = state.player.x;
  const py = state.player.y + 1;

  if (!inBounds(px, py)) { log('[debug] Cannot spawn shield: out of bounds.'); return; }
  if (typeof isMerchantTile === 'function' && isMerchantTile(px, py)) { log('[debug] Spot blocked by merchant.'); return; }
  if (enemyAt(px, py)) { log('[debug] Cannot spawn shield: enemy on tile.'); return; }

  const t = state.tiles[py][px];
  if (!(t === 1 || t === 5)) { log('[debug] Tile below is not free floor.'); return; }

  const kxy = key(px, py);
  state.tiles[py][px] = 5;                        // mark as pickup tile
  state.pickups[kxy] = { kind: 'shield', payload: 1 }; // your pickup code already understands 'shield'

  draw?.();
  updateInvBody?.();
  hideDebug?.();

  log('[debug] Dropped a shield one tile below you.');
});
const clayBtn = document.getElementById('dbgGiveClaymore');
if (clayBtn) clayBtn.addEventListener('click', ()=>{
  // ensure weapon inventory exists
  state.inventory ||= {};
  state.inventory.weapons ||= {};

  // grant one Claymore and equip it
  state.inventory.weapons['Claymore'] = (state.inventory.weapons['Claymore']|0) + 1;
  if (typeof equipWeaponByName === 'function') equipWeaponByName('Claymore');

  // refresh UI and close modal
  updateInvBody?.();
  updateEquipUI?.();
  hideDebug?.();

  log('[debug] Gave you a Claymore (equipped).');
});

const unlockBtn = document.getElementById('dbgUnlockEndless');
if (unlockBtn) unlockBtn.addEventListener('click', ()=>{
  localStorage.setItem('endlessUnlocked', '1');
  if (typeof syncEndlessUnlockUI === 'function') syncEndlessUnlockUI();
  log('[debug] Endless Mode unlocked! Check Main Menu.');
  hideDebug?.();
});

// --- NEW: Bomb Debug ---
const bombBtn = document.getElementById('dbgGiveBomb');
if (bombBtn) bombBtn.addEventListener('click', ()=>{
  state.inventory.bombs = (state.inventory.bombs|0) + 5;
  updateInvBody?.();
  hideDebug?.();
  log('[debug] Added 5 Bombs.');
});

// --- NEW: Gold Debug ---
const goldBtn = document.getElementById('dbgGiveGold');
if (goldBtn) goldBtn.addEventListener('click', ()=>{
  state.inventory.gold = (state.inventory.gold|0) + 500;
  if(typeof updateInvBody === 'function') updateInvBody();
  if(typeof hideDebug === 'function') hideDebug();
  log('[debug] Added 500 Gold.');
});

// --- NEW: Warp Debug ---
const warpBtn = document.getElementById('dbgGiveWarp');
if (warpBtn) warpBtn.addEventListener('click', ()=>{
  state.inventory.warpStones = (state.inventory.warpStones|0) + 1;
  updateInvBody?.();
  hideDebug?.();
  log('[debug] Added 1 Warp Stone.');
});

// --- NEW: Key Blade Debug ---
const keyBtn = document.getElementById('dbgGiveKeyBlade');
if (keyBtn) keyBtn.addEventListener('click', ()=>{
  state.inventory.weapons['Key of Destiny'] = 1;
  if(typeof equipWeaponByName === 'function') equipWeaponByName('Key of Destiny');
  updateInvBody?.();
  updateEquipUI?.();
  hideDebug?.();
  log('[debug] Granted Key of Destiny.');
});

// --- NEW: Unlock All Classes Cheat ---
const clsBtn = document.getElementById('dbgUnlockClasses');
if (clsBtn) clsBtn.addEventListener('click', ()=>{
  const m = loadMeta();
  
  // Dynamic Loop: Unlocks EVERYTHING defined in the CLASSES object
  Object.keys(CLASSES).forEach(key => {
    m['unlocked_' + key] = true;
  });
  
  saveMeta(m);
  hideDebug?.();
  log('[debug] All Classes unlocked. Click Restart to see the menu.');
});

// --- NEW: Spawn Key Debug ---
const spKeyBtn = document.getElementById('dbgSpawnKey');
if (spKeyBtn) spKeyBtn.addEventListener('click', ()=>{
  state.pickups ||= {};
  const px = state.player.x;
  const py = state.player.y + 1;

  if (!inBounds(px, py)) { log('[debug] Out of bounds.'); return; }
  const t = state.tiles[py][px];
  if (t !== 1 && t !== 5) { log('[debug] Tile below is not floor.'); return; }

  const kxy = key(px, py);
  state.tiles[py][px] = 5;
  state.pickups[kxy] = { 
    kind: 'weapon', 
    payload: { name: 'Key of Destiny', type: 'one', min:5, max:7 } 
  };

draw?.();
  hideDebug?.();
  log('[debug] Key of Destiny spawned below.');
});

// --- NEW: Spawn Cursed Weapon Debug ---
const cursBtn = document.getElementById('dbgSpawnCursed');
if (cursBtn) cursBtn.addEventListener('click', ()=>{
  state.pickups ||= {};
  const px = state.player.x;
  const py = state.player.y + 1;

  if (!inBounds(px, py)) { log('[debug] Out of bounds.'); return; }
  const t = state.tiles[py][px];
  if (t !== 1 && t !== 5) { log('[debug] Tile below is not floor.'); return; }

  const kxy = key(px, py);
  state.tiles[py][px] = 5;
  state.pickups[kxy] = { 
    kind: 'weapon', 
    payload: { 
      name: 'Cursed Shortsword', 
      type: 'one', 
      min: 7, max: 9, 
      cursed: true, 
      curseType: 'blood' // Test the HP drain curse
    } 
  };

  draw?.();
  hideDebug?.();
  log('[debug] Cursed Shortsword spawned below.');
});
document.getElementById('dbgSpawnGoldWell')?.addEventListener('click', ()=>{
  const px = state.player.x, py = state.player.y + 1;
  state.tiles[py][px] = 1; state.tiles[py+1][px] = 1; // Clear 2x2 area
  state.tiles[py][px+1] = 1; state.tiles[py+1][px+1] = 1;
  state.goldWell = { x: px, y: py, used: false };
  draw?.(); hideDebug?.(); log('[debug] Gold Well spawned.');
});

// --- NEW: Cleric & Warp Debug Wiring ---
document.getElementById('dbgSpawnCleric')?.addEventListener('click', ()=>{
   state.cleric = { x: state.player.x, y: state.player.y + 1 };
   // Force reveal the tile so you can see her immediately
   state.seen.add(key(state.player.x, state.player.y+1)); 
   draw?.(); 
   log('[debug] Cleric spawned below.'); 
   hideDebug?.();
});

document.getElementById('dbgSpawnWarp')?.addEventListener('click', ()=>{
   // Force spawn on floor below player (overwrite whatever is there)
   const px = state.player.x, py = state.player.y + 1;
   
   if (inBounds(px, py)) {
       const kxy = key(px, py);
       
       // Force tile to be a pickup tile (5)
       state.tiles[py][px] = 5; 
       
       // Ensure pickups object exists
       state.pickups = state.pickups || {};
       state.pickups[kxy] = { kind: 'warp', payload: 1 };
       
       draw?.(); 
       log('[debug] Warp Stone spawned below.'); 
       hideDebug?.();
   } else {
       log('[debug] Out of bounds.');
   }
});
// ---------------------------------------
const healBtn = document.getElementById('dbgSpawnHeal');
if (healBtn) healBtn.addEventListener('click', ()=>{
  // ensure pickup dict exists
  state.pickups ||= {};

  const px = state.player.x;
  const py = state.player.y + 1;

  if (!inBounds(px, py)) { log('[debug] Cannot spawn spell: out of bounds.'); return; }
  if (typeof isMerchantTile === 'function' && isMerchantTile(px, py)) { log('[debug] Spot blocked by merchant.'); return; }
  if (enemyAt(px, py)) { log('[debug] Cannot spawn spell: enemy on tile.'); return; }

  const t = state.tiles[py][px];
  if (!(t === 1 || t === 5)) { log('[debug] Tile below is not free floor.'); return; }

  const kxy = key(px, py);
  state.tiles[py][px] = 5;  // mark as pickup

  // Build a Heal scroll payload (same shape your pickup logic expects)
  const healScroll = {
    name: 'Heal',
    cost: (SPELL_BOOK?.Heal?.cost ?? 4),
    tier: tierForDepth(state.floor)
  };

  state.pickups[kxy] = { kind: 'spell', payload: healScroll };

  draw?.();
  updateInvBody?.();
  hideDebug?.();
  log('[debug] Dropped a Heal scroll one tile below you.');
});

const pebbleBtn = document.getElementById('dbgSpawnPebble');
if (pebbleBtn) pebbleBtn.addEventListener('click', ()=>{
  // ensure pickup dict exists
  state.pickups ||= {};

  const px = state.player.x;
  const py = state.player.y + 1;

  if (!inBounds(px, py)) { log('[debug] Cannot spawn spell: out of bounds.'); return; }
  if (typeof isMerchantTile === 'function' && isMerchantTile(px, py)) { log('[debug] Spot blocked by merchant.'); return; }
  if (enemyAt(px, py)) { log('[debug] Cannot spawn spell: enemy on tile.'); return; }

  const t = state.tiles[py][px];
  if (!(t === 1 || t === 5)) { log('[debug] Tile below is not free floor.'); return; }

  const kxy = key(px, py);
  state.tiles[py][px] = 5;  // mark as pickup

  // Build a Pebble scroll payload (same shape your pickup logic expects)
  const pebbleScroll = {
    name: 'Pebble',
    cost: (SPELL_BOOK?.Pebble?.cost ?? 1),
    tier: tierForDepth(state.floor)
  };

  state.pickups[kxy] = { kind: 'spell', payload: pebbleScroll };

  draw?.();
  updateInvBody?.();
  hideDebug?.();
  log('[debug] Dropped a Pebble scroll one tile below you.');
});


const stairsBtn = document.getElementById('dbgSpawnStairs');
if (stairsBtn) stairsBtn.addEventListener('click', ()=>{
  // place stairs at tile directly below player
  const px = state.player.x;
  const py = state.player.y + 1;

  if (!inBounds(px, py)) { log('[debug] Cannot spawn stairs: out of bounds.'); return; }
  if (typeof isMerchantTile === 'function' && isMerchantTile(px, py)) { log('[debug] Spot blocked by merchant.'); return; }
  if (enemyAt(px, py)) { log('[debug] Cannot spawn stairs: enemy on tile.'); return; }

  // must be empty floor or current pickup tile
  const t = state.tiles[py][px];
  if (!(t === 1 || t === 5)) { log('[debug] Tile below must be walkable floor.'); return; }

  // clear any pickup on that tile
  state.pickups ||= {};
  const kxy = key(px, py);
  if (state.pickups[kxy]) delete state.pickups[kxy];

  // 4 = stairs
  state.tiles[py][px] = 4;
  SFX?.bossDown?.();              // nice chime (optional)
  draw?.();
  hideDebug?.();
  log('[debug] Placed stairs one tile below you.');
});
const shrineBtn = document.getElementById('dbgSpawnShrine');
if (shrineBtn) shrineBtn.addEventListener('click', ()=>{
  // Tile ID 6 is used for Shrine (inferred from interact logic)
  const px = state.player.x;
  const py = state.player.y + 1;

  // Basic validation checks (copied from stairs/scroll logic)
  if (!inBounds(px, py)) { log('[debug] Cannot spawn shrine: out of bounds.'); return; }
  if (typeof isMerchantTile === 'function' && isMerchantTile(px, py)) { log('[debug] Spot blocked by merchant.'); return; }
  if (enemyAt(px, py)) { log('[debug] Cannot spawn shrine: enemy on tile.'); return; }

  // Must be empty floor (1) or a pickup tile (5)
  const t = state.tiles[py][px];
  if (!(t === 1 || t === 5)) { log('[debug] Tile below must be walkable floor.'); return; }

  // Clear any existing pickup on that tile
  state.pickups ||= {};
  const kxy = key(px, py);
  if (state.pickups[kxy]) delete state.pickups[kxy];

  // Set the tile to a Shrine (6)
  state.tiles[py][px] = 6;

draw?.();
  log('[debug] Spawned a Shrine one tile below you.');
  hideDebug?.();
});


// ---------------------------------------

// End of new shrine logic

  });
})();

// ====== CODEX SYSTEM ======
const CODEX_KEY = 'dc_codex_v1';
const CODEX_DEF = {
  // Enemies
  Rat: { name:'Rat', desc:'A large, disease-ridden rodent.', seen:false, kills:0 },
  Bat: { name:'Bat', desc:'Flits in the shadows. Drinks blood to heal.', seen:false, kills:0 },
  Slime: { name:'Slime', desc:'A mindless blob of acidic jelly.', seen:false, kills:0 },
  Spider: { name:'Spider', desc:'Web-spinning hunter. Slows its prey.', seen:false, kills:0 },
  Goblin: { name:'Goblin', desc:'Quick and greedy. Steals items.', seen:false, kills:0 },
  Skeleton: { name:'Skeleton', desc:'Animated bones. Often reassembles.', seen:false, kills:0 },
  Mage: { name:'Mage', desc:'Casts spells from a distance.', seen:false, kills:0 },
  Mimic: { name:'Mimic', desc:'A chest with teeth. Surprise!', seen:false, kills:0 },
  // Bosses
  'The Rat King': { name:'The Rat King', desc:'The toxic ruler of the sewers.', seen:false, kills:0 },
  'Count Fang': { name:'Count Fang', desc:'Ancient vampiric horror.', seen:false, kills:0 },
  'Broodmother': { name:'Broodmother', desc:'Queen of the webs.', seen:false, kills:0 },
  'Sir Squish': { name:'Sir Squish', desc:'A slime of noble lineage.', seen:false, kills:0 },
  'Carl': { name:'Carl', desc:'The Goblin King. Likes gold.', seen:false, kills:0 },
  'Mr. Humerus': { name:'Mr. Humerus', desc:'A really big pile of bones.', seen:false, kills:0 },
  'Archon of Ash': { name:'Archon of Ash', desc:'Master of destructive magic.', seen:false, kills:0 },
  'Your Shadow': { name:'Your Shadow', desc:'A dark reflection of yourself.', seen:false, kills:0 },
  'The Mad King': { name:'The Mad King', desc:'The ruler of the dungeon.', seen:false, kills:0 },
  // NPCs
  Merchant: { name:'Merchant', desc:'Buys and sells goods.', seen:false },
  Blacksmith: { name:'Blacksmith', desc:'Repairs your equipment.', seen:false },
 Jester: { name:'Jester', desc:'Plays games of chance.', seen:false },
  Cartographer: { name:'Cartographer', desc:'Maps the floor for a price.', seen:false },
  Cleric: { name:'Cleric', desc:'A holy figure who offers blessings and purification.', seen:false }, // <--- NEW
  // Effects
  MiasmaChamber: { name:'Miasma Chamber', desc:'Poisonous air fills the floor.', seen:false },
  ShadowLabyrinth: { name:'Shadow Labyrinth', desc:'Vision is severely limited.', seen:false },
  Bloodhunt: { name:'Bloodhunt', desc:'Enemies are stronger and faster.', seen:false },
  
  // --- NEW: Endless Floor Effects ---
  GlacialFreeze:  { name:'Glacial Freeze',  desc:'The floor is ice. Movement carries momentum.', seen:false },
  VolatileAether: { name:'Volatile Aether', desc:'Enemies explode shortly after death.', seen:false },
  AntiMagic:      { name:'Anti-Magic Field',desc:'Magic is disabled, but Melee is stronger.', seen:false },
  ArcaneFlux:     { name:'Arcane Flux',     desc:'Magic is amplified, but Melee is weak.', seen:false },
  
// Existing Interactable
  Shrine: { name:'Mystical Shrine', desc:'A holy altar that offers a blessing... or a curse.', seen:false, triggered:0 }, 
  Gold_Well: { name:'Golden Well', desc:'Toss 500g to wish for power.', seen:false, activated:0 }, // <--- ADDED
  
// New Shrine Effect Trackers (Inferred from interact() function)
  Shrine_Mimic:   { name:'Shrine: Summoned Mimic',   desc:'Triggers a surprise Mimic encounter.', seen:false, activated:0 },
  Shrine_Heal:    { name:'Shrine: Full Restore',     desc:'Restores all HP and MP.', seen:false, activated:0 },
  Shrine_XP:      { name:'Shrine: XP Boost',         desc:'Grants +50 Magic XP.', seen:false, activated:0 },
  Shrine_Teleport: { name:'Shrine: Teleport',        desc:'Teleports you to a random floor tile.', seen:false, activated:0 },
  // --- NEW: Shrine Variants ---
  Shrine_Blood:   { name:'Shrine: Blood Altar',      desc:'Demands HP in exchange for an Item.', seen:false, activated:0 },
  Shrine_Midas:   { name:'Shrine: Midas Touch',      desc:'Converts HP directly into Gold.', seen:false, activated:0 },
  // ----------------------------
  
  // New NPC Interaction Trackers
  Merchant_Bought:   { name:'Merchant: Items Bought',    desc:'Total items purchased (potions, tonics, lockpicks).', seen:false, interactions:0 }, 
  Merchant_Sold:     { name:'Merchant: Items Sold',      desc:'Total items sold to the Merchant.', seen:false, interactions:0 },      
  Blacksmith_Repair: { name:'Blacksmith: Repairs Done',  desc:'Total times durability was restored.', seen:false, interactions:0 },  
  Jester_Spin:       { name:'Jester: Wheel Spins',       desc:'Total spins of the Wheel of Fate.', seen:false, interactions:0 },      
  Cartographer_Map:  { name:'Cartographer: Maps Bought', desc:'Total maps purchased.', seen:false, interactions:0 },  
  Cleric_Bless:      { name:'Cleric: Blessings',         desc:'Total times purified or blessed by the Cleric.', seen:false, interactions:0 },

  // --- Weapon Effects ---
  Sharp:    { name:'Prefix: Sharp',    desc:'Refined edge. Increases Min and Max damage by 1.', seen:false },
  Heavy:    { name:'Prefix: Heavy',    desc:'Weighted for impact. Increases Max damage by 3.', seen:false },
  Vampiric: { name:'Prefix: Vampiric', desc:'Drains life essence. Heals 1 HP on successful hits.', seen:false },
Ancient:  { name:'Prefix: Ancient',  desc:'Lost technology. Increases Min and Max damage by 2.', seen:false },
  
  // --- NEW: Curses ---
  Curse_Blood:   { name:'Curse: Blood',   desc:'The weapon hungers. Drains HP periodically.', seen:false },
  Curse_Greed:   { name:'Curse: Greed',   desc:'A hole in your pocket. Drains Gold periodically.', seen:false },
  Curse_Rust:    { name:'Curse: Rust',    desc:'Brittle steel. Durability degrades twice as fast.', seen:false },
  Curse_Frailty: { name:'Curse: Frailty', desc:'Cursed skin. You take +2 Damage from all sources.', seen:false },

  // --- NEW: Weapon Arts ---
  Art_Cleave:   { name:'Art: Cleave',   desc:'(Axe/2H) A circular swing that hits all adjacent foes.', seen:false, activated:0 },
  Art_Pierce:   { name:'Art: Pierce',   desc:'(Spear) Strikes two tiles in a straight line.', seen:false, activated:0 },
  Art_Backstab: { name:'Art: Backstab', desc:'(Sword) Teleports behind a foe for a critical strike.', seen:false, activated:0 },
  Art_Flurry:   { name:'Art: Flurry',   desc:'(Fists) Unleashes three rapid strikes.', seen:false, activated:0 },
};
if (typeof PICK2_POOL !== 'undefined') {
  PICK2_POOL.forEach(p => {
    const niceName = p.id.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
    CODEX_DEF[p.id] = { 
      name: niceName, 
      desc: p.label, 
      seen: false,
      picked: 0  // <--- ADD THIS LINE
    };
  });
}
function loadCodex(){
  const stored = JSON.parse(localStorage.getItem(CODEX_KEY)||'{}');
  const merged = { ...CODEX_DEF }; // Start with the complete default definition
  
  for (const k in stored) {
    if (merged[k]) {
        // Merge the saved data INTO the default definition, 
        // preserving default properties like 'interactions: 0' if not present in 'stored'.
        merged[k] = { 
            ...merged[k],    // default properties (like interactions:0)
            ...stored[k]     // saved values (like kills:10 or seen:true)
        };
    }
  }
  return merged;
}
function saveCodex(c){ localStorage.setItem(CODEX_KEY, JSON.stringify(c)); }

function unlockCodex(key, increment=false){
  if (!key) return;
  const c = loadCodex();
  
  // Handle loose mapping
  let entry = c[key];
  if (!entry && typeof getBossName === 'function') entry = c[getBossName(key)];
  
  if (entry){
    if (!entry.seen) entry.seen = true;
    
    if (increment) {
       // Is it an enemy?
       if (entry.kills !== undefined) {
         entry.kills++;
       } 
       // Is it an Omen?
       else if (entry.picked !== undefined || (typeof PICK2_POOL !== 'undefined' && PICK2_POOL.some(p => p.id === key))) {
         entry.picked = (entry.picked || 0) + 1;
       }
       // Is it a Shrine or NPC tracker? <--- NEW LOGIC HERE
       else if (entry.activated !== undefined) {
         entry.activated = (entry.activated || 0) + 1;
       }
       else if (entry.interactions !== undefined) {
         entry.interactions = (entry.interactions || 0) + 1; // <--- This line relies on interactions:0 being present
       }
    }
    saveCodex(c);
  }
}

function renderCodexUI(){
  const list = document.getElementById('codexContent');
  if (!list) return;
  list.innerHTML = '';
  const c = loadCodex();
  
// === UPDATE THIS LIST ===
  const cats = [
    { title: 'Enemies', keys: ['Rat','Bat','Spider','Slime','Goblin','Skeleton','Mage','Mimic'] },
{ title: 'Bosses', keys: ['The Rat King','Count Fang','Broodmother','Sir Squish','Carl','Mr. Humerus','Archon of Ash','Your Shadow','The Mad King'] },
    // Added 'Cleric' to the list
    { title: 'Inhabitants', keys: ['Merchant','Blacksmith','Jester','Cartographer','Cleric'] },
    { title: 'Discoveries', keys: ['Shrine', 'Gold_Well'] },
    
    // Updated List:
    { title: 'Floor Effects', keys: [
        'MiasmaChamber','ShadowLabyrinth','Bloodhunt',
        'GlacialFreeze','VolatileAether','AntiMagic','ArcaneFlux'
    ]},
    
    { title: 'Shrine Outcomes', keys: ['Shrine_Mimic','Shrine_Heal','Shrine_XP','Shrine_Teleport','Shrine_Blood','Shrine_Midas'] },
    { title: 'NPC Transactions', keys: ['Merchant_Bought','Merchant_Sold','Blacksmith_Repair','Jester_Spin','Cartographer_Map','Cleric_Bless'] },
    
    // 1. ADDED: Weapon Arts Category
    { title: 'Weapon Arts', keys: ['Art_Cleave', 'Art_Pierce', 'Art_Backstab', 'Art_Flurry'] },

    { title: 'Weapon Traits', keys: ['Sharp', 'Heavy', 'Vampiric', 'Ancient'] },
    { title: 'Active Curses', keys: ['Curse_Blood', 'Curse_Greed', 'Curse_Rust', 'Curse_Frailty'] },
    
    { title: 'Omens', keys: (typeof PICK2_POOL !== 'undefined' ? PICK2_POOL.map(p => p.id) : []) }
  ];

  cats.forEach(cat => {
    const h = document.createElement('div');
    h.style.cssText = 'font-weight:900; font-size:22px; color:#f9d65c; margin-top:20px; border-bottom:1px solid #444; padding-bottom:4px;';
    h.textContent = cat.title;
    list.appendChild(h);

    cat.keys.forEach(k => {
      const data = c[k];
      const row = document.createElement('div');
      row.style.cssText = 'display:flex; justify-content:space-between; align-items:center; padding:10px; background:rgba(255,255,255,0.06); border-radius:8px; border:1px solid rgba(255,255,255,0.1);';
      
      if (data && data.seen) {
           let statHtml = '';
           if (data.kills !== undefined) {
             statHtml = `<div style="font-size:12px; color:#ef4444; font-weight:700;">Kills: ${data.kills}</div>`;
           } else if (data.picked !== undefined) {
             statHtml = `<div style="font-size:12px; color:#60a5fa; font-weight:700;">Picked: ${data.picked}</div>`;
           }
           // NEW STATS DISPLAY LOGIC
           else if (data.activated !== undefined) {
             // Custom label for Gold Well vs Shrines
             const label = (k === 'Gold_Well') ? 'Donated' : 'Activated';
             statHtml = `<div style="font-size:12px; color:#7df9ff; font-weight:700;">${label}: ${data.activated}</div>`;
           } 
           else if (data.interactions !== undefined) {
             statHtml = `<div style="font-size:12px; color:#f6d66a; font-weight:700;">Count: ${data.interactions}</div>`;
           }

         row.innerHTML = `
           <div>
             <div style="font-weight:800; font-size:16px; color:#d9e7f5;">${data.name}</div>
             <div style="font-size:14px; opacity:0.8; margin-top:2px;">${data.desc}</div>
           </div>
           <div style="text-align:right; margin-left:12px;">${statHtml}</div>
         `;
      } else {
         row.innerHTML = `<div style="opacity:0.3; font-style:italic; font-weight:600;">???</div>`;
      }
      list.appendChild(row);
    });
  });
}

document.addEventListener('DOMContentLoaded', ()=>{
  document.getElementById('btnCodex')?.addEventListener('click', ()=>{
    renderCodexUI();
    window.openModal('#codexOverlay');
  });
});

</script>

</body>
</html>
